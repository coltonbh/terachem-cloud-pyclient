{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to tccloud For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to tccloud"},{"location":"#welcome-to-tccloud","text":"For full documentation visit mkdocs.org .","title":"Welcome to tccloud"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"About The about page, yo!","title":"About"},{"location":"about/#about","text":"The about page, yo!","title":"About"},{"location":"development/core_decisions/","text":"Core Development Decisions _RequestsClient Class _RequestsClient public http methods (like compute() and result() should always return Python objects. This gives a layer of abstraction between callers who want to think in terms of Python data objects and the _RequestsClient which thinks in terms of http requests and json data structures. FutureResult Class .get() will return either an AtomicResult or a FailedOperation object. From the users perspective they essentially get back a generic \"Result\" object (which will be either an AtomicResult or FailedOperation ) and can check for its status (once complete) by checking result.status . While this separates the user a bit from the \"status\" field returned by the API, I think this is the easiest user interface, i.e., they get back a result from a future_result and can check its status very simply without having to think separately about status fields and results fields They can still access the API returned status field at future_result.status if needed. E.g.,: result = future_result.get() result.success False # If FailedOperation returned result.success True # If AtomicResult returned","title":"Core Development Decisions"},{"location":"development/core_decisions/#core-development-decisions","text":"","title":"Core Development Decisions"},{"location":"development/core_decisions/#_requestsclient-class","text":"_RequestsClient public http methods (like compute() and result() should always return Python objects. This gives a layer of abstraction between callers who want to think in terms of Python data objects and the _RequestsClient which thinks in terms of http requests and json data structures.","title":"_RequestsClient Class"},{"location":"development/core_decisions/#futureresult-class","text":".get() will return either an AtomicResult or a FailedOperation object. From the users perspective they essentially get back a generic \"Result\" object (which will be either an AtomicResult or FailedOperation ) and can check for its status (once complete) by checking result.status . While this separates the user a bit from the \"status\" field returned by the API, I think this is the easiest user interface, i.e., they get back a result from a future_result and can check its status very simply without having to think separately about status fields and results fields They can still access the API returned status field at future_result.status if needed. E.g.,: result = future_result.get() result.success False # If FailedOperation returned result.success True # If AtomicResult returned","title":"FutureResult Class"},{"location":"usage/TCClient/","text":"TCClient The TCClient is the main way you will interact with TeraChem Cloud to make compute requests.","title":"TCClient"},{"location":"usage/TCClient/#tcclient","text":"The TCClient is the main way you will interact with TeraChem Cloud to make compute requests.","title":"TCClient"},{"location":"usage/authentication/","text":"Authentication Authentication is the process of supplying your credentials (usually a username and password) to tccloud so that you can perform computation. tccloud provides a few easy ways for you to authenticate.","title":"Authentication"},{"location":"usage/authentication/#authentication","text":"Authentication is the process of supplying your credentials (usually a username and password) to tccloud so that you can perform computation. tccloud provides a few easy ways for you to authenticate.","title":"Authentication"}]}