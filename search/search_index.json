{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tccloud \ud83d\udd17 A Python Client for TeraChem Cloud. tccloud is a python client that makes performing quantum chemistry calculations easy, fast, and fun. All input and output data structures are based on the QCSchema specification designed by The Molecular Sciences Software Institute . The client provides a simple, yet powerful interface to perform quantum chemistry calculation using nothing but modern python and an internet connection. Compute is generously provided free of charge by the TeraChem Cloud project. Requirements \ud83d\udd17 Python 3.6+ tccloud stands on the shoulders of giants. It internally depends upon QCElemental , httpx , and toml . The AtomicInput , Molecule , Model , and AtomicResult models used throughout the package come directly from QCElemental . They are included in tccloud.models for your convenience. Installation \ud83d\udd17 pip install tccloud Example \ud83d\udd17 The Absolute Minimum \ud83d\udd17 Create a TeraChem Cloud account at https://tccloud.mtzlab.com/signup . Instantiate a client Configure client (only required the very first time you use TCClient ) >>> from tccloud import TCClient >>> client = TCClient () >>> client . configure () # only run the very first time you use TCClient # See supported compute engines >>> client . supported_engines [ 'psi4' , 'terachem_fe' , ... ] # Test connection to TeraChem Cloud >>> client . hello_world ( \"Colton\" ) 'Welcome to TeraChem Cloud, Colton' Create a Molecule More details about the Molecule object can be found here and here . Molecules can be created from pubchem , local files, or using pure python. >>> from tccloud.models import Molecule >>> water = Molecule . from_data ( \"pubchem:water\" ) Specify your compute job using an AtomicInput object More details about the AtomicInput object can be found here . >>> from tccloud.models import AtomicInput >>> atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"energy\" ) Submit a computation, specify a target quantum chemistry engine, and get back an AtomicResult >>> future_result = client . compute ( atomic_input , engine = \"terachem_fe\" ) >>> future_result . status 'STARTED' # Get result >>> result = future_result . get () # Successful computation >>> result . success True >>> result AtomicResult ( driver = 'energy' , model = { 'method' : 'B3LYP' , 'basis' : '6-31g' }, molecule_hash = 'b6ec4fa' ) >>> result . return_result - 76.38545794119997 # Failed computation >>> result . success False # View result >>> result FailedOperation ( error = ComputeError ( error_type = 'input_error' , error_message = 'QCEngine Input Error: Traceback (most recent call last):...' )) >>> from pprint import pprint >>> pprint ( result . error . error_message ) Putting it all together >>> from tccloud import TCClient >>> from tccloud.models import AtomicInput , Molecule >>> client = TCClient () >>> water = Molecule . from_data ( \"pubchem:water\" ) >>> atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"energy\" ) >>> future_result = client . compute ( atomic_input , engine = \"terachem_fe\" ) >>> result = future_result . get () >>> result AtomicResult ( driver = 'energy' , model = { 'method' : 'B3LYP' , 'basis' : '6-31g' }, molecule_hash = 'b6ec4fa' ) >>> result . return_result - 76.38545794119997 Licence \ud83d\udd17 This project is licensed under the terms of the MIT license.","title":"tccloud"},{"location":"#tccloud","text":"A Python Client for TeraChem Cloud. tccloud is a python client that makes performing quantum chemistry calculations easy, fast, and fun. All input and output data structures are based on the QCSchema specification designed by The Molecular Sciences Software Institute . The client provides a simple, yet powerful interface to perform quantum chemistry calculation using nothing but modern python and an internet connection. Compute is generously provided free of charge by the TeraChem Cloud project.","title":"tccloud"},{"location":"#requirements","text":"Python 3.6+ tccloud stands on the shoulders of giants. It internally depends upon QCElemental , httpx , and toml . The AtomicInput , Molecule , Model , and AtomicResult models used throughout the package come directly from QCElemental . They are included in tccloud.models for your convenience.","title":"Requirements"},{"location":"#installation","text":"pip install tccloud","title":"Installation"},{"location":"#example","text":"","title":"Example"},{"location":"#the-absolute-minimum","text":"Create a TeraChem Cloud account at https://tccloud.mtzlab.com/signup . Instantiate a client Configure client (only required the very first time you use TCClient ) >>> from tccloud import TCClient >>> client = TCClient () >>> client . configure () # only run the very first time you use TCClient # See supported compute engines >>> client . supported_engines [ 'psi4' , 'terachem_fe' , ... ] # Test connection to TeraChem Cloud >>> client . hello_world ( \"Colton\" ) 'Welcome to TeraChem Cloud, Colton' Create a Molecule More details about the Molecule object can be found here and here . Molecules can be created from pubchem , local files, or using pure python. >>> from tccloud.models import Molecule >>> water = Molecule . from_data ( \"pubchem:water\" ) Specify your compute job using an AtomicInput object More details about the AtomicInput object can be found here . >>> from tccloud.models import AtomicInput >>> atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"energy\" ) Submit a computation, specify a target quantum chemistry engine, and get back an AtomicResult >>> future_result = client . compute ( atomic_input , engine = \"terachem_fe\" ) >>> future_result . status 'STARTED' # Get result >>> result = future_result . get () # Successful computation >>> result . success True >>> result AtomicResult ( driver = 'energy' , model = { 'method' : 'B3LYP' , 'basis' : '6-31g' }, molecule_hash = 'b6ec4fa' ) >>> result . return_result - 76.38545794119997 # Failed computation >>> result . success False # View result >>> result FailedOperation ( error = ComputeError ( error_type = 'input_error' , error_message = 'QCEngine Input Error: Traceback (most recent call last):...' )) >>> from pprint import pprint >>> pprint ( result . error . error_message ) Putting it all together >>> from tccloud import TCClient >>> from tccloud.models import AtomicInput , Molecule >>> client = TCClient () >>> water = Molecule . from_data ( \"pubchem:water\" ) >>> atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"energy\" ) >>> future_result = client . compute ( atomic_input , engine = \"terachem_fe\" ) >>> result = future_result . get () >>> result AtomicResult ( driver = 'energy' , model = { 'method' : 'B3LYP' , 'basis' : '6-31g' }, molecule_hash = 'b6ec4fa' ) >>> result . return_result - 76.38545794119997","title":"The Absolute Minimum"},{"location":"#licence","text":"This project is licensed under the terms of the MIT license.","title":"Licence"},{"location":"CHANGELOG/","text":"Changelog \ud83d\udd17 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . unreleased \ud83d\udd17 0.4.0 \ud83d\udd17 Added \ud83d\udd17 to_file() and from_file() methods to easily save compute job ids for later retrieval. Changed \ud83d\udd17 Simplified management of task ids between client and server. Only need to send a single id to server even if a batch computation was initiated. Removed \ud83d\udd17 Support for Python3.6. Python3.6 end-of-lif'ed December 23, 2021. 0.3.1 \ud83d\udd17 Added \ud83d\udd17 Decode b64 encoded data returned from server in AtomicResult.extra['tcfe:keywords'] Changed \ud83d\udd17 Updated config.settings.tcfe_config_kwargs = \"tcfe:config -> config.settings.tcfe_keywords = \"tcfe:keywords 0.3.0 \ud83d\udd17 Added \ud83d\udd17 Support for AtomicInput.protocols.native_files . User can now request QC package specific files generated during a computation. Added support for TeraChem-specific native_files . c0/ca0/cb0 bytes files (or any bytes data) placed in AtomicInput.extras['tcfe:keywords'] will be automatically base64 encoded and sent to the server. The enables seeding computations with a wave function as an initial guess. Base64 encoded native_files returned from server will be automatically decoded to bytes. 0.2.4 \ud83d\udd17 Added \ud83d\udd17 Private compute queues to compute() and compute_procedure() 0.2.3 \ud83d\udd17 Added \ud83d\udd17 Batch compute for both compute() and compute_procedure() methods FutureResultGroup for batch computations Changed \ud83d\udd17 Added pydantic BaseModel as base for FutureResult objects. 0.2.2 \ud83d\udd17 Added \ud83d\udd17 Extended documentation to include a Code Reference section and much more comprehensive documentation of the main objects. Added compute_procedure to TCClient for geometry optimizations. Added TCClient.version property for quick version checks. 0.2.1 - 2021-03-05 \ud83d\udd17 Added \ud83d\udd17 Changelog User documentation Website for documentation 0.2.0 - 2021-02-26 \ud83d\udd17 Added \ud83d\udd17 Added TaskStatus enum to hold all task statuses. Basic documentation on main classes. core_decisions.md to document thinking behind architectural choices. Changed \ud83d\udd17 FutureResult.get() to return either an AtomicResult or a FailedComputation Simplified README.md overview to use dictionaries instead of classes. Results in simpler tutorial with fewer imports. 0.1.1 - 2021-01-22 \ud83d\udd17 Added \ud83d\udd17 TCClient that can manage credentials, submit AtomicInput computations, and retrieve AtomicResult output from TeraChem Cloud. _RequestsClient class that handles all network requests to TeraChem Cloud server FutureResults object that is created from a task_id and can be used to retrieve a result once finished.","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"","title":"unreleased"},{"location":"CHANGELOG/#040","text":"","title":"0.4.0"},{"location":"CHANGELOG/#added","text":"to_file() and from_file() methods to easily save compute job ids for later retrieval.","title":"Added"},{"location":"CHANGELOG/#changed","text":"Simplified management of task ids between client and server. Only need to send a single id to server even if a batch computation was initiated.","title":"Changed"},{"location":"CHANGELOG/#removed","text":"Support for Python3.6. Python3.6 end-of-lif'ed December 23, 2021.","title":"Removed"},{"location":"CHANGELOG/#031","text":"","title":"0.3.1"},{"location":"CHANGELOG/#added_1","text":"Decode b64 encoded data returned from server in AtomicResult.extra['tcfe:keywords']","title":"Added"},{"location":"CHANGELOG/#changed_1","text":"Updated config.settings.tcfe_config_kwargs = \"tcfe:config -> config.settings.tcfe_keywords = \"tcfe:keywords","title":"Changed"},{"location":"CHANGELOG/#030","text":"","title":"0.3.0"},{"location":"CHANGELOG/#added_2","text":"Support for AtomicInput.protocols.native_files . User can now request QC package specific files generated during a computation. Added support for TeraChem-specific native_files . c0/ca0/cb0 bytes files (or any bytes data) placed in AtomicInput.extras['tcfe:keywords'] will be automatically base64 encoded and sent to the server. The enables seeding computations with a wave function as an initial guess. Base64 encoded native_files returned from server will be automatically decoded to bytes.","title":"Added"},{"location":"CHANGELOG/#024","text":"","title":"0.2.4"},{"location":"CHANGELOG/#added_3","text":"Private compute queues to compute() and compute_procedure()","title":"Added"},{"location":"CHANGELOG/#023","text":"","title":"0.2.3"},{"location":"CHANGELOG/#added_4","text":"Batch compute for both compute() and compute_procedure() methods FutureResultGroup for batch computations","title":"Added"},{"location":"CHANGELOG/#changed_2","text":"Added pydantic BaseModel as base for FutureResult objects.","title":"Changed"},{"location":"CHANGELOG/#022","text":"","title":"0.2.2"},{"location":"CHANGELOG/#added_5","text":"Extended documentation to include a Code Reference section and much more comprehensive documentation of the main objects. Added compute_procedure to TCClient for geometry optimizations. Added TCClient.version property for quick version checks.","title":"Added"},{"location":"CHANGELOG/#021-2021-03-05","text":"","title":"0.2.1 - 2021-03-05"},{"location":"CHANGELOG/#added_6","text":"Changelog User documentation Website for documentation","title":"Added"},{"location":"CHANGELOG/#020-2021-02-26","text":"","title":"0.2.0 - 2021-02-26"},{"location":"CHANGELOG/#added_7","text":"Added TaskStatus enum to hold all task statuses. Basic documentation on main classes. core_decisions.md to document thinking behind architectural choices.","title":"Added"},{"location":"CHANGELOG/#changed_3","text":"FutureResult.get() to return either an AtomicResult or a FailedComputation Simplified README.md overview to use dictionaries instead of classes. Results in simpler tutorial with fewer imports.","title":"Changed"},{"location":"CHANGELOG/#011-2021-01-22","text":"","title":"0.1.1 - 2021-01-22"},{"location":"CHANGELOG/#added_8","text":"TCClient that can manage credentials, submit AtomicInput computations, and retrieve AtomicResult output from TeraChem Cloud. _RequestsClient class that handles all network requests to TeraChem Cloud server FutureResults object that is created from a task_id and can be used to retrieve a result once finished.","title":"Added"},{"location":"code_reference/AtomicInput/","text":"AtomicInput \ud83d\udd17 The MolSSI Quantum Chemistry Schema Parameters \ud83d\udd17 id : str, Optional The optional ID for the computation. schema_name : ConstrainedStrValue, Default: qcschema_input The QCSchema specification this model conforms to. Explicitly fixed as qcschema_input. schema_version : int, Default: 1 The version number of schema_name to which this model conforms. molecule : :class: Molecule The molecule to use in the computation. driver : {energy,gradient,hessian,properties} Allowed computation driver values. model : :class: Model The computational molecular sciences model to run. keywords : Dict[Any], Default: {} The program-specific keywords to be used. protocols : :class: AtomicResultProtocols , Optional Protocols regarding the manipulation of computational result data. extras : Dict[Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. provenance : :class: Provenance , Optional Provenance information. Source code in qcelemental/models/results.py class AtomicInput ( ProtoModel ): r \"\"\"The MolSSI Quantum Chemistry Schema\"\"\" id : Optional [ str ] = Field ( None , description = \"The optional ID for the computation.\" ) schema_name : constr ( strip_whitespace = True , regex = \"^(qc_?schema_input)$\" ) = Field ( # type: ignore qcschema_input_default , description = ( f \"The QCSchema specification this model conforms to. Explicitly fixed as { qcschema_input_default } .\" ), ) schema_version : int = Field ( 1 , description = \"The version number of ``schema_name`` to which this model conforms.\" ) molecule : Molecule = Field ( ... , description = \"The molecule to use in the computation.\" ) driver : DriverEnum = Field ( ... , description = str ( DriverEnum . __doc__ )) model : Model = Field ( ... , description = str ( Model . __base_doc__ )) keywords : Dict [ str , Any ] = Field ({}, description = \"The program-specific keywords to be used.\" ) protocols : AtomicResultProtocols = Field ( AtomicResultProtocols (), description = str ( AtomicResultProtocols . __base_doc__ ) ) extras : Dict [ str , Any ] = Field ( {}, description = \"Additional information to bundle with the computation. Use for schema development and scratch space.\" , ) provenance : Provenance = Field ( default_factory = partial ( provenance_stamp , __name__ ), description = str ( Provenance . __base_doc__ ) ) class Config ( ProtoModel . Config ): def schema_extra ( schema , model ): schema [ \"$schema\" ] = qcschema_draft def __repr_args__ ( self ) -> \"ReprArgs\" : return [ ( \"driver\" , self . driver . value ), ( \"model\" , self . model . dict ()), ( \"molecule_hash\" , self . molecule . get_hash ()[: 7 ]), ] Attributes \ud83d\udd17 driver : DriverEnum pydantic-field required \ud83d\udd17 Allowed computation driver values. extras : Dict [ str , Any ] pydantic-field \ud83d\udd17 Additional information to bundle with the computation. Use for schema development and scratch space. id : str pydantic-field \ud83d\udd17 The optional ID for the computation. keywords : Dict [ str , Any ] pydantic-field \ud83d\udd17 The program-specific keywords to be used. model : Model pydantic-field required \ud83d\udd17 The computational molecular sciences model to run. molecule : Molecule pydantic-field required \ud83d\udd17 The molecule to use in the computation. protocols : AtomicResultProtocols pydantic-field \ud83d\udd17 Protocols regarding the manipulation of computational result data. provenance : Provenance pydantic-field \ud83d\udd17 Provenance information. schema_name : ConstrainedStrValue pydantic-field \ud83d\udd17 The QCSchema specification this model conforms to. Explicitly fixed as qcschema_input. schema_version : int pydantic-field \ud83d\udd17 The version number of schema_name to which this model conforms. Config ( Config ) \ud83d\udd17 Source code in qcelemental/models/results.py class Config ( ProtoModel . Config ): force_skip_defaults = True allow_mutation : bool inherited \ud83d\udd17 extra : str inherited \ud83d\udd17 force_skip_defaults : bool inherited \ud83d\udd17 json_encoders : Dict [ str , Any ] inherited \ud83d\udd17 serialize_default_excludes : Set inherited \ud83d\udd17 serialize_skip_defaults : bool inherited \ud83d\udd17 schema_extra ( schema , model ) \ud83d\udd17 Source code in qcelemental/models/results.py def schema_extra ( schema , model ): schema [ \"$schema\" ] = qcschema_draft Methods \ud83d\udd17 compare ( self , other : Union [ ProtoModel , pydantic . main . BaseModel ], ** kwargs ) -> bool inherited \ud83d\udd17 Compares the current object to the provided object recursively. Parameters \ud83d\udd17 other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive . Returns \ud83d\udd17 bool True if the objects match. Source code in qcelemental/models/results.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : r \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs ) dict ( self , ** kwargs ) -> Dict [ str , Any ] inherited \ud83d\udd17 Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/results.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" ) json ( self , ** kwargs ) inherited \ud83d\udd17 Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/results.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs ) serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None ) -> Union [ bytes , str ] inherited \ud83d\udd17 Generates a serialized representation of the model Parameters \ud83d\udd17 encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None . Returns \ud83d\udd17 Union[bytes, str] The serialized model. Source code in qcelemental/models/results.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: r \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"AtomicInput"},{"location":"code_reference/AtomicInput/#atomicinput","text":"The MolSSI Quantum Chemistry Schema","title":"AtomicInput"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput--parameters","text":"id : str, Optional The optional ID for the computation. schema_name : ConstrainedStrValue, Default: qcschema_input The QCSchema specification this model conforms to. Explicitly fixed as qcschema_input. schema_version : int, Default: 1 The version number of schema_name to which this model conforms. molecule : :class: Molecule The molecule to use in the computation. driver : {energy,gradient,hessian,properties} Allowed computation driver values. model : :class: Model The computational molecular sciences model to run. keywords : Dict[Any], Default: {} The program-specific keywords to be used. protocols : :class: AtomicResultProtocols , Optional Protocols regarding the manipulation of computational result data. extras : Dict[Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. provenance : :class: Provenance , Optional Provenance information. Source code in qcelemental/models/results.py class AtomicInput ( ProtoModel ): r \"\"\"The MolSSI Quantum Chemistry Schema\"\"\" id : Optional [ str ] = Field ( None , description = \"The optional ID for the computation.\" ) schema_name : constr ( strip_whitespace = True , regex = \"^(qc_?schema_input)$\" ) = Field ( # type: ignore qcschema_input_default , description = ( f \"The QCSchema specification this model conforms to. Explicitly fixed as { qcschema_input_default } .\" ), ) schema_version : int = Field ( 1 , description = \"The version number of ``schema_name`` to which this model conforms.\" ) molecule : Molecule = Field ( ... , description = \"The molecule to use in the computation.\" ) driver : DriverEnum = Field ( ... , description = str ( DriverEnum . __doc__ )) model : Model = Field ( ... , description = str ( Model . __base_doc__ )) keywords : Dict [ str , Any ] = Field ({}, description = \"The program-specific keywords to be used.\" ) protocols : AtomicResultProtocols = Field ( AtomicResultProtocols (), description = str ( AtomicResultProtocols . __base_doc__ ) ) extras : Dict [ str , Any ] = Field ( {}, description = \"Additional information to bundle with the computation. Use for schema development and scratch space.\" , ) provenance : Provenance = Field ( default_factory = partial ( provenance_stamp , __name__ ), description = str ( Provenance . __base_doc__ ) ) class Config ( ProtoModel . Config ): def schema_extra ( schema , model ): schema [ \"$schema\" ] = qcschema_draft def __repr_args__ ( self ) -> \"ReprArgs\" : return [ ( \"driver\" , self . driver . value ), ( \"model\" , self . model . dict ()), ( \"molecule_hash\" , self . molecule . get_hash ()[: 7 ]), ]","title":"Parameters"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput-attributes","text":"","title":"Attributes"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.driver","text":"Allowed computation driver values.","title":"driver"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.extras","text":"Additional information to bundle with the computation. Use for schema development and scratch space.","title":"extras"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.id","text":"The optional ID for the computation.","title":"id"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.keywords","text":"The program-specific keywords to be used.","title":"keywords"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.model","text":"The computational molecular sciences model to run.","title":"model"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.molecule","text":"The molecule to use in the computation.","title":"molecule"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.protocols","text":"Protocols regarding the manipulation of computational result data.","title":"protocols"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.provenance","text":"Provenance information.","title":"provenance"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.schema_name","text":"The QCSchema specification this model conforms to. Explicitly fixed as qcschema_input.","title":"schema_name"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.schema_version","text":"The version number of schema_name to which this model conforms.","title":"schema_version"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.Config","text":"Source code in qcelemental/models/results.py class Config ( ProtoModel . Config ): force_skip_defaults = True","title":"Config"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.Config.allow_mutation","text":"","title":"allow_mutation"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.Config.extra","text":"","title":"extra"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.Config.force_skip_defaults","text":"","title":"force_skip_defaults"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.Config.json_encoders","text":"","title":"json_encoders"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.Config.serialize_default_excludes","text":"","title":"serialize_default_excludes"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.Config.serialize_skip_defaults","text":"","title":"serialize_skip_defaults"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.Config.schema_extra","text":"Source code in qcelemental/models/results.py def schema_extra ( schema , model ): schema [ \"$schema\" ] = qcschema_draft","title":"schema_extra()"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput-methods","text":"","title":"Methods"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.compare","text":"Compares the current object to the provided object recursively.","title":"compare()"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.compare--parameters","text":"other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive .","title":"Parameters"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.compare--returns","text":"bool True if the objects match. Source code in qcelemental/models/results.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : r \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs )","title":"Returns"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.dict","text":"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/results.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" )","title":"dict()"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.json","text":"Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/results.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs )","title":"json()"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.serialize","text":"Generates a serialized representation of the model","title":"serialize()"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.serialize--parameters","text":"encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None .","title":"Parameters"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.serialize--returns","text":"Union[bytes, str] The serialized model. Source code in qcelemental/models/results.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: r \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Returns"},{"location":"code_reference/AtomicResult/","text":"AtomicResult \ud83d\udd17 Results from a CMS program execution. Parameters \ud83d\udd17 id : str, Optional The optional ID for the computation. schema_name : ConstrainedStrValue, Default: qcschema_output The QCSchema specification this model conforms to. Explicitly fixed as qcschema_output. schema_version : int, Default: 1 The version number of schema_name to which this model conforms. molecule : :class: Molecule The molecule to use in the computation. driver : {energy,gradient,hessian,properties} Allowed computation driver values. model : :class: Model The computational molecular sciences model to run. keywords : Dict[Any], Default: {} The program-specific keywords to be used. protocols : :class: AtomicResultProtocols , Optional Protocols regarding the manipulation of computational result data. extras : Dict[Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. provenance : :class: Provenance Provenance information. properties : :class: AtomicResultProperties Named properties of quantum chemistry computations following the MolSSI QCSchema. All arrays are stored flat but must be reshapable into the dimensions in attribute ``shape``, with abbreviations as follows: * nao: number of atomic orbitals = calcinfo_nbasis * nmo: number of molecular orbitals wavefunction : :class: WavefunctionProperties , Optional Wavefunction properties resulting from a computation. Matrix quantities are stored in column-major order. Presence and contents configurable by protocol. return_result : Union[float, Array, Dict[Any]] The primary return specified by the driver field. Scalar if energy; array if gradient or hessian; dictionary with property keys if properties. stdout : str, Optional The primary logging output of the program, whether natively standard output or a file. Presence vs. absence (or null-ness?) configurable by protocol. stderr : str, Optional The standard error of the program execution. native_files : Dict[Any], Optional DSL files. success : bool The success of program execution. If False, other fields may be blank. error : :class: ComputeError , Optional Complete description of the error from an unsuccessful program execution. Source code in qcelemental/models/results.py class AtomicResult ( AtomicInput ): r \"\"\"Results from a CMS program execution.\"\"\" schema_name : constr ( strip_whitespace = True , regex = \"^(qc_?schema_output)$\" ) = Field ( # type: ignore qcschema_output_default , description = ( f \"The QCSchema specification this model conforms to. Explicitly fixed as { qcschema_output_default } .\" ), ) properties : AtomicResultProperties = Field ( ... , description = str ( AtomicResultProperties . __base_doc__ )) wavefunction : Optional [ WavefunctionProperties ] = Field ( None , description = str ( WavefunctionProperties . __base_doc__ )) return_result : Union [ float , Array [ float ], Dict [ str , Any ]] = Field ( ... , description = \"The primary return specified by the ``driver`` field. Scalar if energy; array if gradient or hessian; dictionary with property keys if properties.\" , ) # type: ignore stdout : Optional [ str ] = Field ( None , description = \"The primary logging output of the program, whether natively standard output or a file. Presence vs. absence (or null-ness?) configurable by protocol.\" , ) stderr : Optional [ str ] = Field ( None , description = \"The standard error of the program execution.\" ) native_files : Optional [ Dict [ str , Any ]] = Field ( None , description = \"DSL files.\" ) success : bool = Field ( ... , description = \"The success of program execution. If False, other fields may be blank.\" ) error : Optional [ ComputeError ] = Field ( None , description = str ( ComputeError . __base_doc__ )) provenance : Provenance = Field ( ... , description = str ( Provenance . __base_doc__ )) @validator ( \"schema_name\" , pre = True ) def _input_to_output ( cls , v ): r \"\"\"If qcschema_input is passed in, cast it to output, otherwise no\"\"\" if v . lower () . strip () in [ qcschema_input_default , qcschema_output_default ]: return qcschema_output_default raise ValueError ( \"Only {0} or {1} is allowed for schema_name, \" \"which will be converted to {0} \" . format ( qcschema_output_default , qcschema_input_default ) ) @validator ( \"return_result\" ) def _validate_return_result ( cls , v , values ): if values [ \"driver\" ] == \"gradient\" : v = np . asarray ( v ) . reshape ( - 1 , 3 ) elif values [ \"driver\" ] == \"hessian\" : v = np . asarray ( v ) nsq = int ( v . size ** 0.5 ) v . shape = ( nsq , nsq ) return v @validator ( \"wavefunction\" , pre = True ) def _wavefunction_protocol ( cls , value , values ): # We are pre, gotta do extra checks if value is None : return value elif isinstance ( value , dict ): wfn = value . copy () elif isinstance ( value , WavefunctionProperties ): wfn = value . dict () else : raise ValueError ( \"wavefunction must be None, a dict, or a WavefunctionProperties object.\" ) # Do not propagate validation errors if \"protocols\" not in values : raise ValueError ( \"Protocols was not properly formed.\" ) # Handle restricted restricted = wfn . get ( \"restricted\" , None ) if restricted is None : raise ValueError ( \"`restricted` is required.\" ) if restricted : for k in list ( wfn . keys ()): if k . endswith ( \"_b\" ): wfn . pop ( k ) # Handle protocols wfnp = values [ \"protocols\" ] . wavefunction return_keep = None if wfnp == \"all\" : pass elif wfnp == \"none\" : wfn = None elif wfnp == \"return_results\" : return_keep = [ \"orbitals_a\" , \"orbitals_b\" , \"density_a\" , \"density_b\" , \"fock_a\" , \"fock_b\" , \"eigenvalues_a\" , \"eigenvalues_b\" , \"occupations_a\" , \"occupations_b\" , ] elif wfnp == \"orbitals_and_eigenvalues\" : return_keep = [ \"orbitals_a\" , \"orbitals_b\" , \"eigenvalues_a\" , \"eigenvalues_b\" ] else : raise ValueError ( f \"Protocol `wavefunction: { wfnp } ` is not understood.\" ) if return_keep is not None : ret_wfn = { \"restricted\" : restricted } if \"basis\" in wfn : ret_wfn [ \"basis\" ] = wfn [ \"basis\" ] for rk in return_keep : key = wfn . get ( rk , None ) if key is None : continue ret_wfn [ rk ] = key ret_wfn [ key ] = wfn [ key ] return ret_wfn else : return wfn @validator ( \"stdout\" ) def _stdout_protocol ( cls , value , values ): # Do not propagate validation errors if \"protocols\" not in values : raise ValueError ( \"Protocols was not properly formed.\" ) outp = values [ \"protocols\" ] . stdout if outp is True : return value elif outp is False : return None else : raise ValueError ( f \"Protocol `stdout: { outp } ` is not understood\" ) @validator ( \"native_files\" ) def _native_file_protocol ( cls , value , values ): ancp = values [ \"protocols\" ] . native_files if ancp == \"all\" : return value elif ancp == \"none\" : return None elif ancp == \"input\" : return_keep = [ \"input\" ] if value is None : files = {} else : files = value . copy () else : raise ValueError ( f \"Protocol `native_files: { ancp } ` is not understood\" ) ret = {} for rk in return_keep : ret [ rk ] = files . get ( rk , None ) return ret Attributes \ud83d\udd17 driver : DriverEnum pydantic-field required \ud83d\udd17 Allowed computation driver values. error : ComputeError pydantic-field \ud83d\udd17 Complete description of the error from an unsuccessful program execution. extras : Dict [ str , Any ] pydantic-field \ud83d\udd17 Additional information to bundle with the computation. Use for schema development and scratch space. id : str pydantic-field \ud83d\udd17 The optional ID for the computation. keywords : Dict [ str , Any ] pydantic-field \ud83d\udd17 The program-specific keywords to be used. model : Model pydantic-field required \ud83d\udd17 The computational molecular sciences model to run. molecule : Molecule pydantic-field required \ud83d\udd17 The molecule to use in the computation. native_files : Dict [ str , Any ] pydantic-field \ud83d\udd17 DSL files. properties : AtomicResultProperties pydantic-field required \ud83d\udd17 Named properties of quantum chemistry computations following the MolSSI QCSchema. All arrays are stored flat but must be reshapable into the dimensions in attribute ``shape``, with abbreviations as follows: * nao: number of atomic orbitals = calcinfo_nbasis * nmo: number of molecular orbitals protocols : AtomicResultProtocols pydantic-field \ud83d\udd17 Protocols regarding the manipulation of computational result data. provenance : Provenance pydantic-field required \ud83d\udd17 Provenance information. return_result : Union [ float , qcelemental . models . types . Array , Dict [ str , Any ]] pydantic-field required \ud83d\udd17 The primary return specified by the driver field. Scalar if energy; array if gradient or hessian; dictionary with property keys if properties. schema_name : ConstrainedStrValue pydantic-field \ud83d\udd17 The QCSchema specification this model conforms to. Explicitly fixed as qcschema_output. schema_version : int pydantic-field \ud83d\udd17 The version number of schema_name to which this model conforms. stderr : str pydantic-field \ud83d\udd17 The standard error of the program execution. stdout : str pydantic-field \ud83d\udd17 The primary logging output of the program, whether natively standard output or a file. Presence vs. absence (or null-ness?) configurable by protocol. success : bool pydantic-field required \ud83d\udd17 The success of program execution. If False, other fields may be blank. wavefunction : WavefunctionProperties pydantic-field \ud83d\udd17 Wavefunction properties resulting from a computation. Matrix quantities are stored in column-major order. Presence and contents configurable by protocol. Config ( Config ) inherited \ud83d\udd17 Source code in qcelemental/models/results.py class Config ( ProtoModel . Config ): force_skip_defaults = True allow_mutation : bool inherited \ud83d\udd17 extra : str inherited \ud83d\udd17 force_skip_defaults : bool inherited \ud83d\udd17 json_encoders : Dict [ str , Any ] inherited \ud83d\udd17 serialize_default_excludes : Set inherited \ud83d\udd17 serialize_skip_defaults : bool inherited \ud83d\udd17 schema_extra ( schema , model ) \ud83d\udd17 Source code in qcelemental/models/results.py def schema_extra ( schema , model ): schema [ \"$schema\" ] = qcschema_draft Methods \ud83d\udd17 compare ( self , other : Union [ ProtoModel , pydantic . main . BaseModel ], ** kwargs ) -> bool inherited \ud83d\udd17 Compares the current object to the provided object recursively. Parameters \ud83d\udd17 other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive . Returns \ud83d\udd17 bool True if the objects match. Source code in qcelemental/models/results.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : r \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs ) dict ( self , ** kwargs ) -> Dict [ str , Any ] inherited \ud83d\udd17 Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/results.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" ) json ( self , ** kwargs ) inherited \ud83d\udd17 Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/results.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs ) serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None ) -> Union [ bytes , str ] inherited \ud83d\udd17 Generates a serialized representation of the model Parameters \ud83d\udd17 encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None . Returns \ud83d\udd17 Union[bytes, str] The serialized model. Source code in qcelemental/models/results.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: r \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"AtomicResult"},{"location":"code_reference/AtomicResult/#atomicresult","text":"Results from a CMS program execution.","title":"AtomicResult"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult--parameters","text":"id : str, Optional The optional ID for the computation. schema_name : ConstrainedStrValue, Default: qcschema_output The QCSchema specification this model conforms to. Explicitly fixed as qcschema_output. schema_version : int, Default: 1 The version number of schema_name to which this model conforms. molecule : :class: Molecule The molecule to use in the computation. driver : {energy,gradient,hessian,properties} Allowed computation driver values. model : :class: Model The computational molecular sciences model to run. keywords : Dict[Any], Default: {} The program-specific keywords to be used. protocols : :class: AtomicResultProtocols , Optional Protocols regarding the manipulation of computational result data. extras : Dict[Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. provenance : :class: Provenance Provenance information. properties : :class: AtomicResultProperties Named properties of quantum chemistry computations following the MolSSI QCSchema. All arrays are stored flat but must be reshapable into the dimensions in attribute ``shape``, with abbreviations as follows: * nao: number of atomic orbitals = calcinfo_nbasis * nmo: number of molecular orbitals wavefunction : :class: WavefunctionProperties , Optional Wavefunction properties resulting from a computation. Matrix quantities are stored in column-major order. Presence and contents configurable by protocol. return_result : Union[float, Array, Dict[Any]] The primary return specified by the driver field. Scalar if energy; array if gradient or hessian; dictionary with property keys if properties. stdout : str, Optional The primary logging output of the program, whether natively standard output or a file. Presence vs. absence (or null-ness?) configurable by protocol. stderr : str, Optional The standard error of the program execution. native_files : Dict[Any], Optional DSL files. success : bool The success of program execution. If False, other fields may be blank. error : :class: ComputeError , Optional Complete description of the error from an unsuccessful program execution. Source code in qcelemental/models/results.py class AtomicResult ( AtomicInput ): r \"\"\"Results from a CMS program execution.\"\"\" schema_name : constr ( strip_whitespace = True , regex = \"^(qc_?schema_output)$\" ) = Field ( # type: ignore qcschema_output_default , description = ( f \"The QCSchema specification this model conforms to. Explicitly fixed as { qcschema_output_default } .\" ), ) properties : AtomicResultProperties = Field ( ... , description = str ( AtomicResultProperties . __base_doc__ )) wavefunction : Optional [ WavefunctionProperties ] = Field ( None , description = str ( WavefunctionProperties . __base_doc__ )) return_result : Union [ float , Array [ float ], Dict [ str , Any ]] = Field ( ... , description = \"The primary return specified by the ``driver`` field. Scalar if energy; array if gradient or hessian; dictionary with property keys if properties.\" , ) # type: ignore stdout : Optional [ str ] = Field ( None , description = \"The primary logging output of the program, whether natively standard output or a file. Presence vs. absence (or null-ness?) configurable by protocol.\" , ) stderr : Optional [ str ] = Field ( None , description = \"The standard error of the program execution.\" ) native_files : Optional [ Dict [ str , Any ]] = Field ( None , description = \"DSL files.\" ) success : bool = Field ( ... , description = \"The success of program execution. If False, other fields may be blank.\" ) error : Optional [ ComputeError ] = Field ( None , description = str ( ComputeError . __base_doc__ )) provenance : Provenance = Field ( ... , description = str ( Provenance . __base_doc__ )) @validator ( \"schema_name\" , pre = True ) def _input_to_output ( cls , v ): r \"\"\"If qcschema_input is passed in, cast it to output, otherwise no\"\"\" if v . lower () . strip () in [ qcschema_input_default , qcschema_output_default ]: return qcschema_output_default raise ValueError ( \"Only {0} or {1} is allowed for schema_name, \" \"which will be converted to {0} \" . format ( qcschema_output_default , qcschema_input_default ) ) @validator ( \"return_result\" ) def _validate_return_result ( cls , v , values ): if values [ \"driver\" ] == \"gradient\" : v = np . asarray ( v ) . reshape ( - 1 , 3 ) elif values [ \"driver\" ] == \"hessian\" : v = np . asarray ( v ) nsq = int ( v . size ** 0.5 ) v . shape = ( nsq , nsq ) return v @validator ( \"wavefunction\" , pre = True ) def _wavefunction_protocol ( cls , value , values ): # We are pre, gotta do extra checks if value is None : return value elif isinstance ( value , dict ): wfn = value . copy () elif isinstance ( value , WavefunctionProperties ): wfn = value . dict () else : raise ValueError ( \"wavefunction must be None, a dict, or a WavefunctionProperties object.\" ) # Do not propagate validation errors if \"protocols\" not in values : raise ValueError ( \"Protocols was not properly formed.\" ) # Handle restricted restricted = wfn . get ( \"restricted\" , None ) if restricted is None : raise ValueError ( \"`restricted` is required.\" ) if restricted : for k in list ( wfn . keys ()): if k . endswith ( \"_b\" ): wfn . pop ( k ) # Handle protocols wfnp = values [ \"protocols\" ] . wavefunction return_keep = None if wfnp == \"all\" : pass elif wfnp == \"none\" : wfn = None elif wfnp == \"return_results\" : return_keep = [ \"orbitals_a\" , \"orbitals_b\" , \"density_a\" , \"density_b\" , \"fock_a\" , \"fock_b\" , \"eigenvalues_a\" , \"eigenvalues_b\" , \"occupations_a\" , \"occupations_b\" , ] elif wfnp == \"orbitals_and_eigenvalues\" : return_keep = [ \"orbitals_a\" , \"orbitals_b\" , \"eigenvalues_a\" , \"eigenvalues_b\" ] else : raise ValueError ( f \"Protocol `wavefunction: { wfnp } ` is not understood.\" ) if return_keep is not None : ret_wfn = { \"restricted\" : restricted } if \"basis\" in wfn : ret_wfn [ \"basis\" ] = wfn [ \"basis\" ] for rk in return_keep : key = wfn . get ( rk , None ) if key is None : continue ret_wfn [ rk ] = key ret_wfn [ key ] = wfn [ key ] return ret_wfn else : return wfn @validator ( \"stdout\" ) def _stdout_protocol ( cls , value , values ): # Do not propagate validation errors if \"protocols\" not in values : raise ValueError ( \"Protocols was not properly formed.\" ) outp = values [ \"protocols\" ] . stdout if outp is True : return value elif outp is False : return None else : raise ValueError ( f \"Protocol `stdout: { outp } ` is not understood\" ) @validator ( \"native_files\" ) def _native_file_protocol ( cls , value , values ): ancp = values [ \"protocols\" ] . native_files if ancp == \"all\" : return value elif ancp == \"none\" : return None elif ancp == \"input\" : return_keep = [ \"input\" ] if value is None : files = {} else : files = value . copy () else : raise ValueError ( f \"Protocol `native_files: { ancp } ` is not understood\" ) ret = {} for rk in return_keep : ret [ rk ] = files . get ( rk , None ) return ret","title":"Parameters"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult-attributes","text":"","title":"Attributes"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.driver","text":"Allowed computation driver values.","title":"driver"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.error","text":"Complete description of the error from an unsuccessful program execution.","title":"error"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.extras","text":"Additional information to bundle with the computation. Use for schema development and scratch space.","title":"extras"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.id","text":"The optional ID for the computation.","title":"id"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.keywords","text":"The program-specific keywords to be used.","title":"keywords"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.model","text":"The computational molecular sciences model to run.","title":"model"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.molecule","text":"The molecule to use in the computation.","title":"molecule"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.native_files","text":"DSL files.","title":"native_files"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.properties","text":"Named properties of quantum chemistry computations following the MolSSI QCSchema. All arrays are stored flat but must be reshapable into the dimensions in attribute ``shape``, with abbreviations as follows: * nao: number of atomic orbitals = calcinfo_nbasis * nmo: number of molecular orbitals","title":"properties"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.protocols","text":"Protocols regarding the manipulation of computational result data.","title":"protocols"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.provenance","text":"Provenance information.","title":"provenance"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.return_result","text":"The primary return specified by the driver field. Scalar if energy; array if gradient or hessian; dictionary with property keys if properties.","title":"return_result"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.schema_name","text":"The QCSchema specification this model conforms to. Explicitly fixed as qcschema_output.","title":"schema_name"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.schema_version","text":"The version number of schema_name to which this model conforms.","title":"schema_version"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.stderr","text":"The standard error of the program execution.","title":"stderr"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.stdout","text":"The primary logging output of the program, whether natively standard output or a file. Presence vs. absence (or null-ness?) configurable by protocol.","title":"stdout"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.success","text":"The success of program execution. If False, other fields may be blank.","title":"success"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.wavefunction","text":"Wavefunction properties resulting from a computation. Matrix quantities are stored in column-major order. Presence and contents configurable by protocol.","title":"wavefunction"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.Config","text":"Source code in qcelemental/models/results.py class Config ( ProtoModel . Config ): force_skip_defaults = True","title":"Config"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.Config.allow_mutation","text":"","title":"allow_mutation"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.Config.extra","text":"","title":"extra"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.Config.force_skip_defaults","text":"","title":"force_skip_defaults"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.Config.json_encoders","text":"","title":"json_encoders"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.Config.serialize_default_excludes","text":"","title":"serialize_default_excludes"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.Config.serialize_skip_defaults","text":"","title":"serialize_skip_defaults"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.Config.schema_extra","text":"Source code in qcelemental/models/results.py def schema_extra ( schema , model ): schema [ \"$schema\" ] = qcschema_draft","title":"schema_extra()"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult-methods","text":"","title":"Methods"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.compare","text":"Compares the current object to the provided object recursively.","title":"compare()"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.compare--parameters","text":"other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive .","title":"Parameters"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.compare--returns","text":"bool True if the objects match. Source code in qcelemental/models/results.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : r \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs )","title":"Returns"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.dict","text":"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/results.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" )","title":"dict()"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.json","text":"Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/results.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs )","title":"json()"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.serialize","text":"Generates a serialized representation of the model","title":"serialize()"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.serialize--parameters","text":"encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None .","title":"Parameters"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.serialize--returns","text":"Union[bytes, str] The serialized model. Source code in qcelemental/models/results.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: r \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Returns"},{"location":"code_reference/ComputeError/","text":"ComputeError \ud83d\udd17 Complete description of the error from an unsuccessful program execution. Parameters \ud83d\udd17 error_type : str The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py error_message : str Text associated with the thrown error. This is often the backtrace, but it can contain additional information as well. extras : Dict[Any], Optional Additional information to bundle with the error. Source code in qcelemental/models/common_models.py class ComputeError ( ProtoModel ): \"\"\"Complete description of the error from an unsuccessful program execution.\"\"\" error_type : str = Field ( # type: ignore ... , # Error enumeration not yet strict description = \"The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py\" , ) error_message : str = Field ( # type: ignore ... , description = \"Text associated with the thrown error. This is often the backtrace, but it can contain additional \" \"information as well.\" , ) extras : Optional [ Dict [ str , Any ]] = Field ( # type: ignore None , description = \"Additional information to bundle with the error.\" , ) class Config : repr_style = [ \"error_type\" , \"error_message\" ] def __repr_args__ ( self ) -> \"ReprArgs\" : return [( \"error_type\" , self . error_type ), ( \"error_message\" , self . error_message )] Attributes \ud83d\udd17 error_message : str pydantic-field required \ud83d\udd17 Text associated with the thrown error. This is often the backtrace, but it can contain additional information as well. error_type : str pydantic-field required \ud83d\udd17 The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py extras : Dict [ str , Any ] pydantic-field \ud83d\udd17 Additional information to bundle with the error. Config \ud83d\udd17 Source code in qcelemental/models/common_models.py class Config ( ProtoModel . Config ): canonical_repr = True extra : str = \"allow\" def schema_extra ( schema , model ): schema [ \"$schema\" ] = qcschema_draft Methods \ud83d\udd17 compare ( self , other : Union [ ProtoModel , pydantic . main . BaseModel ], ** kwargs ) -> bool inherited \ud83d\udd17 Compares the current object to the provided object recursively. Parameters \ud83d\udd17 other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive . Returns \ud83d\udd17 bool True if the objects match. Source code in qcelemental/models/common_models.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : r \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs ) dict ( self , ** kwargs ) -> Dict [ str , Any ] inherited \ud83d\udd17 Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/common_models.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" ) json ( self , ** kwargs ) inherited \ud83d\udd17 Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/common_models.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs ) serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None ) -> Union [ bytes , str ] inherited \ud83d\udd17 Generates a serialized representation of the model Parameters \ud83d\udd17 encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None . Returns \ud83d\udd17 Union[bytes, str] The serialized model. Source code in qcelemental/models/common_models.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: r \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"ComputeError"},{"location":"code_reference/ComputeError/#computeerror","text":"Complete description of the error from an unsuccessful program execution.","title":"ComputeError"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError--parameters","text":"error_type : str The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py error_message : str Text associated with the thrown error. This is often the backtrace, but it can contain additional information as well. extras : Dict[Any], Optional Additional information to bundle with the error. Source code in qcelemental/models/common_models.py class ComputeError ( ProtoModel ): \"\"\"Complete description of the error from an unsuccessful program execution.\"\"\" error_type : str = Field ( # type: ignore ... , # Error enumeration not yet strict description = \"The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py\" , ) error_message : str = Field ( # type: ignore ... , description = \"Text associated with the thrown error. This is often the backtrace, but it can contain additional \" \"information as well.\" , ) extras : Optional [ Dict [ str , Any ]] = Field ( # type: ignore None , description = \"Additional information to bundle with the error.\" , ) class Config : repr_style = [ \"error_type\" , \"error_message\" ] def __repr_args__ ( self ) -> \"ReprArgs\" : return [( \"error_type\" , self . error_type ), ( \"error_message\" , self . error_message )]","title":"Parameters"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError-attributes","text":"","title":"Attributes"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.error_message","text":"Text associated with the thrown error. This is often the backtrace, but it can contain additional information as well.","title":"error_message"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.error_type","text":"The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py","title":"error_type"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.extras","text":"Additional information to bundle with the error.","title":"extras"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.Config","text":"Source code in qcelemental/models/common_models.py class Config ( ProtoModel . Config ): canonical_repr = True extra : str = \"allow\" def schema_extra ( schema , model ): schema [ \"$schema\" ] = qcschema_draft","title":"Config"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError-methods","text":"","title":"Methods"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.compare","text":"Compares the current object to the provided object recursively.","title":"compare()"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.compare--parameters","text":"other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive .","title":"Parameters"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.compare--returns","text":"bool True if the objects match. Source code in qcelemental/models/common_models.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : r \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs )","title":"Returns"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.dict","text":"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/common_models.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" )","title":"dict()"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.json","text":"Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/common_models.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs )","title":"json()"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.serialize","text":"Generates a serialized representation of the model","title":"serialize()"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.serialize--parameters","text":"encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None .","title":"Parameters"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.serialize--returns","text":"Union[bytes, str] The serialized model. Source code in qcelemental/models/common_models.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: r \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Returns"},{"location":"code_reference/FailedOperation/","text":"FailedOperation \ud83d\udd17 Record indicating that a given operation (program, procedure, etc.) has failed and containing the reason and input data which generated the failure. Parameters \ud83d\udd17 id : str, Optional A unique identifier which links this FailedOperation, often of the same Id of the operation should it have been successful. This will often be set programmatically by a database such as Fractal. input_data : Any, Optional The input data which was passed in that generated this failure. This should be the complete input which when attempted to be run, caused the operation to fail. success : bool, Default: False A boolean indicator that the operation failed consistent with the model of successful operations. Should always be False. Allows programmatic assessment of all operations regardless of if they failed or succeeded error : :class: ComputeError A container which has details of the error that failed this operation. See the :class: ComputeError for more details. extras : Dict[Any], Optional Additional information to bundle with the failed operation. Details which pertain specifically to a thrown error should be contained in the error field. See :class: ComputeError for details. Source code in qcelemental/models/common_models.py class FailedOperation ( ProtoModel ): \"\"\"Record indicating that a given operation (program, procedure, etc.) has failed and containing the reason and input data which generated the failure.\"\"\" id : str = Field ( # type: ignore None , description = \"A unique identifier which links this FailedOperation, often of the same Id of the operation \" \"should it have been successful. This will often be set programmatically by a database such as \" \"Fractal.\" , ) input_data : Any = Field ( # type: ignore None , description = \"The input data which was passed in that generated this failure. This should be the complete \" \"input which when attempted to be run, caused the operation to fail.\" , ) success : bool = Field ( # type: ignore False , description = \"A boolean indicator that the operation failed consistent with the model of successful operations. \" \"Should always be False. Allows programmatic assessment of all operations regardless of if they failed or \" \"succeeded\" , ) error : ComputeError = Field ( # type: ignore ... , description = \"A container which has details of the error that failed this operation. See the \" \":class:`ComputeError` for more details.\" , ) extras : Optional [ Dict [ str , Any ]] = Field ( # type: ignore None , description = \"Additional information to bundle with the failed operation. Details which pertain specifically \" \"to a thrown error should be contained in the `error` field. See :class:`ComputeError` for details.\" , ) def __repr_args__ ( self ) -> \"ReprArgs\" : return [( \"error\" , self . error )] Attributes \ud83d\udd17 error : ComputeError pydantic-field required \ud83d\udd17 A container which has details of the error that failed this operation. See the :class: ComputeError for more details. extras : Dict [ str , Any ] pydantic-field \ud83d\udd17 Additional information to bundle with the failed operation. Details which pertain specifically to a thrown error should be contained in the error field. See :class: ComputeError for details. id : str pydantic-field \ud83d\udd17 A unique identifier which links this FailedOperation, often of the same Id of the operation should it have been successful. This will often be set programmatically by a database such as Fractal. input_data : Any pydantic-field \ud83d\udd17 The input data which was passed in that generated this failure. This should be the complete input which when attempted to be run, caused the operation to fail. success : bool pydantic-field \ud83d\udd17 A boolean indicator that the operation failed consistent with the model of successful operations. Should always be False. Allows programmatic assessment of all operations regardless of if they failed or succeeded Config inherited \ud83d\udd17 Source code in qcelemental/models/common_models.py class Config : allow_mutation : bool = False extra : str = \"forbid\" json_encoders : Dict [ str , Any ] = { np . ndarray : lambda v : v . flatten () . tolist ()} serialize_default_excludes : Set = set () serialize_skip_defaults : bool = False force_skip_defaults : bool = False allow_mutation : bool \ud83d\udd17 extra : str \ud83d\udd17 force_skip_defaults : bool \ud83d\udd17 json_encoders : Dict [ str , Any ] \ud83d\udd17 serialize_default_excludes : Set \ud83d\udd17 serialize_skip_defaults : bool \ud83d\udd17 Methods \ud83d\udd17 compare ( self , other : Union [ ProtoModel , pydantic . main . BaseModel ], ** kwargs ) -> bool inherited \ud83d\udd17 Compares the current object to the provided object recursively. Parameters \ud83d\udd17 other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive . Returns \ud83d\udd17 bool True if the objects match. Source code in qcelemental/models/common_models.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : r \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs ) dict ( self , ** kwargs ) -> Dict [ str , Any ] inherited \ud83d\udd17 Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/common_models.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" ) json ( self , ** kwargs ) inherited \ud83d\udd17 Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/common_models.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs ) serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None ) -> Union [ bytes , str ] inherited \ud83d\udd17 Generates a serialized representation of the model Parameters \ud83d\udd17 encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None . Returns \ud83d\udd17 Union[bytes, str] The serialized model. Source code in qcelemental/models/common_models.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: r \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"FailedOperation"},{"location":"code_reference/FailedOperation/#failedoperation","text":"Record indicating that a given operation (program, procedure, etc.) has failed and containing the reason and input data which generated the failure.","title":"FailedOperation"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation--parameters","text":"id : str, Optional A unique identifier which links this FailedOperation, often of the same Id of the operation should it have been successful. This will often be set programmatically by a database such as Fractal. input_data : Any, Optional The input data which was passed in that generated this failure. This should be the complete input which when attempted to be run, caused the operation to fail. success : bool, Default: False A boolean indicator that the operation failed consistent with the model of successful operations. Should always be False. Allows programmatic assessment of all operations regardless of if they failed or succeeded error : :class: ComputeError A container which has details of the error that failed this operation. See the :class: ComputeError for more details. extras : Dict[Any], Optional Additional information to bundle with the failed operation. Details which pertain specifically to a thrown error should be contained in the error field. See :class: ComputeError for details. Source code in qcelemental/models/common_models.py class FailedOperation ( ProtoModel ): \"\"\"Record indicating that a given operation (program, procedure, etc.) has failed and containing the reason and input data which generated the failure.\"\"\" id : str = Field ( # type: ignore None , description = \"A unique identifier which links this FailedOperation, often of the same Id of the operation \" \"should it have been successful. This will often be set programmatically by a database such as \" \"Fractal.\" , ) input_data : Any = Field ( # type: ignore None , description = \"The input data which was passed in that generated this failure. This should be the complete \" \"input which when attempted to be run, caused the operation to fail.\" , ) success : bool = Field ( # type: ignore False , description = \"A boolean indicator that the operation failed consistent with the model of successful operations. \" \"Should always be False. Allows programmatic assessment of all operations regardless of if they failed or \" \"succeeded\" , ) error : ComputeError = Field ( # type: ignore ... , description = \"A container which has details of the error that failed this operation. See the \" \":class:`ComputeError` for more details.\" , ) extras : Optional [ Dict [ str , Any ]] = Field ( # type: ignore None , description = \"Additional information to bundle with the failed operation. Details which pertain specifically \" \"to a thrown error should be contained in the `error` field. See :class:`ComputeError` for details.\" , ) def __repr_args__ ( self ) -> \"ReprArgs\" : return [( \"error\" , self . error )]","title":"Parameters"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation-attributes","text":"","title":"Attributes"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.error","text":"A container which has details of the error that failed this operation. See the :class: ComputeError for more details.","title":"error"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.extras","text":"Additional information to bundle with the failed operation. Details which pertain specifically to a thrown error should be contained in the error field. See :class: ComputeError for details.","title":"extras"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.id","text":"A unique identifier which links this FailedOperation, often of the same Id of the operation should it have been successful. This will often be set programmatically by a database such as Fractal.","title":"id"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.input_data","text":"The input data which was passed in that generated this failure. This should be the complete input which when attempted to be run, caused the operation to fail.","title":"input_data"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.success","text":"A boolean indicator that the operation failed consistent with the model of successful operations. Should always be False. Allows programmatic assessment of all operations regardless of if they failed or succeeded","title":"success"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.Config","text":"Source code in qcelemental/models/common_models.py class Config : allow_mutation : bool = False extra : str = \"forbid\" json_encoders : Dict [ str , Any ] = { np . ndarray : lambda v : v . flatten () . tolist ()} serialize_default_excludes : Set = set () serialize_skip_defaults : bool = False force_skip_defaults : bool = False","title":"Config"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.Config.allow_mutation","text":"","title":"allow_mutation"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.Config.extra","text":"","title":"extra"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.Config.force_skip_defaults","text":"","title":"force_skip_defaults"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.Config.json_encoders","text":"","title":"json_encoders"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.Config.serialize_default_excludes","text":"","title":"serialize_default_excludes"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.Config.serialize_skip_defaults","text":"","title":"serialize_skip_defaults"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation-methods","text":"","title":"Methods"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.compare","text":"Compares the current object to the provided object recursively.","title":"compare()"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.compare--parameters","text":"other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive .","title":"Parameters"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.compare--returns","text":"bool True if the objects match. Source code in qcelemental/models/common_models.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : r \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs )","title":"Returns"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.dict","text":"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/common_models.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" )","title":"dict()"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.json","text":"Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/common_models.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs )","title":"json()"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.serialize","text":"Generates a serialized representation of the model","title":"serialize()"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.serialize--parameters","text":"encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None .","title":"Parameters"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.serialize--returns","text":"Union[bytes, str] The serialized model. Source code in qcelemental/models/common_models.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: r \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Returns"},{"location":"code_reference/FutureResult/","text":"FutureResult \ud83d\udd17 Single computation result Source code in tccloud/models.py class FutureResult ( FutureResultBase ): \"\"\"Single computation result\"\"\" result : Optional [ PossibleResults ] = None Attributes \ud83d\udd17 client : Any pydantic-field \ud83d\udd17 id : str pydantic-field required \ud83d\udd17 result : Union [ qcelemental . models . results . AtomicResult , qcelemental . models . procedures . OptimizationResult , qcelemental . models . common_models . FailedOperation ] pydantic-field \ud83d\udd17 status : str inherited property readonly \ud83d\udd17 Check status of compute task. Returns: Type Description str Status of computation. Note Sets self.result if task is complete. Config inherited \ud83d\udd17 Source code in tccloud/models.py class Config : underscore_attrs_are_private = True validate_assignment = True underscore_attrs_are_private \ud83d\udd17 validate_assignment \ud83d\udd17 Methods \ud83d\udd17 get ( self , timeout : Optional [ float ] = None , interval : float = 1.0 ) -> Union [ qcelemental . models . results . AtomicResult , qcelemental . models . procedures . OptimizationResult , qcelemental . models . common_models . FailedOperation , List [ Union [ qcelemental . models . results . AtomicResult , qcelemental . models . procedures . OptimizationResult , qcelemental . models . common_models . FailedOperation ]]] inherited \ud83d\udd17 Block and return result. Parameters: Name Type Description Default timeout Optional[float] The number of seconds to wait for a computation before raising a TimeOutError. None interval float The amount of time to wait between calls to TeraChem Cloud to check a computation's status. 1.0 Returns: Type Description Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation, List[Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation]]] Resultant values from a computation. Exceptions: Type Description TimeoutError Raised if timout interval exceeded. Source code in tccloud/models.py def get ( self , timeout : Optional [ float ] = None , # in seconds interval : float = 1.0 , ) -> PossibleResultsOrList : \"\"\"Block and return result. Parameters: timeout: The number of seconds to wait for a computation before raising a TimeOutError. interval: The amount of time to wait between calls to TeraChem Cloud to check a computation's status. Returns: Resultant values from a computation. Exceptions: TimeoutError: Raised if timout interval exceeded. \"\"\" if self . result : return self . result start_time = time () while not self . result : # Calling self.status returns status and sets self.result if task complete self . status if timeout : if ( time () - start_time ) > timeout : raise TimeoutError ( f \"Your timeout limit of { timeout } seconds was exceeded\" ) sleep ( interval ) return self . result","title":"FutureResult"},{"location":"code_reference/FutureResult/#futureresult","text":"Single computation result Source code in tccloud/models.py class FutureResult ( FutureResultBase ): \"\"\"Single computation result\"\"\" result : Optional [ PossibleResults ] = None","title":"FutureResult"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult-attributes","text":"","title":"Attributes"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.client","text":"","title":"client"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.id","text":"","title":"id"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.result","text":"","title":"result"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.status","text":"Check status of compute task. Returns: Type Description str Status of computation. Note Sets self.result if task is complete.","title":"status"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.Config","text":"Source code in tccloud/models.py class Config : underscore_attrs_are_private = True validate_assignment = True","title":"Config"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.Config.underscore_attrs_are_private","text":"","title":"underscore_attrs_are_private"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.Config.validate_assignment","text":"","title":"validate_assignment"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult-methods","text":"","title":"Methods"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.get","text":"Block and return result. Parameters: Name Type Description Default timeout Optional[float] The number of seconds to wait for a computation before raising a TimeOutError. None interval float The amount of time to wait between calls to TeraChem Cloud to check a computation's status. 1.0 Returns: Type Description Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation, List[Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation]]] Resultant values from a computation. Exceptions: Type Description TimeoutError Raised if timout interval exceeded. Source code in tccloud/models.py def get ( self , timeout : Optional [ float ] = None , # in seconds interval : float = 1.0 , ) -> PossibleResultsOrList : \"\"\"Block and return result. Parameters: timeout: The number of seconds to wait for a computation before raising a TimeOutError. interval: The amount of time to wait between calls to TeraChem Cloud to check a computation's status. Returns: Resultant values from a computation. Exceptions: TimeoutError: Raised if timout interval exceeded. \"\"\" if self . result : return self . result start_time = time () while not self . result : # Calling self.status returns status and sets self.result if task complete self . status if timeout : if ( time () - start_time ) > timeout : raise TimeoutError ( f \"Your timeout limit of { timeout } seconds was exceeded\" ) sleep ( interval ) return self . result","title":"get()"},{"location":"code_reference/Molecule/","text":"Molecule \ud83d\udd17 Overview \ud83d\udd17 The Molecule object is the core representation of a molecule used throughout tccloud . The molecule object is from the qcelemental.models module, but it is available in the tccloud.models module for your convenience. You can access the QCElemental documentation on the Molecule here . It is assumed that all geometries are in bohr . Import the Model object \ud83d\udd17 from tccloud.models import Molecule Create a Molecule \ud83d\udd17 Molecules can be created directly from data on pubchem , a python string, a psi4 file, an xyz file, an xyz+ file, or a json file. Pubchem: water = Molecule . from_data ( \"pubchem:water\" ) From Files: water = Molecule . from_file ( \"water.xyz\" ) water = Molecule . from_file ( \"water.psi4\" ) Save a Molecule to a file \ud83d\udd17 water = Molecule . from_data ( \"pubchem:water\" ) # JSON is the prefered format since it preserves the most information water . to_file ( \"water.json\" ) water . to_file ( \"water.xyz\" ) water . to_file ( \"water.psi4\" ) Oft-used Attributes \ud83d\udd17 water = Molecule . from_data ( \"pubchem:water\" ) water . symbols array ([ 'O' , 'H' , 'H' ], dtype = '<U1' ) water . symbols water . geometry array ([[ 0. , 0. , 0. ], [ 0.52421003 , 1.68733646 , 0.48074633 ], [ 1.14668581 , - 0.45032174 , - 1.35474466 ]]) # All Attributes attrs = [ attr for attr in dir ( water ) if not attr . startswith ( \"_\" )] print ( attrs ) Molecule Full Reference \ud83d\udd17 The physical Cartesian representation of the molecular system. A QCSchema representation of a Molecule. This model contains data for symbols, geometry, connectivity, charges, fragmentation, etc while also supporting a wide array of I/O and manipulation capabilities. Molecule objects geometry, masses, and charges are truncated to 8, 6, and 4 decimal places respectively to assist with duplicate detection. Notes \ud83d\udd17 All arrays are stored flat but must be reshapable into the dimensions in attribute shape , with abbreviations as follows: nat: number of atomic = calcinfo_natom nfr: number of fragments : irregular dimension not systematically reshapable Source code in qcelemental/models/molecule.py class Molecule ( ProtoModel ): r \"\"\" The physical Cartesian representation of the molecular system. A QCSchema representation of a Molecule. This model contains data for symbols, geometry, connectivity, charges, fragmentation, etc while also supporting a wide array of I/O and manipulation capabilities. Molecule objects geometry, masses, and charges are truncated to 8, 6, and 4 decimal places respectively to assist with duplicate detection. Notes ----- All arrays are stored flat but must be reshapable into the dimensions in attribute ``shape``, with abbreviations as follows: * nat: number of atomic = calcinfo_natom * nfr: number of fragments * <varies>: irregular dimension not systematically reshapable \"\"\" schema_name : constr ( strip_whitespace = True , regex = \"^(qcschema_molecule)$\" ) = Field ( # type: ignore qcschema_molecule_default , description = ( f \"The QCSchema specification to which this model conforms. Explicitly fixed as { qcschema_molecule_default } .\" ), ) schema_version : int = Field ( # type: ignore 2 , description = \"The version number of ``schema_name`` to which this model conforms.\" ) validated : bool = Field ( # type: ignore False , description = \"A boolean indicator (for speed purposes) that the input Molecule data has been previously checked \" \"for schema (data layout and type) and physics (e.g., non-overlapping atoms, feasible \" \"multiplicity) compliance. This should be False in most cases. A ``True`` setting \" \"should only ever be set by the constructor for this class itself or other trusted sources such as \" \"a Fractal Server or previously serialized Molecules.\" , ) # Required data symbols : Array [ str ] = Field ( # type: ignore ... , description = \"The ordered array of atomic elemental symbols in title case. This field's index \" \"sets atomic order for all other per-atom fields like ``real`` and the first dimension of \" \"``geometry``. Ghost/virtual atoms must have an entry here in ``symbols``; ghostedness is \" \"indicated through the ``real`` field.\" , shape = [ \"nat\" ], ) geometry : Array [ float ] = Field ( # type: ignore ... , description = \"The ordered array for Cartesian XYZ atomic coordinates [a0]. \" \"Atom ordering is fixed; that is, a consumer who shuffles atoms must not reattach the input \" \"(pre-shuffling) molecule schema instance to any output (post-shuffling) per-atom results \" \"(e.g., gradient). Index of the first dimension matches the 0-indexed indices of all other \" \"per-atom settings like ``symbols`` and ``real``.\" \" \\n \" \"Serialized storage is always flat, (3*nat,), but QCSchema implementations will want to reshape it. \" \"QCElemental can also accept array-likes which can be mapped to (nat,3) such as a 1-D list of length 3*nat, \" \"or the serialized version of the array in (3*nat,) shape; all forms will be reshaped to \" \"(nat,3) for this attribute.\" , shape = [ \"nat\" , 3 ], units = \"a0\" , ) # Molecule data name : Optional [ str ] = Field ( # type: ignore None , description = \"Common or human-readable name to assign to this molecule. This field can be arbitrary; see ``identifiers`` for well-defined labels.\" , ) identifiers : Optional [ Identifiers ] = Field ( # type: ignore None , description = \"An optional dictionary of additional identifiers by which this molecule can be referenced, \" \"such as INCHI, canonical SMILES, etc. See the :class:``Identifiers`` model for more details.\" , ) comment : Optional [ str ] = Field ( # type: ignore None , description = \"Additional comments for this molecule. Intended for pure human/user consumption and clarity.\" , ) molecular_charge : float = Field ( 0.0 , description = \"The net electrostatic charge of the molecule.\" ) # type: ignore molecular_multiplicity : int = Field ( 1 , description = \"The total multiplicity of the molecule.\" ) # type: ignore # Atom data masses_ : Optional [ Array [ float ]] = Field ( # type: ignore None , description = \"The ordered array of atomic masses. Index order \" \"matches the 0-indexed indices of all other per-atom fields like ``symbols`` and ``real``. If \" \"this is not provided, the mass of each atom is inferred from its most common isotope. If this \" \"is provided, it must be the same length as ``symbols`` but can accept ``None`` entries for \" \"standard masses to infer from the same index in the ``symbols`` field.\" , shape = [ \"nat\" ], units = \"u\" , ) real_ : Optional [ Array [ bool ]] = Field ( # type: ignore None , description = \"The ordered array indicating if each atom is real (``True``) or \" \"ghost/virtual (``False``). Index \" \"matches the 0-indexed indices of all other per-atom settings like ``symbols`` and the first \" \"dimension of ``geometry``. If this is not provided, all atoms are assumed to be real (``True``).\" \"If this is provided, the reality or ghostedness of every atom must be specified.\" , shape = [ \"nat\" ], ) atom_labels_ : Optional [ Array [ str ]] = Field ( # type: ignore None , description = \"Additional per-atom labels as an array of strings. Typical use is in \" \"model conversions, such as Elemental <-> Molpro and not typically something which should be user \" \"assigned. See the ``comments`` field for general human-consumable text to affix to the molecule.\" , shape = [ \"nat\" ], ) atomic_numbers_ : Optional [ Array [ np . int16 ]] = Field ( # type: ignore None , description = \"An optional ordered 1-D array-like object of atomic numbers of shape (nat,). Index \" \"matches the 0-indexed indices of all other per-atom settings like ``symbols`` and ``real``. \" \"Values are inferred from the ``symbols`` list if not explicitly set. \" \"Ghostedness should be indicated through ``real`` field, not zeros here.\" , shape = [ \"nat\" ], ) mass_numbers_ : Optional [ Array [ np . int16 ]] = Field ( # type: ignore None , description = \"An optional ordered 1-D array-like object of atomic *mass* numbers of shape (nat). Index \" \"matches the 0-indexed indices of all other per-atom settings like ``symbols`` and ``real``. \" \"Values are inferred from the most common isotopes of the ``symbols`` list if not explicitly set. \" \"If single isotope not (yet) known for an atom, -1 is placeholder.\" , shape = [ \"nat\" ], ) # Fragment and connection data connectivity_ : Optional [ List [ Tuple [ NonnegativeInt , NonnegativeInt , BondOrderFloat ]]] = Field ( # type: ignore None , description = \"A list of bonds within the molecule. Each entry is a tuple \" \"of ``(atom_index_A, atom_index_B, bond_order)`` where the ``atom_index`` \" \"matches the 0-indexed indices of all other per-atom settings like ``symbols`` and ``real``. \" \"Bonds may be freely reordered and inverted.\" , min_items = 1 , ) fragments_ : Optional [ List [ Array [ np . int32 ]]] = Field ( # type: ignore None , description = \"List of indices grouping atoms (0-indexed) into molecular fragments within the molecule. \" \"Each entry in the outer list is a new fragment; index matches the ordering in ``fragment_charges`` and \" \"``fragment_multiplicities``. Inner lists are 0-indexed atoms which compose the fragment; every atom must \" \"be in exactly one inner list. Noncontiguous fragments are allowed, though no QM program is known to support them. \" \"Fragment ordering is fixed; that is, a consumer who shuffles fragments must not reattach the input \" \"(pre-shuffling) molecule schema instance to any output (post-shuffling) per-fragment results (e.g., n-body energy arrays).\" , shape = [ \"nfr\" , \"<varies>\" ], ) fragment_charges_ : Optional [ List [ float ]] = Field ( # type: ignore None , description = \"The total charge of each fragment in the ``fragments`` list. The index of this \" \"list matches the 0-index indices of ``fragments`` list. Will be filled in based on a set of rules \" \"if not provided (and ``fragments`` are specified).\" , shape = [ \"nfr\" ], ) fragment_multiplicities_ : Optional [ List [ int ]] = Field ( # type: ignore None , description = \"The multiplicity of each fragment in the ``fragments`` list. The index of this \" \"list matches the 0-index indices of ``fragments`` list. Will be filled in based on a set of \" \"rules if not provided (and ``fragments`` are specified).\" , shape = [ \"nfr\" ], ) # Orientation fix_com : bool = Field ( # type: ignore False , description = \"Whether translation of geometry is allowed (fix F) or disallowed (fix T).\" \"When False, QCElemental will pre-process the Molecule object to translate the center of mass \" \"to (0,0,0) in Euclidean coordinate space, resulting in a different ``geometry`` than the \" \"one provided. 'Fix' is used in the sense of 'specify': that is, `fix_com=True` signals that \" \"the origin in `geometry` is a deliberate part of the Molecule spec, whereas `fix_com=False` \" \"(default) allows that the origin is happenstance and may be adjusted. \" \"guidance: A consumer who translates the geometry must not reattach the input (pre-translation) molecule schema instance to any output (post-translation) origin-sensitive results (e.g., an ordinary energy when EFP present).\" , ) fix_orientation : bool = Field ( # type: ignore False , description = \"Whether rotation of geometry is allowed (fix F) or disallowed (fix T). \" \"When False, QCElemental will pre-process the Molecule object to orient via the intertial tensor, \" \"resulting in a different ``geometry`` than the one provided. \" \"'Fix' is used in the sense of 'specify': that is, `fix_orientation=True` signals that \" \"the frame orientation in `geometry` is a deliberate part of the Molecule spec, whereas \" \"`fix_orientation=False` (default) allows that the frame is happenstance and may be adjusted. \" \"guidance: A consumer who rotates the geometry must not reattach the input (pre-rotation) molecule schema instance to any output (post-rotation) frame-sensitive results (e.g., molecular vibrations).\" , ) fix_symmetry : Optional [ str ] = Field ( # type: ignore None , description = \"Maximal point group symmetry which ``geometry`` should be treated. Lowercase.\" ) # Extra provenance : Provenance = Field ( default_factory = partial ( provenance_stamp , __name__ ), description = \"The provenance information about how this Molecule (and its attributes) were generated, \" \"provided, and manipulated.\" , ) id : Optional [ Any ] = Field ( # type: ignore None , description = \"A unique identifier for this Molecule object. This field exists primarily for Databases \" \"(e.g. Fractal's Server) to track and lookup this specific object and should virtually \" \"never need to be manually set.\" , ) extras : Dict [ str , Any ] = Field ( # type: ignore None , description = \"Additional information to bundle with the molecule. Use for schema development and scratch space.\" , ) class Config ( ProtoModel . Config ): serialize_skip_defaults = True repr_style = lambda self : [ ( \"name\" , self . name ), ( \"formula\" , self . get_molecular_formula ()), ( \"hash\" , self . get_hash ()[: 7 ]), ] fields = { \"masses_\" : \"masses\" , \"real_\" : \"real\" , \"atom_labels_\" : \"atom_labels\" , \"atomic_numbers_\" : \"atomic_numbers\" , \"mass_numbers_\" : \"mass_numbers\" , \"connectivity_\" : \"connectivity\" , \"fragments_\" : \"fragments\" , \"fragment_charges_\" : \"fragment_charges\" , \"fragment_multiplicities_\" : \"fragment_multiplicities\" , } def schema_extra ( schema , model ): # below addresses the draft-04 issue until https://github.com/samuelcolvin/pydantic/issues/1478 . schema [ \"$schema\" ] = qcschema_draft def __init__ ( self , orient : bool = False , validate : Optional [ bool ] = None , ** kwargs : Any ) -> None : r \"\"\"Initializes the molecule object from dictionary-like values. Parameters ---------- orient If True, orientates the Molecule to a common reference frame. validate If ``None`` validation is always applied unless the ``validated`` flag is set. Otherwise uses the boolean to decide to validate the Molecule or not. **kwargs The values of the Molecule object attributes. \"\"\" if validate is None : validate = not kwargs . get ( \"validated\" , False ) geometry_prep = kwargs . pop ( \"_geometry_prep\" , False ) geometry_noise = kwargs . pop ( \"geometry_noise\" , GEOMETRY_NOISE ) if validate : kwargs [ \"schema_name\" ] = kwargs . pop ( \"schema_name\" , \"qcschema_molecule\" ) kwargs [ \"schema_version\" ] = kwargs . pop ( \"schema_version\" , 2 ) # original_keys = set(kwargs.keys()) # revive when ready to revisit sparsity nonphysical = kwargs . pop ( \"nonphysical\" , False ) schema = to_schema ( from_schema ( kwargs , nonphysical = nonphysical ), dtype = kwargs [ \"schema_version\" ], copy = False , np_out = True ) schema = _filter_defaults ( schema ) kwargs [ \"validated\" ] = True kwargs = { ** kwargs , ** schema } # Allow any extra fields validate = True super () . __init__ ( ** kwargs ) # We are pulling out the values *explicitly* so that the pydantic skip_defaults works as expected # All attributes set below are equivalent to the default set. values = self . __dict__ if validate : values [ \"symbols\" ] = np . core . defchararray . title ( self . symbols ) # Title case for consistency if orient : values [ \"geometry\" ] = float_prep ( self . _orient_molecule_internal (), geometry_noise ) elif validate or geometry_prep : values [ \"geometry\" ] = float_prep ( values [ \"geometry\" ], geometry_noise ) @validator ( \"geometry\" ) def _must_be_3n ( cls , v , values , ** kwargs ): n = len ( values [ \"symbols\" ]) try : v = v . reshape ( n , 3 ) except ( ValueError , AttributeError ): raise ValueError ( \"Geometry must be castable to shape (N,3)!\" ) return v @validator ( \"masses_\" , \"real_\" ) def _must_be_n ( cls , v , values , ** kwargs ): n = len ( values [ \"symbols\" ]) if len ( v ) != n : raise ValueError ( \"Masses and Real must be same number of entries as Symbols\" ) return v @validator ( \"real_\" ) def _populate_real ( cls , v , values , ** kwargs ): # Can't use geometry here since its already been validated and not in values n = len ( values [ \"symbols\" ]) if len ( v ) == 0 : v = np . array ([ True for _ in range ( n )]) return v @validator ( \"fragment_charges_\" , \"fragment_multiplicities_\" ) def _must_be_n_frag ( cls , v , values , ** kwargs ): if \"fragments_\" in values and values [ \"fragments_\" ] is not None : n = len ( values [ \"fragments_\" ]) if len ( v ) != n : raise ValueError ( \"Fragment Charges and Fragment Multiplicities must be same number of entries as Fragments\" ) return v @property def hash_fields ( self ): return [ \"symbols\" , \"masses\" , \"molecular_charge\" , \"molecular_multiplicity\" , \"real\" , \"geometry\" , \"fragments\" , \"fragment_charges\" , \"fragment_multiplicities\" , \"connectivity\" , ] @property def masses ( self ) -> Array [ float ]: masses = self . __dict__ . get ( \"masses_\" ) if masses is None : masses = np . array ([ periodictable . to_mass ( x ) for x in self . symbols ]) return masses @property def real ( self ) -> Array [ bool ]: real = self . __dict__ . get ( \"real_\" ) if real is None : real = np . array ([ True for x in self . symbols ]) return real @property def atom_labels ( self ) -> Array [ str ]: atom_labels = self . __dict__ . get ( \"atom_labels_\" ) if atom_labels is None : atom_labels = np . array ([ \"\" for x in self . symbols ]) return atom_labels @property def atomic_numbers ( self ) -> Array [ np . int16 ]: atomic_numbers = self . __dict__ . get ( \"atomic_numbers_\" ) if atomic_numbers is None : atomic_numbers = np . array ([ periodictable . to_Z ( x ) for x in self . symbols ]) return atomic_numbers @property def mass_numbers ( self ) -> Array [ np . int16 ]: mass_numbers = self . __dict__ . get ( \"mass_numbers_\" ) if mass_numbers is None : mass_numbers = np . array ([ periodictable . to_A ( x ) for x in self . symbols ]) return mass_numbers @property def connectivity ( self ) -> List [ Tuple [ int , int , float ]]: connectivity = self . __dict__ . get ( \"connectivity_\" ) # default is None, not [] return connectivity @property def fragments ( self ) -> List [ Array [ np . int32 ]]: fragments = self . __dict__ . get ( \"fragments_\" ) if fragments is None : fragments = [ np . arange ( len ( self . symbols ), dtype = np . int32 )] return fragments @property def fragment_charges ( self ) -> List [ float ]: fragment_charges = self . __dict__ . get ( \"fragment_charges_\" ) if fragment_charges is None : fragment_charges = [ self . molecular_charge ] return fragment_charges @property def fragment_multiplicities ( self ) -> List [ int ]: fragment_multiplicities = self . __dict__ . get ( \"fragment_multiplicities_\" ) if fragment_multiplicities is None : fragment_multiplicities = [ self . molecular_multiplicity ] return fragment_multiplicities ### Non-Pydantic API functions def show ( self , ngl_kwargs : Optional [ Dict [ str , Any ]] = None ) -> \"nglview.NGLWidget\" : # type: ignore r \"\"\"Creates a 3D representation of a molecule that can be manipulated in Jupyter Notebooks and exported as images (`.png`). Parameters ---------- ngl_kwargs Addition nglview NGLWidget kwargs Returns ------- nglview.NGLWidget A nglview view of the molecule \"\"\" if not which_import ( \"nglview\" , return_bool = True ): raise ModuleNotFoundError ( f \"Python module nglwview not found. Solve by installing it: `conda install -c conda-forge nglview`\" ) # pragma: no cover import nglview as nv # type: ignore if ngl_kwargs is None : ngl_kwargs = {} structure = nv . TextStructure ( self . to_string ( \"nglview-sdf\" ), ext = \"sdf\" ) widget = nv . NGLWidget ( structure , ** ngl_kwargs ) return widget def measure ( self , measurements : Union [ List [ int ], List [ List [ int ]]], * , degrees : bool = True ) -> Union [ float , List [ float ]]: r \"\"\" Takes a measurement of the moleucle from the indicies provided. Parameters ---------- measurements Either a single list of indices or multiple. Return a distance, angle, or dihedral depending if 2, 3, or 4 indices is provided, respectively. Values are returned in Bohr (distance) or degree. degrees Returns degrees by default, radians otherwise. Returns ------- Union[float, List[float]] Either a value or list of the measured values. \"\"\" return measure_coordinates ( self . geometry , measurements , degrees = degrees ) def orient_molecule ( self ): r \"\"\" Centers the molecule and orients via inertia tensor before returning a new Molecule \"\"\" return Molecule ( orient = True , ** self . dict ()) def compare ( self , other ): warnings . warn ( \"Molecule.compare is deprecated and will be removed in v0.13.0. Use == instead.\" , DeprecationWarning ) return self == other def __eq__ ( self , other ): r \"\"\" Checks if two molecules are identical. This is a molecular identity defined by scientific terms, and not programing terms, so it's less rigorous than a programmatic equality or a memory equivalent `is`. \"\"\" if isinstance ( other , dict ): other = Molecule ( orient = False , ** other ) elif isinstance ( other , Molecule ): pass else : raise TypeError ( \"Comparison molecule not understood of type ' {} '.\" . format ( type ( other ))) return self . get_hash () == other . get_hash () def dict ( self , * args , ** kwargs ): kwargs [ \"by_alias\" ] = True kwargs [ \"exclude_unset\" ] = True return super () . dict ( * args , ** kwargs ) def pretty_print ( self ): r \"\"\"Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms. (method name in libmints is print_in_angstrom) \"\"\" text = \"\" text += \"\"\" Geometry (in {0:s} ), charge = {1:.1f} , multiplicity = {2:d} : \\n\\n \"\"\" . format ( \"Angstrom\" , self . molecular_charge , self . molecular_multiplicity ) text += \"\"\" Center X Y Z \\n \"\"\" text += \"\"\" ------------ ----------------- ----------------- ----------------- \\n \"\"\" for i in range ( len ( self . geometry )): text += \"\"\" {0:8s}{1:4s} \"\"\" . format ( self . symbols [ i ], \"\" if self . real [ i ] else \"(Gh)\" ) for j in range ( 3 ): text += \"\"\" {0:17.12f} \"\"\" . format ( self . geometry [ i ][ j ] * constants . conversion_factor ( \"bohr\" , \"angstroms\" ) ) text += \" \\n \" # text += \"\\n\" return text def get_fragment ( self , real : Union [ int , List ], ghost : Optional [ Union [ int , List ]] = None , orient : bool = False , group_fragments : bool = True , ) -> \"Molecule\" : r \"\"\"Get new Molecule with fragments preserved, dropped, or ghosted. Parameters ---------- real Fragment index or list of indices (0-indexed) to be real atoms in new Molecule. ghost Fragment index or list of indices (0-indexed) to be ghost atoms (basis fns only) in new Molecule. orient Whether or not to align (inertial frame) and phase geometry upon new Molecule instantiation (according to _orient_molecule_internal)? group_fragments Whether or not to group real fragments at the start of the atom list and ghost fragments toward the back. Previous to ``v0.5``, this was always effectively True. True is handy for finding duplicate (atom-order-independent) molecules by hash. False preserves fragment order (though collapsing gaps for absent fragments) like Psi4's ``extract_subsets``. False is handy for gradients where atom order of returned values matters. Returns ------- Molecule New qcelemental.models.Molecule with ``self``\\'s fragments present, ghosted, or absent. \"\"\" if isinstance ( real , int ): real = [ real ] if isinstance ( ghost , int ): ghost = [ ghost ] elif ghost is None : ghost = [] constructor_dict : Dict = {} ret_name = ( self . name if self . name is not None else \"\" ) + \" (\" + str ( real ) + \",\" + str ( ghost ) + \")\" constructor_dict [ \"name\" ] = ret_name # ret = Molecule(None, name=ret_name) if len ( set ( real ) & set ( ghost )): raise TypeError ( \"Molecule:get_fragment: real and ghost sets are overlapping! ( {0} , {1} ).\" . format ( str ( real ), str ( ghost )) ) geom_blocks = [] symbols = [] masses = [] real_atoms = [] fragments = [] fragment_charges = [] fragment_multiplicities = [] atom_size = 0 if group_fragments : # Loop through the real blocks frag_start = 0 for frag in real : frag_size = len ( self . fragments [ frag ]) geom_blocks . append ( self . geometry [ self . fragments [ frag ]]) for idx in self . fragments [ frag ]: symbols . append ( self . symbols [ idx ]) real_atoms . append ( True ) masses . append ( self . masses [ idx ]) fragments . append ( list ( range ( frag_start , frag_start + frag_size ))) frag_start += frag_size fragment_charges . append ( float ( self . fragment_charges [ frag ])) fragment_multiplicities . append ( self . fragment_multiplicities [ frag ]) # Set charge and multiplicity constructor_dict [ \"molecular_charge\" ] = sum ( fragment_charges ) constructor_dict [ \"molecular_multiplicity\" ] = sum ( x - 1 for x in fragment_multiplicities ) + 1 # Loop through the ghost blocks for frag in ghost : frag_size = len ( self . fragments [ frag ]) geom_blocks . append ( self . geometry [ self . fragments [ frag ]]) for idx in self . fragments [ frag ]: symbols . append ( self . symbols [ idx ]) real_atoms . append ( False ) masses . append ( self . masses [ idx ]) fragments . append ( list ( range ( frag_start , frag_start + frag_size ))) frag_start += frag_size fragment_charges . append ( 0 ) fragment_multiplicities . append ( 1 ) else : # List[Array[np.int32]] at2fr : List [ Union [ int , None ]] = [ None ] * len ( self . symbols ) for ifr , fr in enumerate ( self . fragments ): for iat in fr : at2fr [ iat ] = ifr at2at : List [ Union [ int , None ]] = [ None ] * len ( self . symbols ) for iat in range ( len ( self . symbols )): ifr = at2fr [ iat ] if ifr in real or ifr in ghost : geom_blocks . append ( self . geometry [ iat ]) symbols . append ( self . symbols [ iat ]) real_atoms . append ( ifr in real ) masses . append ( self . masses [ iat ]) at2at [ iat ] = atom_size atom_size += 1 else : at2at [ iat ] = None for ifr , fr in enumerate ( self . fragments ): if ifr in real or ifr in ghost : fragments . append ([ at2at [ iat ] for iat in fr ]) if ifr in real : fragment_charges . append ( self . fragment_charges [ ifr ]) fragment_multiplicities . append ( self . fragment_multiplicities [ ifr ]) elif ifr in ghost : fragment_charges . append ( 0 ) fragment_multiplicities . append ( 1 ) assert None not in fragments constructor_dict [ \"fragments\" ] = fragments constructor_dict [ \"fragment_charges\" ] = fragment_charges constructor_dict [ \"fragment_multiplicities\" ] = fragment_multiplicities constructor_dict [ \"symbols\" ] = symbols constructor_dict [ \"geometry\" ] = np . vstack ( geom_blocks ) constructor_dict [ \"real\" ] = real_atoms constructor_dict [ \"masses\" ] = masses return Molecule ( orient = orient , ** constructor_dict ) def to_string ( # type: ignore self , dtype : str , units : str = None , * , atom_format : str = None , ghost_format : str = None , width : int = 17 , prec : int = 12 , return_data : bool = False , ): r \"\"\"Returns a string that can be used by a variety of programs. Unclear if this will be removed or renamed to \"to_psi4_string\" in the future Suggest psi4 --> psi4frag and psi4 route to to_string \"\"\" molrec = from_schema ( self . dict (), nonphysical = True ) return to_string ( molrec , dtype = dtype , units = units , atom_format = atom_format , ghost_format = ghost_format , width = width , prec = prec , return_data = return_data , ) def get_hash ( self ): r \"\"\" Returns the hash of the molecule. \"\"\" m = hashlib . sha1 () concat = \"\" np . set_printoptions ( precision = 16 ) for field in self . hash_fields : data = getattr ( self , field ) if field == \"geometry\" : data = float_prep ( data , GEOMETRY_NOISE ) elif field == \"fragment_charges\" : data = float_prep ( data , CHARGE_NOISE ) elif field == \"molecular_charge\" : data = float_prep ( data , CHARGE_NOISE ) elif field == \"masses\" : data = float_prep ( data , MASS_NOISE ) concat += json . dumps ( data , default = lambda x : x . ravel () . tolist ()) m . update ( concat . encode ( \"utf-8\" )) return m . hexdigest () def get_molecular_formula ( self , order : str = \"alphabetical\" ) -> str : r \"\"\" Returns the molecular formula for a molecule. Parameters ---------- order: str, optional Sorting order of the formula. Valid choices are \"alphabetical\" and \"hill\". Returns ------- str The molecular formula. Examples -------- >>> methane = qcelemental.models.Molecule(''' ... H 0.5288 0.1610 0.9359 ... C 0.0000 0.0000 0.0000 ... H 0.2051 0.8240 -0.6786 ... H 0.3345 -0.9314 -0.4496 ... H -1.0685 -0.0537 0.1921 ... ''') >>> methane.get_molecular_formula() CH4 >>> hcl = qcelemental.models.Molecule(''' ... H 0.0000 0.0000 0.0000 ... Cl 0.0000 0.0000 1.2000 ... ''') >>> hcl.get_molecular_formula() ClH \"\"\" from ..molutil import molecular_formula_from_symbols return molecular_formula_from_symbols ( symbols = self . symbols , order = order ) ### Constructors @classmethod def from_data ( cls , data : Union [ str , Dict [ str , Any ], np . ndarray , bytes ], dtype : Optional [ str ] = None , * , orient : bool = False , validate : bool = None , ** kwargs : Dict [ str , Any ], ) -> \"Molecule\" : r \"\"\" Constructs a molecule object from a data structure. Parameters ---------- data Data to construct Molecule from dtype How to interpret the data, if not passed attempts to discover this based on input type. orient Orientates the molecule to a standard frame or not. validate Validates the molecule or not. **kwargs Additional kwargs to pass to the constructors. kwargs take precedence over data. Returns ------- Molecule A constructed molecule class. \"\"\" if dtype is None : if isinstance ( data , str ): dtype = \"string\" elif isinstance ( data , np . ndarray ): dtype = \"numpy\" elif isinstance ( data , dict ): dtype = \"dict\" elif isinstance ( dtype , bytes ): dtype = \"msgpack\" else : raise TypeError ( \"Input type not understood, please supply the 'dtype' kwarg.\" ) if dtype in [ \"string\" , \"psi4\" , \"xyz\" , \"xyz+\" ]: mol_dict = from_string ( data , dtype if dtype != \"string\" else None ) assert isinstance ( mol_dict , dict ) input_dict = to_schema ( mol_dict [ \"qm\" ], dtype = 2 , np_out = True ) input_dict = _filter_defaults ( input_dict ) input_dict [ \"validated\" ] = True input_dict [ \"_geometry_prep\" ] = True elif dtype == \"numpy\" : data = np . asarray ( data ) data = { \"geom\" : data [:, 1 :], \"elez\" : data [:, 0 ], \"units\" : kwargs . pop ( \"units\" , \"Angstrom\" ), \"fragment_separators\" : kwargs . pop ( \"frags\" , []), } input_dict = to_schema ( from_arrays ( ** data ), dtype = 2 , np_out = True ) input_dict = _filter_defaults ( input_dict ) input_dict [ \"validated\" ] = True input_dict [ \"_geometry_prep\" ] = True elif dtype == \"msgpack\" : assert isinstance ( data , bytes ) input_dict = msgpackext_loads ( data ) elif dtype == \"json\" : assert isinstance ( data , str ) input_dict = json . loads ( data ) elif dtype == \"dict\" : assert isinstance ( data , dict ) input_dict = data else : raise KeyError ( \"Dtype not understood ' {} '.\" . format ( dtype )) input_dict . update ( kwargs ) # if charge/spin options are given, invalidate charge and spin options that are missing charge_spin_opts = { \"molecular_charge\" , \"fragment_charges\" , \"molecular_multiplicity\" , \"fragment_multiplicities\" } kwarg_keys = set ( kwargs . keys ()) if len ( charge_spin_opts & kwarg_keys ) > 0 : for key in charge_spin_opts - kwarg_keys : input_dict . pop ( key , None ) input_dict . pop ( \"validated\" , None ) return cls ( orient = orient , validate = validate , ** input_dict ) @classmethod def from_file ( cls , filename : str , dtype : Optional [ str ] = None , * , orient : bool = False , ** kwargs ): r \"\"\" Constructs a molecule object from a file. Parameters ---------- filename The filename to build dtype The type of file to interpret. orient Orientates the molecule to a standard frame or not. **kwargs Any additional keywords to pass to the constructor Returns ------- Molecule A constructed molecule class. \"\"\" ext = Path ( filename ) . suffix if dtype is None : if ext in _extension_map : dtype = _extension_map [ ext ] else : # Let `from_string` try to sort it dtype = \"string\" # Raw string type, read and pass through if dtype in [ \"string\" , \"xyz\" , \"xyz+\" , \"psi4\" ]: with open ( filename , \"r\" ) as infile : data = infile . read () elif dtype == \"numpy\" : data = np . load ( filename ) elif dtype in [ \"json\" , \"json-ext\" ]: with open ( filename , \"r\" ) as infile : data = deserialize ( infile . read (), encoding = \"json-ext\" ) dtype = \"dict\" elif dtype in [ \"msgpack\" , \"msgpack-ext\" ]: with open ( filename , \"rb\" ) as infile_bytes : data = deserialize ( infile_bytes . read (), encoding = \"msgpack-ext\" ) dtype = \"dict\" else : raise KeyError ( \"Dtype not understood ' {} '.\" . format ( dtype )) return cls . from_data ( data , dtype , orient = orient , ** kwargs ) def to_file ( self , filename : str , dtype : Optional [ str ] = None ) -> None : r \"\"\"Writes the Molecule to a file. Parameters ---------- filename The filename to write to dtype The type of file to write, attempts to infer dtype from the filename if not provided. \"\"\" ext = Path ( filename ) . suffix if dtype is None : if ext in _extension_map : dtype = _extension_map [ ext ] else : raise KeyError ( f \"Could not infer dtype from filename: ` { filename } `\" ) if dtype in [ \"xyz\" , \"xyz+\" , \"psi4\" ]: stringified = self . to_string ( dtype ) elif dtype in [ \"json\" , \"json-ext\" , \"msgpack\" , \"msgpack-ext\" ]: stringified = self . serialize ( dtype ) elif dtype in [ \"numpy\" ]: elements = np . array ( self . atomic_numbers ) . reshape ( - 1 , 1 ) npmol = np . hstack (( elements , self . geometry * constants . conversion_factor ( \"bohr\" , \"angstroms\" ))) np . save ( filename , npmol ) return else : raise KeyError ( f \"Dtype ` { dtype } ` is not valid\" ) flags = \"wb\" if dtype . startswith ( \"msgpack\" ) else \"w\" with open ( filename , flags ) as handle : handle . write ( stringified ) ### Non-Pydantic internal functions def _orient_molecule_internal ( self ): r \"\"\" Centers the molecule and orients via inertia tensor before returning a new set of the molecule geometry \"\"\" new_geometry = self . geometry . copy () # Ensure we get a copy # Get the mass as an array # Masses are needed for orientation np_mass = np . array ( self . masses ) # Center on Mass new_geometry -= np . average ( new_geometry , axis = 0 , weights = np_mass ) # Rotate into inertial frame tensor = self . _inertial_tensor ( new_geometry , weight = np_mass ) _ , evecs = np . linalg . eigh ( tensor ) new_geometry = np . dot ( new_geometry , evecs ) # Phases? Lets do the simplest thing and ensure the first atom in each column # that is not on a plane is positve phase_check = [ False , False , False ] geom_noise = 10 ** ( - GEOMETRY_NOISE ) for num in range ( new_geometry . shape [ 0 ]): for x in range ( 3 ): if phase_check [ x ]: continue val = new_geometry [ num , x ] if abs ( val ) < geom_noise : continue phase_check [ x ] = True if val < 0 : new_geometry [:, x ] *= - 1 if sum ( phase_check ) == 3 : break return new_geometry def __repr_args__ ( self ) -> \"ReprArgs\" : return [( \"name\" , self . name ), ( \"formula\" , self . get_molecular_formula ()), ( \"hash\" , self . get_hash ()[: 7 ])] def _ipython_display_ ( self , ** kwargs ) -> None : try : self . show () . _ipython_display_ ( ** kwargs ) except ModuleNotFoundError : from IPython.display import display display ( f \"Install nglview for interactive visualization.\" , f \" { repr ( self ) } \" ) @staticmethod def _inertial_tensor ( geom , * , weight ): r \"\"\" Compute the moment inertia tensor for a given geometry. \"\"\" # Build inertia tensor tensor = np . zeros (( 3 , 3 )) # Diagonal tensor [ 0 ][ 0 ] = np . sum ( weight * ( geom [:, 1 ] ** 2.0 + geom [:, 2 ] ** 2.0 )) tensor [ 1 ][ 1 ] = np . sum ( weight * ( geom [:, 0 ] ** 2.0 + geom [:, 2 ] ** 2.0 )) tensor [ 2 ][ 2 ] = np . sum ( weight * ( geom [:, 0 ] ** 2.0 + geom [:, 1 ] ** 2.0 )) # I(alpha, beta) # Off diagonal tensor [ 1 ][ 0 ] = tensor [ 0 ][ 1 ] = - 1.0 * np . sum ( weight * geom [:, 0 ] * geom [:, 1 ]) tensor [ 2 ][ 0 ] = tensor [ 0 ][ 2 ] = - 1.0 * np . sum ( weight * geom [:, 0 ] * geom [:, 2 ]) tensor [ 2 ][ 1 ] = tensor [ 1 ][ 2 ] = - 1.0 * np . sum ( weight * geom [:, 1 ] * geom [:, 2 ]) return tensor def nuclear_repulsion_energy ( self , ifr : int = None ) -> float : r \"\"\"Nuclear repulsion energy. Parameters ---------- ifr If not `None`, only compute for the `ifr`-th (0-indexed) fragment. Returns ------- nre : float Nuclear repulsion energy in entire molecule or in fragment. \"\"\" Zeff = [ z * int ( real ) for z , real in zip ( cast ( Iterable [ int ], self . atomic_numbers ), self . real )] atoms = list ( range ( self . geometry . shape [ 0 ])) if ifr is not None : atoms = self . fragments [ ifr ] nre = 0.0 for iat1 , at1 in enumerate ( atoms ): for at2 in atoms [: iat1 ]: dist = np . linalg . norm ( self . geometry [ at1 ] - self . geometry [ at2 ]) nre += Zeff [ at1 ] * Zeff [ at2 ] / dist return nre def nelectrons ( self , ifr : int = None ) -> int : r \"\"\"Number of electrons. Parameters ---------- ifr If not `None`, only compute for the `ifr`-th (0-indexed) fragment. Returns ------- nelec : int Number of electrons in entire molecule or in fragment. \"\"\" Zeff = [ z * int ( real ) for z , real in zip ( cast ( Iterable [ int ], self . atomic_numbers ), self . real )] if ifr is None : nel = sum ( Zeff ) - self . molecular_charge else : nel = sum ([ zf for iat , zf in enumerate ( Zeff ) if iat in self . fragments [ ifr ]]) - self . fragment_charges [ ifr ] return int ( nel ) def align ( self , ref_mol : \"Molecule\" , * , do_plot : bool = False , verbose : int = 0 , atoms_map : bool = False , run_resorting : bool = False , mols_align : Union [ bool , float ] = False , run_to_completion : bool = False , uno_cutoff : float = 1.0e-3 , run_mirror : bool = False , generic_ghosts : bool = False , ) -> Tuple [ \"Molecule\" , Dict [ str , Any ]]: r \"\"\"Finds shift, rotation, and atom reordering of `concern_mol` (self) that best aligns with `ref_mol`. Wraps :py:func:`qcelemental.molutil.B787` for :py:class:`qcelemental.models.Molecule`. Employs the Kabsch, Hungarian, and Uno algorithms to exhaustively locate the best alignment for non-oriented, non-ordered structures. Parameters ---------- ref_mol : qcelemental.models.Molecule Molecule to match. atoms_map Whether atom1 of `ref_mol` corresponds to atom1 of `concern_mol`, etc. If true, specifying `True` can save much time. mols_align Whether ref_mol and concern_mol have identical geometries (barring orientation or atom mapping) and expected final RMSD = 0. If `True`, procedure is truncated when RMSD condition met, saving time. If float, RMSD tolerance at which search for alignment stops. If provided, the alignment routine will throw an error if it fails to align the molecule within the specified RMSD tolerance. do_plot Pops up a mpl plot showing before, after, and ref geometries. run_to_completion Run reorderings to completion (past RMSD = 0) even if unnecessary because `mols_align=True`. Used to test worst-case timings. run_resorting Run the resorting machinery even if unnecessary because `atoms_map=True`. uno_cutoff TODO run_mirror Run alternate geometries potentially allowing best match to `ref_mol` from mirror image of `concern_mol`. Only run if system confirmed to be nonsuperimposable upon mirror reflection. generic_ghosts When one or both molecules doesn't have meaningful element info for ghosts (can happen when harvesting from a printout with a generic ghost symbol), set this to True to place all real=False atoms into the same space for alignment. Only allowed when ``atoms_map=True``. verbose Print level. Returns ------- mol : Molecule data : Dict[key, Any] Molecule is internal geometry of `self` optimally aligned and atom-ordered to `ref_mol`. Presently all fragment information is discarded. `data['rmsd']` is RMSD [A] between `ref_mol` and the optimally aligned geometry computed. `data['mill']` is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from `concern_mol` and the optimally aligned geometry. \"\"\" from ..molutil.align import B787 rgeom = np . array ( ref_mol . geometry ) runiq = np . asarray ( [ hashlib . sha1 (( sym + str ( mas )) . encode ( \"utf-8\" )) . hexdigest () for sym , mas in zip ( cast ( Iterable [ str ], ref_mol . symbols ), ref_mol . masses ) ] ) concern_mol = self cgeom = np . array ( concern_mol . geometry ) cuniq = np . asarray ( [ hashlib . sha1 (( sym + str ( mas )) . encode ( \"utf-8\" )) . hexdigest () for sym , mas in zip ( cast ( Iterable [ str ], concern_mol . symbols ), concern_mol . masses ) ] ) if generic_ghosts : if not mols_align : raise ValueError ( \"Too risky to lump ghosts together when mols not superimposable.\" ) bq_hash = hashlib . sha1 (( \"bq\" ) . encode ( \"utf-8\" )) . hexdigest () runiq = np . asarray ([( rl_hash if rl else bq_hash ) for rl , rl_hash in zip ( ref_mol . real , runiq )]) cuniq = np . asarray ([( rl_hash if rl else bq_hash ) for rl , rl_hash in zip ( concern_mol . real , cuniq )]) rmsd , solution = B787 ( cgeom = cgeom , rgeom = rgeom , cuniq = cuniq , runiq = runiq , do_plot = do_plot , verbose = verbose , atoms_map = atoms_map , run_resorting = run_resorting , mols_align = mols_align , run_to_completion = run_to_completion , run_mirror = run_mirror , uno_cutoff = uno_cutoff , ) aupdate = { \"symbols\" : solution . align_atoms ( concern_mol . symbols ), \"geometry\" : solution . align_coordinates ( concern_mol . geometry , reverse = False ), \"masses\" : solution . align_atoms ( concern_mol . masses ), \"real\" : solution . align_atoms ( concern_mol . real ), \"atom_labels\" : solution . align_atoms ( concern_mol . atom_labels ), \"atomic_numbers\" : solution . align_atoms ( concern_mol . atomic_numbers ), \"mass_numbers\" : solution . align_atoms ( concern_mol . mass_numbers ), } adict = { ** concern_mol . dict (), ** aupdate } # preserve intrinsic symmetry with lighter truncation amol = Molecule ( validate = True , ** adict , geometry_noise = 13 ) # TODO -- can probably do more with fragments in amol now that # Mol is something with non-contig frags. frags now discarded. assert compare_values ( concern_mol . nuclear_repulsion_energy (), amol . nuclear_repulsion_energy (), \"Q: concern_mol-->returned_mol NRE uncorrupted\" , atol = 1.0e-4 , quiet = ( verbose > 1 ), ) if mols_align : assert compare_values ( ref_mol . nuclear_repulsion_energy (), amol . nuclear_repulsion_energy (), \"Q: concern_mol-->returned_mol NRE matches ref_mol\" , atol = 1.0e-4 , quiet = ( verbose > 1 ), ) assert compare ( True , np . allclose ( ref_mol . geometry , amol . geometry , atol = 4 ), \"Q: concern_mol-->returned_mol geometry matches ref_mol\" , quiet = ( verbose > 1 ), ) return amol , { \"rmsd\" : rmsd , \"mill\" : solution } def scramble ( self , * , do_shift : Union [ bool , Array [ float ], List ] = True , do_rotate : Union [ bool , Array [ float ], List [ List ]] = True , do_resort : Union [ bool , List ] = True , deflection : float = 1.0 , do_mirror : bool = False , do_plot : bool = False , do_test : bool = False , run_to_completion : bool = False , run_resorting : bool = False , verbose : int = 0 , ) -> Tuple [ \"Molecule\" , Dict [ str , Any ]]: r \"\"\"Generate a Molecule with random or directed translation, rotation, and atom shuffling. Optionally, check that the aligner returns the opposite transformation. Parameters ---------- ref_mol : qcelemental.models.Molecule Molecule to perturb. do_shift Whether to generate a random atom shift on interval [-3, 3) in each dimension (`True`) or leave at current origin. To shift by a specified vector, supply a 3-element list. do_rotate Whether to generate a random 3D rotation according to algorithm of Arvo. To rotate by a specified matrix, supply a 9-element list of lists. do_resort Whether to shuffle atoms (`True`) or leave 1st atom 1st, etc. (`False`). To specify shuffle, supply a nat-element list of indices. deflection If `do_rotate`, how random a rotation: 0.0 is no change, 0.1 is small perturbation, 1.0 is completely random. do_mirror Whether to construct the mirror image structure by inverting y-axis. do_plot Pops up a mpl plot showing before, after, and ref geometries. do_test Additionally, run the aligner on the returned Molecule and check that opposite transformations obtained. run_to_completion By construction, scrambled systems are fully alignable (final RMSD=0). Even so, `True` turns off the mechanism to stop when RMSD reaches zero and instead proceed to worst possible time. run_resorting Even if atoms not shuffled, test the resorting machinery. verbose Print level. Returns ------- mol : Molecule data : Dict[key, Any] Molecule is scrambled copy of `ref_mol` (self). `data['rmsd']` is RMSD [A] between `ref_mol` and the scrambled geometry. `data['mill']` is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from `ref_mol` to the returned geometry. Raises ------ AssertionError If `do_test=True` and aligner sanity check fails for any of the reverse transformations. \"\"\" from ..molutil.align import compute_scramble ref_mol = self rgeom = ref_mol . geometry nat = rgeom . shape [ 0 ] perturbation = compute_scramble ( nat , do_shift = do_shift , do_rotate = do_rotate , deflection = deflection , do_resort = do_resort , do_mirror = do_mirror , ) cgeom = perturbation . align_coordinates ( rgeom , reverse = True ) cupdate = { \"symbols\" : perturbation . align_atoms ( ref_mol . symbols ), \"geometry\" : cgeom , \"masses\" : perturbation . align_atoms ( ref_mol . masses ), \"real\" : perturbation . align_atoms ( ref_mol . real ), \"atom_labels\" : perturbation . align_atoms ( ref_mol . atom_labels ), \"atomic_numbers\" : perturbation . align_atoms ( ref_mol . atomic_numbers ), \"mass_numbers\" : perturbation . align_atoms ( ref_mol . mass_numbers ), } cdict = { ** ref_mol . dict (), ** cupdate } # preserve intrinsic symmetry with lighter truncation cmol = Molecule ( validate = True , ** cdict , geometry_noise = 13 ) rmsd = np . linalg . norm ( cgeom - rgeom ) * constants . bohr2angstroms / np . sqrt ( nat ) if verbose >= 1 : print ( \"Start RMSD = {:8.4f} [A]\" . format ( rmsd )) if do_test : _ , data = cmol . align ( ref_mol , do_plot = do_plot , atoms_map = ( not do_resort ), run_resorting = run_resorting , mols_align = True , run_to_completion = run_to_completion , run_mirror = do_mirror , verbose = verbose , ) solution = data [ \"mill\" ] assert compare ( True , np . allclose ( solution . shift , perturbation . shift , atol = 1.0e-6 ), \"shifts equiv\" , quiet = ( verbose > 1 ) ) if not do_resort : assert compare ( True , np . allclose ( solution . rotation . T , perturbation . rotation ), \"rotations transpose\" , quiet = ( verbose > 1 ), ) if solution . mirror : assert compare ( True , do_mirror , \"mirror allowed\" , quiet = ( verbose > 1 )) return cmol , { \"rmsd\" : rmsd , \"mill\" : perturbation } Attributes \ud83d\udd17 atom_labels : Array property readonly \ud83d\udd17 atom_labels_ : Array pydantic-field \ud83d\udd17 Additional per-atom labels as an array of strings. Typical use is in model conversions, such as Elemental <-> Molpro and not typically something which should be user assigned. See the comments field for general human-consumable text to affix to the molecule. atomic_numbers : Array property readonly \ud83d\udd17 atomic_numbers_ : Array pydantic-field \ud83d\udd17 An optional ordered 1-D array-like object of atomic numbers of shape (nat,). Index matches the 0-indexed indices of all other per-atom settings like symbols and real . Values are inferred from the symbols list if not explicitly set. Ghostedness should be indicated through real field, not zeros here. comment : str pydantic-field \ud83d\udd17 Additional comments for this molecule. Intended for pure human/user consumption and clarity. connectivity : List [ Tuple [ int , int , float ]] property readonly \ud83d\udd17 connectivity_ : ConstrainedListValue pydantic-field \ud83d\udd17 A list of bonds within the molecule. Each entry is a tuple of (atom_index_A, atom_index_B, bond_order) where the atom_index matches the 0-indexed indices of all other per-atom settings like symbols and real . Bonds may be freely reordered and inverted. extras : Dict [ str , Any ] pydantic-field \ud83d\udd17 Additional information to bundle with the molecule. Use for schema development and scratch space. fix_com : bool pydantic-field \ud83d\udd17 Whether translation of geometry is allowed (fix F) or disallowed (fix T).When False, QCElemental will pre-process the Molecule object to translate the center of mass to (0,0,0) in Euclidean coordinate space, resulting in a different geometry than the one provided. 'Fix' is used in the sense of 'specify': that is, fix_com=True signals that the origin in geometry is a deliberate part of the Molecule spec, whereas fix_com=False (default) allows that the origin is happenstance and may be adjusted. guidance: A consumer who translates the geometry must not reattach the input (pre-translation) molecule schema instance to any output (post-translation) origin-sensitive results (e.g., an ordinary energy when EFP present). fix_orientation : bool pydantic-field \ud83d\udd17 Whether rotation of geometry is allowed (fix F) or disallowed (fix T). When False, QCElemental will pre-process the Molecule object to orient via the intertial tensor, resulting in a different geometry than the one provided. 'Fix' is used in the sense of 'specify': that is, fix_orientation=True signals that the frame orientation in geometry is a deliberate part of the Molecule spec, whereas fix_orientation=False (default) allows that the frame is happenstance and may be adjusted. guidance: A consumer who rotates the geometry must not reattach the input (pre-rotation) molecule schema instance to any output (post-rotation) frame-sensitive results (e.g., molecular vibrations). fix_symmetry : str pydantic-field \ud83d\udd17 Maximal point group symmetry which geometry should be treated. Lowercase. fragment_charges : List [ float ] property readonly \ud83d\udd17 fragment_charges_ : List [ float ] pydantic-field \ud83d\udd17 The total charge of each fragment in the fragments list. The index of this list matches the 0-index indices of fragments list. Will be filled in based on a set of rules if not provided (and fragments are specified). fragment_multiplicities : List [ int ] property readonly \ud83d\udd17 fragment_multiplicities_ : List [ int ] pydantic-field \ud83d\udd17 The multiplicity of each fragment in the fragments list. The index of this list matches the 0-index indices of fragments list. Will be filled in based on a set of rules if not provided (and fragments are specified). fragments : List [ qcelemental . models . types . Array ] property readonly \ud83d\udd17 fragments_ : List [ qcelemental . models . types . Array ] pydantic-field \ud83d\udd17 List of indices grouping atoms (0-indexed) into molecular fragments within the molecule. Each entry in the outer list is a new fragment; index matches the ordering in fragment_charges and fragment_multiplicities . Inner lists are 0-indexed atoms which compose the fragment; every atom must be in exactly one inner list. Noncontiguous fragments are allowed, though no QM program is known to support them. Fragment ordering is fixed; that is, a consumer who shuffles fragments must not reattach the input (pre-shuffling) molecule schema instance to any output (post-shuffling) per-fragment results (e.g., n-body energy arrays). geometry : Array pydantic-field required \ud83d\udd17 The ordered array for Cartesian XYZ atomic coordinates [a0]. Atom ordering is fixed; that is, a consumer who shuffles atoms must not reattach the input (pre-shuffling) molecule schema instance to any output (post-shuffling) per-atom results (e.g., gradient). Index of the first dimension matches the 0-indexed indices of all other per-atom settings like symbols and real . Serialized storage is always flat, (3 nat,), but QCSchema implementations will want to reshape it. QCElemental can also accept array-likes which can be mapped to (nat,3) such as a 1-D list of length 3 nat, or the serialized version of the array in (3*nat,) shape; all forms will be reshaped to (nat,3) for this attribute. hash_fields property readonly \ud83d\udd17 id : Any pydantic-field \ud83d\udd17 A unique identifier for this Molecule object. This field exists primarily for Databases (e.g. Fractal's Server) to track and lookup this specific object and should virtually never need to be manually set. identifiers : Identifiers pydantic-field \ud83d\udd17 An optional dictionary of additional identifiers by which this molecule can be referenced, such as INCHI, canonical SMILES, etc. See the :class: Identifiers model for more details. mass_numbers : Array property readonly \ud83d\udd17 mass_numbers_ : Array pydantic-field \ud83d\udd17 An optional ordered 1-D array-like object of atomic mass numbers of shape (nat). Index matches the 0-indexed indices of all other per-atom settings like symbols and real . Values are inferred from the most common isotopes of the symbols list if not explicitly set. If single isotope not (yet) known for an atom, -1 is placeholder. masses : Array property readonly \ud83d\udd17 masses_ : Array pydantic-field \ud83d\udd17 The ordered array of atomic masses. Index order matches the 0-indexed indices of all other per-atom fields like symbols and real . If this is not provided, the mass of each atom is inferred from its most common isotope. If this is provided, it must be the same length as symbols but can accept None entries for standard masses to infer from the same index in the symbols field. molecular_charge : float pydantic-field \ud83d\udd17 The net electrostatic charge of the molecule. molecular_multiplicity : int pydantic-field \ud83d\udd17 The total multiplicity of the molecule. name : str pydantic-field \ud83d\udd17 Common or human-readable name to assign to this molecule. This field can be arbitrary; see identifiers for well-defined labels. provenance : Provenance pydantic-field \ud83d\udd17 The provenance information about how this Molecule (and its attributes) were generated, provided, and manipulated. real : Array property readonly \ud83d\udd17 real_ : Array pydantic-field \ud83d\udd17 The ordered array indicating if each atom is real ( True ) or ghost/virtual ( False ). Index matches the 0-indexed indices of all other per-atom settings like symbols and the first dimension of geometry . If this is not provided, all atoms are assumed to be real ( True ).If this is provided, the reality or ghostedness of every atom must be specified. schema_name : ConstrainedStrValue pydantic-field \ud83d\udd17 The QCSchema specification to which this model conforms. Explicitly fixed as qcschema_molecule. schema_version : int pydantic-field \ud83d\udd17 The version number of schema_name to which this model conforms. symbols : Array pydantic-field required \ud83d\udd17 The ordered array of atomic elemental symbols in title case. This field's index sets atomic order for all other per-atom fields like real and the first dimension of geometry . Ghost/virtual atoms must have an entry here in symbols ; ghostedness is indicated through the real field. validated : bool pydantic-field \ud83d\udd17 A boolean indicator (for speed purposes) that the input Molecule data has been previously checked for schema (data layout and type) and physics (e.g., non-overlapping atoms, feasible multiplicity) compliance. This should be False in most cases. A True setting should only ever be set by the constructor for this class itself or other trusted sources such as a Fractal Server or previously serialized Molecules. Config ( Config ) \ud83d\udd17 Source code in qcelemental/models/molecule.py class Config ( ProtoModel . Config ): serialize_skip_defaults = True allow_mutation : bool inherited \ud83d\udd17 extra : str inherited \ud83d\udd17 force_skip_defaults : bool inherited \ud83d\udd17 json_encoders : Dict [ str , Any ] inherited \ud83d\udd17 serialize_default_excludes : Set inherited \ud83d\udd17 serialize_skip_defaults : bool \ud83d\udd17 repr_style ( self ) \ud83d\udd17 Source code in qcelemental/models/molecule.py repr_style = lambda self : [ ( \"name\" , self . name ), ( \"formula\" , self . get_molecular_formula ()), ( \"hash\" , self . get_hash ()[: 7 ]), ] schema_extra ( schema , model ) \ud83d\udd17 Source code in qcelemental/models/molecule.py def schema_extra ( schema , model ): # below addresses the draft-04 issue until https://github.com/samuelcolvin/pydantic/issues/1478 . schema [ \"$schema\" ] = qcschema_draft Methods \ud83d\udd17 __init__ ( self , orient : bool = False , validate : Optional [ bool ] = None , ** kwargs : Any ) -> None special \ud83d\udd17 Initializes the molecule object from dictionary-like values. Parameters \ud83d\udd17 orient If True, orientates the Molecule to a common reference frame. validate If None validation is always applied unless the validated flag is set. Otherwise uses the boolean to decide to validate the Molecule or not. **kwargs The values of the Molecule object attributes. Source code in qcelemental/models/molecule.py def __init__ ( self , orient : bool = False , validate : Optional [ bool ] = None , ** kwargs : Any ) -> None : r \"\"\"Initializes the molecule object from dictionary-like values. Parameters ---------- orient If True, orientates the Molecule to a common reference frame. validate If ``None`` validation is always applied unless the ``validated`` flag is set. Otherwise uses the boolean to decide to validate the Molecule or not. **kwargs The values of the Molecule object attributes. \"\"\" if validate is None : validate = not kwargs . get ( \"validated\" , False ) geometry_prep = kwargs . pop ( \"_geometry_prep\" , False ) geometry_noise = kwargs . pop ( \"geometry_noise\" , GEOMETRY_NOISE ) if validate : kwargs [ \"schema_name\" ] = kwargs . pop ( \"schema_name\" , \"qcschema_molecule\" ) kwargs [ \"schema_version\" ] = kwargs . pop ( \"schema_version\" , 2 ) # original_keys = set(kwargs.keys()) # revive when ready to revisit sparsity nonphysical = kwargs . pop ( \"nonphysical\" , False ) schema = to_schema ( from_schema ( kwargs , nonphysical = nonphysical ), dtype = kwargs [ \"schema_version\" ], copy = False , np_out = True ) schema = _filter_defaults ( schema ) kwargs [ \"validated\" ] = True kwargs = { ** kwargs , ** schema } # Allow any extra fields validate = True super () . __init__ ( ** kwargs ) # We are pulling out the values *explicitly* so that the pydantic skip_defaults works as expected # All attributes set below are equivalent to the default set. values = self . __dict__ if validate : values [ \"symbols\" ] = np . core . defchararray . title ( self . symbols ) # Title case for consistency if orient : values [ \"geometry\" ] = float_prep ( self . _orient_molecule_internal (), geometry_noise ) elif validate or geometry_prep : values [ \"geometry\" ] = float_prep ( values [ \"geometry\" ], geometry_noise ) align ( self , ref_mol : Molecule , * , do_plot : bool = False , verbose : int = 0 , atoms_map : bool = False , run_resorting : bool = False , mols_align : Union [ bool , float ] = False , run_to_completion : bool = False , uno_cutoff : float = 0.001 , run_mirror : bool = False , generic_ghosts : bool = False ) -> Tuple [ Molecule , Dict [ str , Any ]] \ud83d\udd17 Finds shift, rotation, and atom reordering of concern_mol (self) that best aligns with ref_mol . Wraps func: qcelemental.molutil.B787 for class: qcelemental.models.Molecule . Employs the Kabsch, Hungarian, and Uno algorithms to exhaustively locate the best alignment for non-oriented, non-ordered structures. Parameters \ud83d\udd17 ref_mol : qcelemental.models.Molecule Molecule to match. atoms_map Whether atom1 of ref_mol corresponds to atom1 of concern_mol , etc. If true, specifying True can save much time. mols_align Whether ref_mol and concern_mol have identical geometries (barring orientation or atom mapping) and expected final RMSD = 0. If True , procedure is truncated when RMSD condition met, saving time. If float, RMSD tolerance at which search for alignment stops. If provided, the alignment routine will throw an error if it fails to align the molecule within the specified RMSD tolerance. do_plot Pops up a mpl plot showing before, after, and ref geometries. run_to_completion Run reorderings to completion (past RMSD = 0) even if unnecessary because mols_align=True . Used to test worst-case timings. run_resorting Run the resorting machinery even if unnecessary because atoms_map=True . uno_cutoff TODO run_mirror Run alternate geometries potentially allowing best match to ref_mol from mirror image of concern_mol . Only run if system confirmed to be nonsuperimposable upon mirror reflection. generic_ghosts When one or both molecules doesn't have meaningful element info for ghosts (can happen when harvesting from a printout with a generic ghost symbol), set this to True to place all real=False atoms into the same space for alignment. Only allowed when atoms_map=True . verbose Print level. Returns \ud83d\udd17 mol : Molecule data : Dict[key, Any] Molecule is internal geometry of self optimally aligned and atom-ordered to ref_mol . Presently all fragment information is discarded. data['rmsd'] is RMSD [A] between ref_mol and the optimally aligned geometry computed. data['mill'] is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from concern_mol and the optimally aligned geometry. Source code in qcelemental/models/molecule.py def align ( self , ref_mol : \"Molecule\" , * , do_plot : bool = False , verbose : int = 0 , atoms_map : bool = False , run_resorting : bool = False , mols_align : Union [ bool , float ] = False , run_to_completion : bool = False , uno_cutoff : float = 1.0e-3 , run_mirror : bool = False , generic_ghosts : bool = False , ) -> Tuple [ \"Molecule\" , Dict [ str , Any ]]: r \"\"\"Finds shift, rotation, and atom reordering of `concern_mol` (self) that best aligns with `ref_mol`. Wraps :py:func:`qcelemental.molutil.B787` for :py:class:`qcelemental.models.Molecule`. Employs the Kabsch, Hungarian, and Uno algorithms to exhaustively locate the best alignment for non-oriented, non-ordered structures. Parameters ---------- ref_mol : qcelemental.models.Molecule Molecule to match. atoms_map Whether atom1 of `ref_mol` corresponds to atom1 of `concern_mol`, etc. If true, specifying `True` can save much time. mols_align Whether ref_mol and concern_mol have identical geometries (barring orientation or atom mapping) and expected final RMSD = 0. If `True`, procedure is truncated when RMSD condition met, saving time. If float, RMSD tolerance at which search for alignment stops. If provided, the alignment routine will throw an error if it fails to align the molecule within the specified RMSD tolerance. do_plot Pops up a mpl plot showing before, after, and ref geometries. run_to_completion Run reorderings to completion (past RMSD = 0) even if unnecessary because `mols_align=True`. Used to test worst-case timings. run_resorting Run the resorting machinery even if unnecessary because `atoms_map=True`. uno_cutoff TODO run_mirror Run alternate geometries potentially allowing best match to `ref_mol` from mirror image of `concern_mol`. Only run if system confirmed to be nonsuperimposable upon mirror reflection. generic_ghosts When one or both molecules doesn't have meaningful element info for ghosts (can happen when harvesting from a printout with a generic ghost symbol), set this to True to place all real=False atoms into the same space for alignment. Only allowed when ``atoms_map=True``. verbose Print level. Returns ------- mol : Molecule data : Dict[key, Any] Molecule is internal geometry of `self` optimally aligned and atom-ordered to `ref_mol`. Presently all fragment information is discarded. `data['rmsd']` is RMSD [A] between `ref_mol` and the optimally aligned geometry computed. `data['mill']` is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from `concern_mol` and the optimally aligned geometry. \"\"\" from ..molutil.align import B787 rgeom = np . array ( ref_mol . geometry ) runiq = np . asarray ( [ hashlib . sha1 (( sym + str ( mas )) . encode ( \"utf-8\" )) . hexdigest () for sym , mas in zip ( cast ( Iterable [ str ], ref_mol . symbols ), ref_mol . masses ) ] ) concern_mol = self cgeom = np . array ( concern_mol . geometry ) cuniq = np . asarray ( [ hashlib . sha1 (( sym + str ( mas )) . encode ( \"utf-8\" )) . hexdigest () for sym , mas in zip ( cast ( Iterable [ str ], concern_mol . symbols ), concern_mol . masses ) ] ) if generic_ghosts : if not mols_align : raise ValueError ( \"Too risky to lump ghosts together when mols not superimposable.\" ) bq_hash = hashlib . sha1 (( \"bq\" ) . encode ( \"utf-8\" )) . hexdigest () runiq = np . asarray ([( rl_hash if rl else bq_hash ) for rl , rl_hash in zip ( ref_mol . real , runiq )]) cuniq = np . asarray ([( rl_hash if rl else bq_hash ) for rl , rl_hash in zip ( concern_mol . real , cuniq )]) rmsd , solution = B787 ( cgeom = cgeom , rgeom = rgeom , cuniq = cuniq , runiq = runiq , do_plot = do_plot , verbose = verbose , atoms_map = atoms_map , run_resorting = run_resorting , mols_align = mols_align , run_to_completion = run_to_completion , run_mirror = run_mirror , uno_cutoff = uno_cutoff , ) aupdate = { \"symbols\" : solution . align_atoms ( concern_mol . symbols ), \"geometry\" : solution . align_coordinates ( concern_mol . geometry , reverse = False ), \"masses\" : solution . align_atoms ( concern_mol . masses ), \"real\" : solution . align_atoms ( concern_mol . real ), \"atom_labels\" : solution . align_atoms ( concern_mol . atom_labels ), \"atomic_numbers\" : solution . align_atoms ( concern_mol . atomic_numbers ), \"mass_numbers\" : solution . align_atoms ( concern_mol . mass_numbers ), } adict = { ** concern_mol . dict (), ** aupdate } # preserve intrinsic symmetry with lighter truncation amol = Molecule ( validate = True , ** adict , geometry_noise = 13 ) # TODO -- can probably do more with fragments in amol now that # Mol is something with non-contig frags. frags now discarded. assert compare_values ( concern_mol . nuclear_repulsion_energy (), amol . nuclear_repulsion_energy (), \"Q: concern_mol-->returned_mol NRE uncorrupted\" , atol = 1.0e-4 , quiet = ( verbose > 1 ), ) if mols_align : assert compare_values ( ref_mol . nuclear_repulsion_energy (), amol . nuclear_repulsion_energy (), \"Q: concern_mol-->returned_mol NRE matches ref_mol\" , atol = 1.0e-4 , quiet = ( verbose > 1 ), ) assert compare ( True , np . allclose ( ref_mol . geometry , amol . geometry , atol = 4 ), \"Q: concern_mol-->returned_mol geometry matches ref_mol\" , quiet = ( verbose > 1 ), ) return amol , { \"rmsd\" : rmsd , \"mill\" : solution } compare ( self , other ) \ud83d\udd17 Compares the current object to the provided object recursively. Parameters \ud83d\udd17 other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive . Returns \ud83d\udd17 bool True if the objects match. Source code in qcelemental/models/molecule.py def compare ( self , other ): warnings . warn ( \"Molecule.compare is deprecated and will be removed in v0.13.0. Use == instead.\" , DeprecationWarning ) return self == other dict ( self , * args , ** kwargs ) \ud83d\udd17 Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/molecule.py def dict ( self , * args , ** kwargs ): kwargs [ \"by_alias\" ] = True kwargs [ \"exclude_unset\" ] = True return super () . dict ( * args , ** kwargs ) from_data ( data : Union [ str , Dict [ str , Any ], numpy . ndarray , bytes ], dtype : Optional [ str ] = None , * , orient : bool = False , validate : bool = None , ** kwargs : Dict [ str , Any ]) -> Molecule classmethod \ud83d\udd17 Constructs a molecule object from a data structure. Parameters \ud83d\udd17 data Data to construct Molecule from dtype How to interpret the data, if not passed attempts to discover this based on input type. orient Orientates the molecule to a standard frame or not. validate Validates the molecule or not. **kwargs Additional kwargs to pass to the constructors. kwargs take precedence over data. Returns \ud83d\udd17 Molecule A constructed molecule class. Source code in qcelemental/models/molecule.py @classmethod def from_data ( cls , data : Union [ str , Dict [ str , Any ], np . ndarray , bytes ], dtype : Optional [ str ] = None , * , orient : bool = False , validate : bool = None , ** kwargs : Dict [ str , Any ], ) -> \"Molecule\" : r \"\"\" Constructs a molecule object from a data structure. Parameters ---------- data Data to construct Molecule from dtype How to interpret the data, if not passed attempts to discover this based on input type. orient Orientates the molecule to a standard frame or not. validate Validates the molecule or not. **kwargs Additional kwargs to pass to the constructors. kwargs take precedence over data. Returns ------- Molecule A constructed molecule class. \"\"\" if dtype is None : if isinstance ( data , str ): dtype = \"string\" elif isinstance ( data , np . ndarray ): dtype = \"numpy\" elif isinstance ( data , dict ): dtype = \"dict\" elif isinstance ( dtype , bytes ): dtype = \"msgpack\" else : raise TypeError ( \"Input type not understood, please supply the 'dtype' kwarg.\" ) if dtype in [ \"string\" , \"psi4\" , \"xyz\" , \"xyz+\" ]: mol_dict = from_string ( data , dtype if dtype != \"string\" else None ) assert isinstance ( mol_dict , dict ) input_dict = to_schema ( mol_dict [ \"qm\" ], dtype = 2 , np_out = True ) input_dict = _filter_defaults ( input_dict ) input_dict [ \"validated\" ] = True input_dict [ \"_geometry_prep\" ] = True elif dtype == \"numpy\" : data = np . asarray ( data ) data = { \"geom\" : data [:, 1 :], \"elez\" : data [:, 0 ], \"units\" : kwargs . pop ( \"units\" , \"Angstrom\" ), \"fragment_separators\" : kwargs . pop ( \"frags\" , []), } input_dict = to_schema ( from_arrays ( ** data ), dtype = 2 , np_out = True ) input_dict = _filter_defaults ( input_dict ) input_dict [ \"validated\" ] = True input_dict [ \"_geometry_prep\" ] = True elif dtype == \"msgpack\" : assert isinstance ( data , bytes ) input_dict = msgpackext_loads ( data ) elif dtype == \"json\" : assert isinstance ( data , str ) input_dict = json . loads ( data ) elif dtype == \"dict\" : assert isinstance ( data , dict ) input_dict = data else : raise KeyError ( \"Dtype not understood ' {} '.\" . format ( dtype )) input_dict . update ( kwargs ) # if charge/spin options are given, invalidate charge and spin options that are missing charge_spin_opts = { \"molecular_charge\" , \"fragment_charges\" , \"molecular_multiplicity\" , \"fragment_multiplicities\" } kwarg_keys = set ( kwargs . keys ()) if len ( charge_spin_opts & kwarg_keys ) > 0 : for key in charge_spin_opts - kwarg_keys : input_dict . pop ( key , None ) input_dict . pop ( \"validated\" , None ) return cls ( orient = orient , validate = validate , ** input_dict ) from_file ( filename : str , dtype : Optional [ str ] = None , * , orient : bool = False , ** kwargs ) classmethod \ud83d\udd17 Constructs a molecule object from a file. Parameters \ud83d\udd17 filename The filename to build dtype The type of file to interpret. orient Orientates the molecule to a standard frame or not. **kwargs Any additional keywords to pass to the constructor Returns \ud83d\udd17 Molecule A constructed molecule class. Source code in qcelemental/models/molecule.py @classmethod def from_file ( cls , filename : str , dtype : Optional [ str ] = None , * , orient : bool = False , ** kwargs ): r \"\"\" Constructs a molecule object from a file. Parameters ---------- filename The filename to build dtype The type of file to interpret. orient Orientates the molecule to a standard frame or not. **kwargs Any additional keywords to pass to the constructor Returns ------- Molecule A constructed molecule class. \"\"\" ext = Path ( filename ) . suffix if dtype is None : if ext in _extension_map : dtype = _extension_map [ ext ] else : # Let `from_string` try to sort it dtype = \"string\" # Raw string type, read and pass through if dtype in [ \"string\" , \"xyz\" , \"xyz+\" , \"psi4\" ]: with open ( filename , \"r\" ) as infile : data = infile . read () elif dtype == \"numpy\" : data = np . load ( filename ) elif dtype in [ \"json\" , \"json-ext\" ]: with open ( filename , \"r\" ) as infile : data = deserialize ( infile . read (), encoding = \"json-ext\" ) dtype = \"dict\" elif dtype in [ \"msgpack\" , \"msgpack-ext\" ]: with open ( filename , \"rb\" ) as infile_bytes : data = deserialize ( infile_bytes . read (), encoding = \"msgpack-ext\" ) dtype = \"dict\" else : raise KeyError ( \"Dtype not understood ' {} '.\" . format ( dtype )) return cls . from_data ( data , dtype , orient = orient , ** kwargs ) get_fragment ( self , real : Union [ int , List ], ghost : Union [ int , List ] = None , orient : bool = False , group_fragments : bool = True ) -> Molecule \ud83d\udd17 Get new Molecule with fragments preserved, dropped, or ghosted. Parameters \ud83d\udd17 real Fragment index or list of indices (0-indexed) to be real atoms in new Molecule. ghost Fragment index or list of indices (0-indexed) to be ghost atoms (basis fns only) in new Molecule. orient Whether or not to align (inertial frame) and phase geometry upon new Molecule instantiation (according to _orient_molecule_internal)? group_fragments Whether or not to group real fragments at the start of the atom list and ghost fragments toward the back. Previous to v0.5 , this was always effectively True. True is handy for finding duplicate (atom-order-independent) molecules by hash. False preserves fragment order (though collapsing gaps for absent fragments) like Psi4's extract_subsets . False is handy for gradients where atom order of returned values matters. Returns \ud83d\udd17 Molecule New qcelemental.models.Molecule with self \\'s fragments present, ghosted, or absent. Source code in qcelemental/models/molecule.py def get_fragment ( self , real : Union [ int , List ], ghost : Optional [ Union [ int , List ]] = None , orient : bool = False , group_fragments : bool = True , ) -> \"Molecule\" : r \"\"\"Get new Molecule with fragments preserved, dropped, or ghosted. Parameters ---------- real Fragment index or list of indices (0-indexed) to be real atoms in new Molecule. ghost Fragment index or list of indices (0-indexed) to be ghost atoms (basis fns only) in new Molecule. orient Whether or not to align (inertial frame) and phase geometry upon new Molecule instantiation (according to _orient_molecule_internal)? group_fragments Whether or not to group real fragments at the start of the atom list and ghost fragments toward the back. Previous to ``v0.5``, this was always effectively True. True is handy for finding duplicate (atom-order-independent) molecules by hash. False preserves fragment order (though collapsing gaps for absent fragments) like Psi4's ``extract_subsets``. False is handy for gradients where atom order of returned values matters. Returns ------- Molecule New qcelemental.models.Molecule with ``self``\\'s fragments present, ghosted, or absent. \"\"\" if isinstance ( real , int ): real = [ real ] if isinstance ( ghost , int ): ghost = [ ghost ] elif ghost is None : ghost = [] constructor_dict : Dict = {} ret_name = ( self . name if self . name is not None else \"\" ) + \" (\" + str ( real ) + \",\" + str ( ghost ) + \")\" constructor_dict [ \"name\" ] = ret_name # ret = Molecule(None, name=ret_name) if len ( set ( real ) & set ( ghost )): raise TypeError ( \"Molecule:get_fragment: real and ghost sets are overlapping! ( {0} , {1} ).\" . format ( str ( real ), str ( ghost )) ) geom_blocks = [] symbols = [] masses = [] real_atoms = [] fragments = [] fragment_charges = [] fragment_multiplicities = [] atom_size = 0 if group_fragments : # Loop through the real blocks frag_start = 0 for frag in real : frag_size = len ( self . fragments [ frag ]) geom_blocks . append ( self . geometry [ self . fragments [ frag ]]) for idx in self . fragments [ frag ]: symbols . append ( self . symbols [ idx ]) real_atoms . append ( True ) masses . append ( self . masses [ idx ]) fragments . append ( list ( range ( frag_start , frag_start + frag_size ))) frag_start += frag_size fragment_charges . append ( float ( self . fragment_charges [ frag ])) fragment_multiplicities . append ( self . fragment_multiplicities [ frag ]) # Set charge and multiplicity constructor_dict [ \"molecular_charge\" ] = sum ( fragment_charges ) constructor_dict [ \"molecular_multiplicity\" ] = sum ( x - 1 for x in fragment_multiplicities ) + 1 # Loop through the ghost blocks for frag in ghost : frag_size = len ( self . fragments [ frag ]) geom_blocks . append ( self . geometry [ self . fragments [ frag ]]) for idx in self . fragments [ frag ]: symbols . append ( self . symbols [ idx ]) real_atoms . append ( False ) masses . append ( self . masses [ idx ]) fragments . append ( list ( range ( frag_start , frag_start + frag_size ))) frag_start += frag_size fragment_charges . append ( 0 ) fragment_multiplicities . append ( 1 ) else : # List[Array[np.int32]] at2fr : List [ Union [ int , None ]] = [ None ] * len ( self . symbols ) for ifr , fr in enumerate ( self . fragments ): for iat in fr : at2fr [ iat ] = ifr at2at : List [ Union [ int , None ]] = [ None ] * len ( self . symbols ) for iat in range ( len ( self . symbols )): ifr = at2fr [ iat ] if ifr in real or ifr in ghost : geom_blocks . append ( self . geometry [ iat ]) symbols . append ( self . symbols [ iat ]) real_atoms . append ( ifr in real ) masses . append ( self . masses [ iat ]) at2at [ iat ] = atom_size atom_size += 1 else : at2at [ iat ] = None for ifr , fr in enumerate ( self . fragments ): if ifr in real or ifr in ghost : fragments . append ([ at2at [ iat ] for iat in fr ]) if ifr in real : fragment_charges . append ( self . fragment_charges [ ifr ]) fragment_multiplicities . append ( self . fragment_multiplicities [ ifr ]) elif ifr in ghost : fragment_charges . append ( 0 ) fragment_multiplicities . append ( 1 ) assert None not in fragments constructor_dict [ \"fragments\" ] = fragments constructor_dict [ \"fragment_charges\" ] = fragment_charges constructor_dict [ \"fragment_multiplicities\" ] = fragment_multiplicities constructor_dict [ \"symbols\" ] = symbols constructor_dict [ \"geometry\" ] = np . vstack ( geom_blocks ) constructor_dict [ \"real\" ] = real_atoms constructor_dict [ \"masses\" ] = masses return Molecule ( orient = orient , ** constructor_dict ) get_hash ( self ) \ud83d\udd17 Returns the hash of the molecule. Source code in qcelemental/models/molecule.py def get_hash ( self ): r \"\"\" Returns the hash of the molecule. \"\"\" m = hashlib . sha1 () concat = \"\" np . set_printoptions ( precision = 16 ) for field in self . hash_fields : data = getattr ( self , field ) if field == \"geometry\" : data = float_prep ( data , GEOMETRY_NOISE ) elif field == \"fragment_charges\" : data = float_prep ( data , CHARGE_NOISE ) elif field == \"molecular_charge\" : data = float_prep ( data , CHARGE_NOISE ) elif field == \"masses\" : data = float_prep ( data , MASS_NOISE ) concat += json . dumps ( data , default = lambda x : x . ravel () . tolist ()) m . update ( concat . encode ( \"utf-8\" )) return m . hexdigest () get_molecular_formula ( self , order : str = 'alphabetical' ) -> str \ud83d\udd17 Returns the molecular formula for a molecule. Parameters \ud83d\udd17 str, optional Sorting order of the formula. Valid choices are \"alphabetical\" and \"hill\". Returns \ud83d\udd17 str The molecular formula. Examples \ud83d\udd17 methane = qcelemental.models.Molecule(''' ... H 0.5288 0.1610 0.9359 ... C 0.0000 0.0000 0.0000 ... H 0.2051 0.8240 -0.6786 ... H 0.3345 -0.9314 -0.4496 ... H -1.0685 -0.0537 0.1921 ... ''') methane.get_molecular_formula() CH4 hcl = qcelemental.models.Molecule(''' ... H 0.0000 0.0000 0.0000 ... Cl 0.0000 0.0000 1.2000 ... ''') hcl.get_molecular_formula() ClH Source code in qcelemental/models/molecule.py def get_molecular_formula ( self , order : str = \"alphabetical\" ) -> str : r \"\"\" Returns the molecular formula for a molecule. Parameters ---------- order: str, optional Sorting order of the formula. Valid choices are \"alphabetical\" and \"hill\". Returns ------- str The molecular formula. Examples -------- >>> methane = qcelemental.models.Molecule(''' ... H 0.5288 0.1610 0.9359 ... C 0.0000 0.0000 0.0000 ... H 0.2051 0.8240 -0.6786 ... H 0.3345 -0.9314 -0.4496 ... H -1.0685 -0.0537 0.1921 ... ''') >>> methane.get_molecular_formula() CH4 >>> hcl = qcelemental.models.Molecule(''' ... H 0.0000 0.0000 0.0000 ... Cl 0.0000 0.0000 1.2000 ... ''') >>> hcl.get_molecular_formula() ClH \"\"\" from ..molutil import molecular_formula_from_symbols return molecular_formula_from_symbols ( symbols = self . symbols , order = order ) json ( self , ** kwargs ) inherited \ud83d\udd17 Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/molecule.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs ) measure ( self , measurements : Union [ List [ int ], List [ List [ int ]]], * , degrees : bool = True ) -> Union [ float , List [ float ]] \ud83d\udd17 Takes a measurement of the moleucle from the indicies provided. Parameters \ud83d\udd17 measurements Either a single list of indices or multiple. Return a distance, angle, or dihedral depending if 2, 3, or 4 indices is provided, respectively. Values are returned in Bohr (distance) or degree. degrees Returns degrees by default, radians otherwise. Returns \ud83d\udd17 Union[float, List[float]] Either a value or list of the measured values. Source code in qcelemental/models/molecule.py def measure ( self , measurements : Union [ List [ int ], List [ List [ int ]]], * , degrees : bool = True ) -> Union [ float , List [ float ]]: r \"\"\" Takes a measurement of the moleucle from the indicies provided. Parameters ---------- measurements Either a single list of indices or multiple. Return a distance, angle, or dihedral depending if 2, 3, or 4 indices is provided, respectively. Values are returned in Bohr (distance) or degree. degrees Returns degrees by default, radians otherwise. Returns ------- Union[float, List[float]] Either a value or list of the measured values. \"\"\" return measure_coordinates ( self . geometry , measurements , degrees = degrees ) nelectrons ( self , ifr : int = None ) -> int \ud83d\udd17 Number of electrons. Parameters \ud83d\udd17 ifr If not None , only compute for the ifr -th (0-indexed) fragment. Returns \ud83d\udd17 nelec : int Number of electrons in entire molecule or in fragment. Source code in qcelemental/models/molecule.py def nelectrons ( self , ifr : int = None ) -> int : r \"\"\"Number of electrons. Parameters ---------- ifr If not `None`, only compute for the `ifr`-th (0-indexed) fragment. Returns ------- nelec : int Number of electrons in entire molecule or in fragment. \"\"\" Zeff = [ z * int ( real ) for z , real in zip ( cast ( Iterable [ int ], self . atomic_numbers ), self . real )] if ifr is None : nel = sum ( Zeff ) - self . molecular_charge else : nel = sum ([ zf for iat , zf in enumerate ( Zeff ) if iat in self . fragments [ ifr ]]) - self . fragment_charges [ ifr ] return int ( nel ) nuclear_repulsion_energy ( self , ifr : int = None ) -> float \ud83d\udd17 Nuclear repulsion energy. Parameters \ud83d\udd17 ifr If not None , only compute for the ifr -th (0-indexed) fragment. Returns \ud83d\udd17 nre : float Nuclear repulsion energy in entire molecule or in fragment. Source code in qcelemental/models/molecule.py def nuclear_repulsion_energy ( self , ifr : int = None ) -> float : r \"\"\"Nuclear repulsion energy. Parameters ---------- ifr If not `None`, only compute for the `ifr`-th (0-indexed) fragment. Returns ------- nre : float Nuclear repulsion energy in entire molecule or in fragment. \"\"\" Zeff = [ z * int ( real ) for z , real in zip ( cast ( Iterable [ int ], self . atomic_numbers ), self . real )] atoms = list ( range ( self . geometry . shape [ 0 ])) if ifr is not None : atoms = self . fragments [ ifr ] nre = 0.0 for iat1 , at1 in enumerate ( atoms ): for at2 in atoms [: iat1 ]: dist = np . linalg . norm ( self . geometry [ at1 ] - self . geometry [ at2 ]) nre += Zeff [ at1 ] * Zeff [ at2 ] / dist return nre orient_molecule ( self ) \ud83d\udd17 Centers the molecule and orients via inertia tensor before returning a new Molecule Source code in qcelemental/models/molecule.py def orient_molecule ( self ): r \"\"\" Centers the molecule and orients via inertia tensor before returning a new Molecule \"\"\" return Molecule ( orient = True , ** self . dict ()) pretty_print ( self ) \ud83d\udd17 Print the molecule in Angstroms. Same as func: print_out only always in Angstroms. (method name in libmints is print_in_angstrom) Source code in qcelemental/models/molecule.py def pretty_print ( self ): r \"\"\"Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms. (method name in libmints is print_in_angstrom) \"\"\" text = \"\" text += \"\"\" Geometry (in {0:s} ), charge = {1:.1f} , multiplicity = {2:d} : \\n\\n \"\"\" . format ( \"Angstrom\" , self . molecular_charge , self . molecular_multiplicity ) text += \"\"\" Center X Y Z \\n \"\"\" text += \"\"\" ------------ ----------------- ----------------- ----------------- \\n \"\"\" for i in range ( len ( self . geometry )): text += \"\"\" {0:8s}{1:4s} \"\"\" . format ( self . symbols [ i ], \"\" if self . real [ i ] else \"(Gh)\" ) for j in range ( 3 ): text += \"\"\" {0:17.12f} \"\"\" . format ( self . geometry [ i ][ j ] * constants . conversion_factor ( \"bohr\" , \"angstroms\" ) ) text += \" \\n \" # text += \"\\n\" return text scramble ( self , * , do_shift : Union [ bool , qcelemental . models . types . Array , List ] = True , do_rotate : Union [ bool , qcelemental . models . types . Array , List [ List ]] = True , do_resort : Union [ bool , List ] = True , deflection : float = 1.0 , do_mirror : bool = False , do_plot : bool = False , do_test : bool = False , run_to_completion : bool = False , run_resorting : bool = False , verbose : int = 0 ) -> Tuple [ Molecule , Dict [ str , Any ]] \ud83d\udd17 Generate a Molecule with random or directed translation, rotation, and atom shuffling. Optionally, check that the aligner returns the opposite transformation. Parameters \ud83d\udd17 ref_mol : qcelemental.models.Molecule Molecule to perturb. do_shift Whether to generate a random atom shift on interval [-3, 3) in each dimension ( True ) or leave at current origin. To shift by a specified vector, supply a 3-element list. do_rotate Whether to generate a random 3D rotation according to algorithm of Arvo. To rotate by a specified matrix, supply a 9-element list of lists. do_resort Whether to shuffle atoms ( True ) or leave 1st atom 1st, etc. ( False ). To specify shuffle, supply a nat-element list of indices. deflection If do_rotate , how random a rotation: 0.0 is no change, 0.1 is small perturbation, 1.0 is completely random. do_mirror Whether to construct the mirror image structure by inverting y-axis. do_plot Pops up a mpl plot showing before, after, and ref geometries. do_test Additionally, run the aligner on the returned Molecule and check that opposite transformations obtained. run_to_completion By construction, scrambled systems are fully alignable (final RMSD=0). Even so, True turns off the mechanism to stop when RMSD reaches zero and instead proceed to worst possible time. run_resorting Even if atoms not shuffled, test the resorting machinery. verbose Print level. Returns \ud83d\udd17 mol : Molecule data : Dict[key, Any] Molecule is scrambled copy of ref_mol (self). data['rmsd'] is RMSD [A] between ref_mol and the scrambled geometry. data['mill'] is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from ref_mol to the returned geometry. Raises \ud83d\udd17 AssertionError If do_test=True and aligner sanity check fails for any of the reverse transformations. Source code in qcelemental/models/molecule.py def scramble ( self , * , do_shift : Union [ bool , Array [ float ], List ] = True , do_rotate : Union [ bool , Array [ float ], List [ List ]] = True , do_resort : Union [ bool , List ] = True , deflection : float = 1.0 , do_mirror : bool = False , do_plot : bool = False , do_test : bool = False , run_to_completion : bool = False , run_resorting : bool = False , verbose : int = 0 , ) -> Tuple [ \"Molecule\" , Dict [ str , Any ]]: r \"\"\"Generate a Molecule with random or directed translation, rotation, and atom shuffling. Optionally, check that the aligner returns the opposite transformation. Parameters ---------- ref_mol : qcelemental.models.Molecule Molecule to perturb. do_shift Whether to generate a random atom shift on interval [-3, 3) in each dimension (`True`) or leave at current origin. To shift by a specified vector, supply a 3-element list. do_rotate Whether to generate a random 3D rotation according to algorithm of Arvo. To rotate by a specified matrix, supply a 9-element list of lists. do_resort Whether to shuffle atoms (`True`) or leave 1st atom 1st, etc. (`False`). To specify shuffle, supply a nat-element list of indices. deflection If `do_rotate`, how random a rotation: 0.0 is no change, 0.1 is small perturbation, 1.0 is completely random. do_mirror Whether to construct the mirror image structure by inverting y-axis. do_plot Pops up a mpl plot showing before, after, and ref geometries. do_test Additionally, run the aligner on the returned Molecule and check that opposite transformations obtained. run_to_completion By construction, scrambled systems are fully alignable (final RMSD=0). Even so, `True` turns off the mechanism to stop when RMSD reaches zero and instead proceed to worst possible time. run_resorting Even if atoms not shuffled, test the resorting machinery. verbose Print level. Returns ------- mol : Molecule data : Dict[key, Any] Molecule is scrambled copy of `ref_mol` (self). `data['rmsd']` is RMSD [A] between `ref_mol` and the scrambled geometry. `data['mill']` is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from `ref_mol` to the returned geometry. Raises ------ AssertionError If `do_test=True` and aligner sanity check fails for any of the reverse transformations. \"\"\" from ..molutil.align import compute_scramble ref_mol = self rgeom = ref_mol . geometry nat = rgeom . shape [ 0 ] perturbation = compute_scramble ( nat , do_shift = do_shift , do_rotate = do_rotate , deflection = deflection , do_resort = do_resort , do_mirror = do_mirror , ) cgeom = perturbation . align_coordinates ( rgeom , reverse = True ) cupdate = { \"symbols\" : perturbation . align_atoms ( ref_mol . symbols ), \"geometry\" : cgeom , \"masses\" : perturbation . align_atoms ( ref_mol . masses ), \"real\" : perturbation . align_atoms ( ref_mol . real ), \"atom_labels\" : perturbation . align_atoms ( ref_mol . atom_labels ), \"atomic_numbers\" : perturbation . align_atoms ( ref_mol . atomic_numbers ), \"mass_numbers\" : perturbation . align_atoms ( ref_mol . mass_numbers ), } cdict = { ** ref_mol . dict (), ** cupdate } # preserve intrinsic symmetry with lighter truncation cmol = Molecule ( validate = True , ** cdict , geometry_noise = 13 ) rmsd = np . linalg . norm ( cgeom - rgeom ) * constants . bohr2angstroms / np . sqrt ( nat ) if verbose >= 1 : print ( \"Start RMSD = {:8.4f} [A]\" . format ( rmsd )) if do_test : _ , data = cmol . align ( ref_mol , do_plot = do_plot , atoms_map = ( not do_resort ), run_resorting = run_resorting , mols_align = True , run_to_completion = run_to_completion , run_mirror = do_mirror , verbose = verbose , ) solution = data [ \"mill\" ] assert compare ( True , np . allclose ( solution . shift , perturbation . shift , atol = 1.0e-6 ), \"shifts equiv\" , quiet = ( verbose > 1 ) ) if not do_resort : assert compare ( True , np . allclose ( solution . rotation . T , perturbation . rotation ), \"rotations transpose\" , quiet = ( verbose > 1 ), ) if solution . mirror : assert compare ( True , do_mirror , \"mirror allowed\" , quiet = ( verbose > 1 )) return cmol , { \"rmsd\" : rmsd , \"mill\" : perturbation } serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None ) -> Union [ bytes , str ] inherited \ud83d\udd17 Generates a serialized representation of the model Parameters \ud83d\udd17 encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None . Returns \ud83d\udd17 Union[bytes, str] The serialized model. Source code in qcelemental/models/molecule.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: r \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding ) show ( self , ngl_kwargs : Optional [ Dict [ str , Any ]] = None ) -> nglview . NGLWidget \ud83d\udd17 Creates a 3D representation of a molecule that can be manipulated in Jupyter Notebooks and exported as images ( .png ). Parameters \ud83d\udd17 ngl_kwargs Addition nglview NGLWidget kwargs Returns \ud83d\udd17 nglview.NGLWidget A nglview view of the molecule Source code in qcelemental/models/molecule.py def show ( self , ngl_kwargs : Optional [ Dict [ str , Any ]] = None ) -> \"nglview.NGLWidget\" : # type: ignore r \"\"\"Creates a 3D representation of a molecule that can be manipulated in Jupyter Notebooks and exported as images (`.png`). Parameters ---------- ngl_kwargs Addition nglview NGLWidget kwargs Returns ------- nglview.NGLWidget A nglview view of the molecule \"\"\" if not which_import ( \"nglview\" , return_bool = True ): raise ModuleNotFoundError ( f \"Python module nglwview not found. Solve by installing it: `conda install -c conda-forge nglview`\" ) # pragma: no cover import nglview as nv # type: ignore if ngl_kwargs is None : ngl_kwargs = {} structure = nv . TextStructure ( self . to_string ( \"nglview-sdf\" ), ext = \"sdf\" ) widget = nv . NGLWidget ( structure , ** ngl_kwargs ) return widget to_file ( self , filename : str , dtype : Optional [ str ] = None ) -> None \ud83d\udd17 Writes the Molecule to a file. Parameters \ud83d\udd17 filename The filename to write to dtype The type of file to write, attempts to infer dtype from the filename if not provided. Source code in qcelemental/models/molecule.py def to_file ( self , filename : str , dtype : Optional [ str ] = None ) -> None : r \"\"\"Writes the Molecule to a file. Parameters ---------- filename The filename to write to dtype The type of file to write, attempts to infer dtype from the filename if not provided. \"\"\" ext = Path ( filename ) . suffix if dtype is None : if ext in _extension_map : dtype = _extension_map [ ext ] else : raise KeyError ( f \"Could not infer dtype from filename: ` { filename } `\" ) if dtype in [ \"xyz\" , \"xyz+\" , \"psi4\" ]: stringified = self . to_string ( dtype ) elif dtype in [ \"json\" , \"json-ext\" , \"msgpack\" , \"msgpack-ext\" ]: stringified = self . serialize ( dtype ) elif dtype in [ \"numpy\" ]: elements = np . array ( self . atomic_numbers ) . reshape ( - 1 , 1 ) npmol = np . hstack (( elements , self . geometry * constants . conversion_factor ( \"bohr\" , \"angstroms\" ))) np . save ( filename , npmol ) return else : raise KeyError ( f \"Dtype ` { dtype } ` is not valid\" ) flags = \"wb\" if dtype . startswith ( \"msgpack\" ) else \"w\" with open ( filename , flags ) as handle : handle . write ( stringified ) to_string ( self , dtype : str , units : str = None , * , atom_format : str = None , ghost_format : str = None , width : int = 17 , prec : int = 12 , return_data : bool = False ) \ud83d\udd17 Returns a string that can be used by a variety of programs. Unclear if this will be removed or renamed to \"to_psi4_string\" in the future Suggest psi4 --> psi4frag and psi4 route to to_string Source code in qcelemental/models/molecule.py def to_string ( # type: ignore self , dtype : str , units : str = None , * , atom_format : str = None , ghost_format : str = None , width : int = 17 , prec : int = 12 , return_data : bool = False , ): r \"\"\"Returns a string that can be used by a variety of programs. Unclear if this will be removed or renamed to \"to_psi4_string\" in the future Suggest psi4 --> psi4frag and psi4 route to to_string \"\"\" molrec = from_schema ( self . dict (), nonphysical = True ) return to_string ( molrec , dtype = dtype , units = units , atom_format = atom_format , ghost_format = ghost_format , width = width , prec = prec , return_data = return_data , )","title":"Molecule"},{"location":"code_reference/Molecule/#molecule","text":"","title":"Molecule"},{"location":"code_reference/Molecule/#overview","text":"The Molecule object is the core representation of a molecule used throughout tccloud . The molecule object is from the qcelemental.models module, but it is available in the tccloud.models module for your convenience. You can access the QCElemental documentation on the Molecule here . It is assumed that all geometries are in bohr .","title":"Overview"},{"location":"code_reference/Molecule/#import-the-model-object","text":"from tccloud.models import Molecule","title":"Import the Model object"},{"location":"code_reference/Molecule/#create-a-molecule","text":"Molecules can be created directly from data on pubchem , a python string, a psi4 file, an xyz file, an xyz+ file, or a json file. Pubchem: water = Molecule . from_data ( \"pubchem:water\" ) From Files: water = Molecule . from_file ( \"water.xyz\" ) water = Molecule . from_file ( \"water.psi4\" )","title":"Create a Molecule"},{"location":"code_reference/Molecule/#save-a-molecule-to-a-file","text":"water = Molecule . from_data ( \"pubchem:water\" ) # JSON is the prefered format since it preserves the most information water . to_file ( \"water.json\" ) water . to_file ( \"water.xyz\" ) water . to_file ( \"water.psi4\" )","title":"Save a Molecule to a file"},{"location":"code_reference/Molecule/#oft-used-attributes","text":"water = Molecule . from_data ( \"pubchem:water\" ) water . symbols array ([ 'O' , 'H' , 'H' ], dtype = '<U1' ) water . symbols water . geometry array ([[ 0. , 0. , 0. ], [ 0.52421003 , 1.68733646 , 0.48074633 ], [ 1.14668581 , - 0.45032174 , - 1.35474466 ]]) # All Attributes attrs = [ attr for attr in dir ( water ) if not attr . startswith ( \"_\" )] print ( attrs )","title":"Oft-used Attributes"},{"location":"code_reference/Molecule/#molecule-full-reference","text":"The physical Cartesian representation of the molecular system. A QCSchema representation of a Molecule. This model contains data for symbols, geometry, connectivity, charges, fragmentation, etc while also supporting a wide array of I/O and manipulation capabilities. Molecule objects geometry, masses, and charges are truncated to 8, 6, and 4 decimal places respectively to assist with duplicate detection.","title":"Molecule Full Reference"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule--notes","text":"All arrays are stored flat but must be reshapable into the dimensions in attribute shape , with abbreviations as follows: nat: number of atomic = calcinfo_natom nfr: number of fragments : irregular dimension not systematically reshapable Source code in qcelemental/models/molecule.py class Molecule ( ProtoModel ): r \"\"\" The physical Cartesian representation of the molecular system. A QCSchema representation of a Molecule. This model contains data for symbols, geometry, connectivity, charges, fragmentation, etc while also supporting a wide array of I/O and manipulation capabilities. Molecule objects geometry, masses, and charges are truncated to 8, 6, and 4 decimal places respectively to assist with duplicate detection. Notes ----- All arrays are stored flat but must be reshapable into the dimensions in attribute ``shape``, with abbreviations as follows: * nat: number of atomic = calcinfo_natom * nfr: number of fragments * <varies>: irregular dimension not systematically reshapable \"\"\" schema_name : constr ( strip_whitespace = True , regex = \"^(qcschema_molecule)$\" ) = Field ( # type: ignore qcschema_molecule_default , description = ( f \"The QCSchema specification to which this model conforms. Explicitly fixed as { qcschema_molecule_default } .\" ), ) schema_version : int = Field ( # type: ignore 2 , description = \"The version number of ``schema_name`` to which this model conforms.\" ) validated : bool = Field ( # type: ignore False , description = \"A boolean indicator (for speed purposes) that the input Molecule data has been previously checked \" \"for schema (data layout and type) and physics (e.g., non-overlapping atoms, feasible \" \"multiplicity) compliance. This should be False in most cases. A ``True`` setting \" \"should only ever be set by the constructor for this class itself or other trusted sources such as \" \"a Fractal Server or previously serialized Molecules.\" , ) # Required data symbols : Array [ str ] = Field ( # type: ignore ... , description = \"The ordered array of atomic elemental symbols in title case. This field's index \" \"sets atomic order for all other per-atom fields like ``real`` and the first dimension of \" \"``geometry``. Ghost/virtual atoms must have an entry here in ``symbols``; ghostedness is \" \"indicated through the ``real`` field.\" , shape = [ \"nat\" ], ) geometry : Array [ float ] = Field ( # type: ignore ... , description = \"The ordered array for Cartesian XYZ atomic coordinates [a0]. \" \"Atom ordering is fixed; that is, a consumer who shuffles atoms must not reattach the input \" \"(pre-shuffling) molecule schema instance to any output (post-shuffling) per-atom results \" \"(e.g., gradient). Index of the first dimension matches the 0-indexed indices of all other \" \"per-atom settings like ``symbols`` and ``real``.\" \" \\n \" \"Serialized storage is always flat, (3*nat,), but QCSchema implementations will want to reshape it. \" \"QCElemental can also accept array-likes which can be mapped to (nat,3) such as a 1-D list of length 3*nat, \" \"or the serialized version of the array in (3*nat,) shape; all forms will be reshaped to \" \"(nat,3) for this attribute.\" , shape = [ \"nat\" , 3 ], units = \"a0\" , ) # Molecule data name : Optional [ str ] = Field ( # type: ignore None , description = \"Common or human-readable name to assign to this molecule. This field can be arbitrary; see ``identifiers`` for well-defined labels.\" , ) identifiers : Optional [ Identifiers ] = Field ( # type: ignore None , description = \"An optional dictionary of additional identifiers by which this molecule can be referenced, \" \"such as INCHI, canonical SMILES, etc. See the :class:``Identifiers`` model for more details.\" , ) comment : Optional [ str ] = Field ( # type: ignore None , description = \"Additional comments for this molecule. Intended for pure human/user consumption and clarity.\" , ) molecular_charge : float = Field ( 0.0 , description = \"The net electrostatic charge of the molecule.\" ) # type: ignore molecular_multiplicity : int = Field ( 1 , description = \"The total multiplicity of the molecule.\" ) # type: ignore # Atom data masses_ : Optional [ Array [ float ]] = Field ( # type: ignore None , description = \"The ordered array of atomic masses. Index order \" \"matches the 0-indexed indices of all other per-atom fields like ``symbols`` and ``real``. If \" \"this is not provided, the mass of each atom is inferred from its most common isotope. If this \" \"is provided, it must be the same length as ``symbols`` but can accept ``None`` entries for \" \"standard masses to infer from the same index in the ``symbols`` field.\" , shape = [ \"nat\" ], units = \"u\" , ) real_ : Optional [ Array [ bool ]] = Field ( # type: ignore None , description = \"The ordered array indicating if each atom is real (``True``) or \" \"ghost/virtual (``False``). Index \" \"matches the 0-indexed indices of all other per-atom settings like ``symbols`` and the first \" \"dimension of ``geometry``. If this is not provided, all atoms are assumed to be real (``True``).\" \"If this is provided, the reality or ghostedness of every atom must be specified.\" , shape = [ \"nat\" ], ) atom_labels_ : Optional [ Array [ str ]] = Field ( # type: ignore None , description = \"Additional per-atom labels as an array of strings. Typical use is in \" \"model conversions, such as Elemental <-> Molpro and not typically something which should be user \" \"assigned. See the ``comments`` field for general human-consumable text to affix to the molecule.\" , shape = [ \"nat\" ], ) atomic_numbers_ : Optional [ Array [ np . int16 ]] = Field ( # type: ignore None , description = \"An optional ordered 1-D array-like object of atomic numbers of shape (nat,). Index \" \"matches the 0-indexed indices of all other per-atom settings like ``symbols`` and ``real``. \" \"Values are inferred from the ``symbols`` list if not explicitly set. \" \"Ghostedness should be indicated through ``real`` field, not zeros here.\" , shape = [ \"nat\" ], ) mass_numbers_ : Optional [ Array [ np . int16 ]] = Field ( # type: ignore None , description = \"An optional ordered 1-D array-like object of atomic *mass* numbers of shape (nat). Index \" \"matches the 0-indexed indices of all other per-atom settings like ``symbols`` and ``real``. \" \"Values are inferred from the most common isotopes of the ``symbols`` list if not explicitly set. \" \"If single isotope not (yet) known for an atom, -1 is placeholder.\" , shape = [ \"nat\" ], ) # Fragment and connection data connectivity_ : Optional [ List [ Tuple [ NonnegativeInt , NonnegativeInt , BondOrderFloat ]]] = Field ( # type: ignore None , description = \"A list of bonds within the molecule. Each entry is a tuple \" \"of ``(atom_index_A, atom_index_B, bond_order)`` where the ``atom_index`` \" \"matches the 0-indexed indices of all other per-atom settings like ``symbols`` and ``real``. \" \"Bonds may be freely reordered and inverted.\" , min_items = 1 , ) fragments_ : Optional [ List [ Array [ np . int32 ]]] = Field ( # type: ignore None , description = \"List of indices grouping atoms (0-indexed) into molecular fragments within the molecule. \" \"Each entry in the outer list is a new fragment; index matches the ordering in ``fragment_charges`` and \" \"``fragment_multiplicities``. Inner lists are 0-indexed atoms which compose the fragment; every atom must \" \"be in exactly one inner list. Noncontiguous fragments are allowed, though no QM program is known to support them. \" \"Fragment ordering is fixed; that is, a consumer who shuffles fragments must not reattach the input \" \"(pre-shuffling) molecule schema instance to any output (post-shuffling) per-fragment results (e.g., n-body energy arrays).\" , shape = [ \"nfr\" , \"<varies>\" ], ) fragment_charges_ : Optional [ List [ float ]] = Field ( # type: ignore None , description = \"The total charge of each fragment in the ``fragments`` list. The index of this \" \"list matches the 0-index indices of ``fragments`` list. Will be filled in based on a set of rules \" \"if not provided (and ``fragments`` are specified).\" , shape = [ \"nfr\" ], ) fragment_multiplicities_ : Optional [ List [ int ]] = Field ( # type: ignore None , description = \"The multiplicity of each fragment in the ``fragments`` list. The index of this \" \"list matches the 0-index indices of ``fragments`` list. Will be filled in based on a set of \" \"rules if not provided (and ``fragments`` are specified).\" , shape = [ \"nfr\" ], ) # Orientation fix_com : bool = Field ( # type: ignore False , description = \"Whether translation of geometry is allowed (fix F) or disallowed (fix T).\" \"When False, QCElemental will pre-process the Molecule object to translate the center of mass \" \"to (0,0,0) in Euclidean coordinate space, resulting in a different ``geometry`` than the \" \"one provided. 'Fix' is used in the sense of 'specify': that is, `fix_com=True` signals that \" \"the origin in `geometry` is a deliberate part of the Molecule spec, whereas `fix_com=False` \" \"(default) allows that the origin is happenstance and may be adjusted. \" \"guidance: A consumer who translates the geometry must not reattach the input (pre-translation) molecule schema instance to any output (post-translation) origin-sensitive results (e.g., an ordinary energy when EFP present).\" , ) fix_orientation : bool = Field ( # type: ignore False , description = \"Whether rotation of geometry is allowed (fix F) or disallowed (fix T). \" \"When False, QCElemental will pre-process the Molecule object to orient via the intertial tensor, \" \"resulting in a different ``geometry`` than the one provided. \" \"'Fix' is used in the sense of 'specify': that is, `fix_orientation=True` signals that \" \"the frame orientation in `geometry` is a deliberate part of the Molecule spec, whereas \" \"`fix_orientation=False` (default) allows that the frame is happenstance and may be adjusted. \" \"guidance: A consumer who rotates the geometry must not reattach the input (pre-rotation) molecule schema instance to any output (post-rotation) frame-sensitive results (e.g., molecular vibrations).\" , ) fix_symmetry : Optional [ str ] = Field ( # type: ignore None , description = \"Maximal point group symmetry which ``geometry`` should be treated. Lowercase.\" ) # Extra provenance : Provenance = Field ( default_factory = partial ( provenance_stamp , __name__ ), description = \"The provenance information about how this Molecule (and its attributes) were generated, \" \"provided, and manipulated.\" , ) id : Optional [ Any ] = Field ( # type: ignore None , description = \"A unique identifier for this Molecule object. This field exists primarily for Databases \" \"(e.g. Fractal's Server) to track and lookup this specific object and should virtually \" \"never need to be manually set.\" , ) extras : Dict [ str , Any ] = Field ( # type: ignore None , description = \"Additional information to bundle with the molecule. Use for schema development and scratch space.\" , ) class Config ( ProtoModel . Config ): serialize_skip_defaults = True repr_style = lambda self : [ ( \"name\" , self . name ), ( \"formula\" , self . get_molecular_formula ()), ( \"hash\" , self . get_hash ()[: 7 ]), ] fields = { \"masses_\" : \"masses\" , \"real_\" : \"real\" , \"atom_labels_\" : \"atom_labels\" , \"atomic_numbers_\" : \"atomic_numbers\" , \"mass_numbers_\" : \"mass_numbers\" , \"connectivity_\" : \"connectivity\" , \"fragments_\" : \"fragments\" , \"fragment_charges_\" : \"fragment_charges\" , \"fragment_multiplicities_\" : \"fragment_multiplicities\" , } def schema_extra ( schema , model ): # below addresses the draft-04 issue until https://github.com/samuelcolvin/pydantic/issues/1478 . schema [ \"$schema\" ] = qcschema_draft def __init__ ( self , orient : bool = False , validate : Optional [ bool ] = None , ** kwargs : Any ) -> None : r \"\"\"Initializes the molecule object from dictionary-like values. Parameters ---------- orient If True, orientates the Molecule to a common reference frame. validate If ``None`` validation is always applied unless the ``validated`` flag is set. Otherwise uses the boolean to decide to validate the Molecule or not. **kwargs The values of the Molecule object attributes. \"\"\" if validate is None : validate = not kwargs . get ( \"validated\" , False ) geometry_prep = kwargs . pop ( \"_geometry_prep\" , False ) geometry_noise = kwargs . pop ( \"geometry_noise\" , GEOMETRY_NOISE ) if validate : kwargs [ \"schema_name\" ] = kwargs . pop ( \"schema_name\" , \"qcschema_molecule\" ) kwargs [ \"schema_version\" ] = kwargs . pop ( \"schema_version\" , 2 ) # original_keys = set(kwargs.keys()) # revive when ready to revisit sparsity nonphysical = kwargs . pop ( \"nonphysical\" , False ) schema = to_schema ( from_schema ( kwargs , nonphysical = nonphysical ), dtype = kwargs [ \"schema_version\" ], copy = False , np_out = True ) schema = _filter_defaults ( schema ) kwargs [ \"validated\" ] = True kwargs = { ** kwargs , ** schema } # Allow any extra fields validate = True super () . __init__ ( ** kwargs ) # We are pulling out the values *explicitly* so that the pydantic skip_defaults works as expected # All attributes set below are equivalent to the default set. values = self . __dict__ if validate : values [ \"symbols\" ] = np . core . defchararray . title ( self . symbols ) # Title case for consistency if orient : values [ \"geometry\" ] = float_prep ( self . _orient_molecule_internal (), geometry_noise ) elif validate or geometry_prep : values [ \"geometry\" ] = float_prep ( values [ \"geometry\" ], geometry_noise ) @validator ( \"geometry\" ) def _must_be_3n ( cls , v , values , ** kwargs ): n = len ( values [ \"symbols\" ]) try : v = v . reshape ( n , 3 ) except ( ValueError , AttributeError ): raise ValueError ( \"Geometry must be castable to shape (N,3)!\" ) return v @validator ( \"masses_\" , \"real_\" ) def _must_be_n ( cls , v , values , ** kwargs ): n = len ( values [ \"symbols\" ]) if len ( v ) != n : raise ValueError ( \"Masses and Real must be same number of entries as Symbols\" ) return v @validator ( \"real_\" ) def _populate_real ( cls , v , values , ** kwargs ): # Can't use geometry here since its already been validated and not in values n = len ( values [ \"symbols\" ]) if len ( v ) == 0 : v = np . array ([ True for _ in range ( n )]) return v @validator ( \"fragment_charges_\" , \"fragment_multiplicities_\" ) def _must_be_n_frag ( cls , v , values , ** kwargs ): if \"fragments_\" in values and values [ \"fragments_\" ] is not None : n = len ( values [ \"fragments_\" ]) if len ( v ) != n : raise ValueError ( \"Fragment Charges and Fragment Multiplicities must be same number of entries as Fragments\" ) return v @property def hash_fields ( self ): return [ \"symbols\" , \"masses\" , \"molecular_charge\" , \"molecular_multiplicity\" , \"real\" , \"geometry\" , \"fragments\" , \"fragment_charges\" , \"fragment_multiplicities\" , \"connectivity\" , ] @property def masses ( self ) -> Array [ float ]: masses = self . __dict__ . get ( \"masses_\" ) if masses is None : masses = np . array ([ periodictable . to_mass ( x ) for x in self . symbols ]) return masses @property def real ( self ) -> Array [ bool ]: real = self . __dict__ . get ( \"real_\" ) if real is None : real = np . array ([ True for x in self . symbols ]) return real @property def atom_labels ( self ) -> Array [ str ]: atom_labels = self . __dict__ . get ( \"atom_labels_\" ) if atom_labels is None : atom_labels = np . array ([ \"\" for x in self . symbols ]) return atom_labels @property def atomic_numbers ( self ) -> Array [ np . int16 ]: atomic_numbers = self . __dict__ . get ( \"atomic_numbers_\" ) if atomic_numbers is None : atomic_numbers = np . array ([ periodictable . to_Z ( x ) for x in self . symbols ]) return atomic_numbers @property def mass_numbers ( self ) -> Array [ np . int16 ]: mass_numbers = self . __dict__ . get ( \"mass_numbers_\" ) if mass_numbers is None : mass_numbers = np . array ([ periodictable . to_A ( x ) for x in self . symbols ]) return mass_numbers @property def connectivity ( self ) -> List [ Tuple [ int , int , float ]]: connectivity = self . __dict__ . get ( \"connectivity_\" ) # default is None, not [] return connectivity @property def fragments ( self ) -> List [ Array [ np . int32 ]]: fragments = self . __dict__ . get ( \"fragments_\" ) if fragments is None : fragments = [ np . arange ( len ( self . symbols ), dtype = np . int32 )] return fragments @property def fragment_charges ( self ) -> List [ float ]: fragment_charges = self . __dict__ . get ( \"fragment_charges_\" ) if fragment_charges is None : fragment_charges = [ self . molecular_charge ] return fragment_charges @property def fragment_multiplicities ( self ) -> List [ int ]: fragment_multiplicities = self . __dict__ . get ( \"fragment_multiplicities_\" ) if fragment_multiplicities is None : fragment_multiplicities = [ self . molecular_multiplicity ] return fragment_multiplicities ### Non-Pydantic API functions def show ( self , ngl_kwargs : Optional [ Dict [ str , Any ]] = None ) -> \"nglview.NGLWidget\" : # type: ignore r \"\"\"Creates a 3D representation of a molecule that can be manipulated in Jupyter Notebooks and exported as images (`.png`). Parameters ---------- ngl_kwargs Addition nglview NGLWidget kwargs Returns ------- nglview.NGLWidget A nglview view of the molecule \"\"\" if not which_import ( \"nglview\" , return_bool = True ): raise ModuleNotFoundError ( f \"Python module nglwview not found. Solve by installing it: `conda install -c conda-forge nglview`\" ) # pragma: no cover import nglview as nv # type: ignore if ngl_kwargs is None : ngl_kwargs = {} structure = nv . TextStructure ( self . to_string ( \"nglview-sdf\" ), ext = \"sdf\" ) widget = nv . NGLWidget ( structure , ** ngl_kwargs ) return widget def measure ( self , measurements : Union [ List [ int ], List [ List [ int ]]], * , degrees : bool = True ) -> Union [ float , List [ float ]]: r \"\"\" Takes a measurement of the moleucle from the indicies provided. Parameters ---------- measurements Either a single list of indices or multiple. Return a distance, angle, or dihedral depending if 2, 3, or 4 indices is provided, respectively. Values are returned in Bohr (distance) or degree. degrees Returns degrees by default, radians otherwise. Returns ------- Union[float, List[float]] Either a value or list of the measured values. \"\"\" return measure_coordinates ( self . geometry , measurements , degrees = degrees ) def orient_molecule ( self ): r \"\"\" Centers the molecule and orients via inertia tensor before returning a new Molecule \"\"\" return Molecule ( orient = True , ** self . dict ()) def compare ( self , other ): warnings . warn ( \"Molecule.compare is deprecated and will be removed in v0.13.0. Use == instead.\" , DeprecationWarning ) return self == other def __eq__ ( self , other ): r \"\"\" Checks if two molecules are identical. This is a molecular identity defined by scientific terms, and not programing terms, so it's less rigorous than a programmatic equality or a memory equivalent `is`. \"\"\" if isinstance ( other , dict ): other = Molecule ( orient = False , ** other ) elif isinstance ( other , Molecule ): pass else : raise TypeError ( \"Comparison molecule not understood of type ' {} '.\" . format ( type ( other ))) return self . get_hash () == other . get_hash () def dict ( self , * args , ** kwargs ): kwargs [ \"by_alias\" ] = True kwargs [ \"exclude_unset\" ] = True return super () . dict ( * args , ** kwargs ) def pretty_print ( self ): r \"\"\"Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms. (method name in libmints is print_in_angstrom) \"\"\" text = \"\" text += \"\"\" Geometry (in {0:s} ), charge = {1:.1f} , multiplicity = {2:d} : \\n\\n \"\"\" . format ( \"Angstrom\" , self . molecular_charge , self . molecular_multiplicity ) text += \"\"\" Center X Y Z \\n \"\"\" text += \"\"\" ------------ ----------------- ----------------- ----------------- \\n \"\"\" for i in range ( len ( self . geometry )): text += \"\"\" {0:8s}{1:4s} \"\"\" . format ( self . symbols [ i ], \"\" if self . real [ i ] else \"(Gh)\" ) for j in range ( 3 ): text += \"\"\" {0:17.12f} \"\"\" . format ( self . geometry [ i ][ j ] * constants . conversion_factor ( \"bohr\" , \"angstroms\" ) ) text += \" \\n \" # text += \"\\n\" return text def get_fragment ( self , real : Union [ int , List ], ghost : Optional [ Union [ int , List ]] = None , orient : bool = False , group_fragments : bool = True , ) -> \"Molecule\" : r \"\"\"Get new Molecule with fragments preserved, dropped, or ghosted. Parameters ---------- real Fragment index or list of indices (0-indexed) to be real atoms in new Molecule. ghost Fragment index or list of indices (0-indexed) to be ghost atoms (basis fns only) in new Molecule. orient Whether or not to align (inertial frame) and phase geometry upon new Molecule instantiation (according to _orient_molecule_internal)? group_fragments Whether or not to group real fragments at the start of the atom list and ghost fragments toward the back. Previous to ``v0.5``, this was always effectively True. True is handy for finding duplicate (atom-order-independent) molecules by hash. False preserves fragment order (though collapsing gaps for absent fragments) like Psi4's ``extract_subsets``. False is handy for gradients where atom order of returned values matters. Returns ------- Molecule New qcelemental.models.Molecule with ``self``\\'s fragments present, ghosted, or absent. \"\"\" if isinstance ( real , int ): real = [ real ] if isinstance ( ghost , int ): ghost = [ ghost ] elif ghost is None : ghost = [] constructor_dict : Dict = {} ret_name = ( self . name if self . name is not None else \"\" ) + \" (\" + str ( real ) + \",\" + str ( ghost ) + \")\" constructor_dict [ \"name\" ] = ret_name # ret = Molecule(None, name=ret_name) if len ( set ( real ) & set ( ghost )): raise TypeError ( \"Molecule:get_fragment: real and ghost sets are overlapping! ( {0} , {1} ).\" . format ( str ( real ), str ( ghost )) ) geom_blocks = [] symbols = [] masses = [] real_atoms = [] fragments = [] fragment_charges = [] fragment_multiplicities = [] atom_size = 0 if group_fragments : # Loop through the real blocks frag_start = 0 for frag in real : frag_size = len ( self . fragments [ frag ]) geom_blocks . append ( self . geometry [ self . fragments [ frag ]]) for idx in self . fragments [ frag ]: symbols . append ( self . symbols [ idx ]) real_atoms . append ( True ) masses . append ( self . masses [ idx ]) fragments . append ( list ( range ( frag_start , frag_start + frag_size ))) frag_start += frag_size fragment_charges . append ( float ( self . fragment_charges [ frag ])) fragment_multiplicities . append ( self . fragment_multiplicities [ frag ]) # Set charge and multiplicity constructor_dict [ \"molecular_charge\" ] = sum ( fragment_charges ) constructor_dict [ \"molecular_multiplicity\" ] = sum ( x - 1 for x in fragment_multiplicities ) + 1 # Loop through the ghost blocks for frag in ghost : frag_size = len ( self . fragments [ frag ]) geom_blocks . append ( self . geometry [ self . fragments [ frag ]]) for idx in self . fragments [ frag ]: symbols . append ( self . symbols [ idx ]) real_atoms . append ( False ) masses . append ( self . masses [ idx ]) fragments . append ( list ( range ( frag_start , frag_start + frag_size ))) frag_start += frag_size fragment_charges . append ( 0 ) fragment_multiplicities . append ( 1 ) else : # List[Array[np.int32]] at2fr : List [ Union [ int , None ]] = [ None ] * len ( self . symbols ) for ifr , fr in enumerate ( self . fragments ): for iat in fr : at2fr [ iat ] = ifr at2at : List [ Union [ int , None ]] = [ None ] * len ( self . symbols ) for iat in range ( len ( self . symbols )): ifr = at2fr [ iat ] if ifr in real or ifr in ghost : geom_blocks . append ( self . geometry [ iat ]) symbols . append ( self . symbols [ iat ]) real_atoms . append ( ifr in real ) masses . append ( self . masses [ iat ]) at2at [ iat ] = atom_size atom_size += 1 else : at2at [ iat ] = None for ifr , fr in enumerate ( self . fragments ): if ifr in real or ifr in ghost : fragments . append ([ at2at [ iat ] for iat in fr ]) if ifr in real : fragment_charges . append ( self . fragment_charges [ ifr ]) fragment_multiplicities . append ( self . fragment_multiplicities [ ifr ]) elif ifr in ghost : fragment_charges . append ( 0 ) fragment_multiplicities . append ( 1 ) assert None not in fragments constructor_dict [ \"fragments\" ] = fragments constructor_dict [ \"fragment_charges\" ] = fragment_charges constructor_dict [ \"fragment_multiplicities\" ] = fragment_multiplicities constructor_dict [ \"symbols\" ] = symbols constructor_dict [ \"geometry\" ] = np . vstack ( geom_blocks ) constructor_dict [ \"real\" ] = real_atoms constructor_dict [ \"masses\" ] = masses return Molecule ( orient = orient , ** constructor_dict ) def to_string ( # type: ignore self , dtype : str , units : str = None , * , atom_format : str = None , ghost_format : str = None , width : int = 17 , prec : int = 12 , return_data : bool = False , ): r \"\"\"Returns a string that can be used by a variety of programs. Unclear if this will be removed or renamed to \"to_psi4_string\" in the future Suggest psi4 --> psi4frag and psi4 route to to_string \"\"\" molrec = from_schema ( self . dict (), nonphysical = True ) return to_string ( molrec , dtype = dtype , units = units , atom_format = atom_format , ghost_format = ghost_format , width = width , prec = prec , return_data = return_data , ) def get_hash ( self ): r \"\"\" Returns the hash of the molecule. \"\"\" m = hashlib . sha1 () concat = \"\" np . set_printoptions ( precision = 16 ) for field in self . hash_fields : data = getattr ( self , field ) if field == \"geometry\" : data = float_prep ( data , GEOMETRY_NOISE ) elif field == \"fragment_charges\" : data = float_prep ( data , CHARGE_NOISE ) elif field == \"molecular_charge\" : data = float_prep ( data , CHARGE_NOISE ) elif field == \"masses\" : data = float_prep ( data , MASS_NOISE ) concat += json . dumps ( data , default = lambda x : x . ravel () . tolist ()) m . update ( concat . encode ( \"utf-8\" )) return m . hexdigest () def get_molecular_formula ( self , order : str = \"alphabetical\" ) -> str : r \"\"\" Returns the molecular formula for a molecule. Parameters ---------- order: str, optional Sorting order of the formula. Valid choices are \"alphabetical\" and \"hill\". Returns ------- str The molecular formula. Examples -------- >>> methane = qcelemental.models.Molecule(''' ... H 0.5288 0.1610 0.9359 ... C 0.0000 0.0000 0.0000 ... H 0.2051 0.8240 -0.6786 ... H 0.3345 -0.9314 -0.4496 ... H -1.0685 -0.0537 0.1921 ... ''') >>> methane.get_molecular_formula() CH4 >>> hcl = qcelemental.models.Molecule(''' ... H 0.0000 0.0000 0.0000 ... Cl 0.0000 0.0000 1.2000 ... ''') >>> hcl.get_molecular_formula() ClH \"\"\" from ..molutil import molecular_formula_from_symbols return molecular_formula_from_symbols ( symbols = self . symbols , order = order ) ### Constructors @classmethod def from_data ( cls , data : Union [ str , Dict [ str , Any ], np . ndarray , bytes ], dtype : Optional [ str ] = None , * , orient : bool = False , validate : bool = None , ** kwargs : Dict [ str , Any ], ) -> \"Molecule\" : r \"\"\" Constructs a molecule object from a data structure. Parameters ---------- data Data to construct Molecule from dtype How to interpret the data, if not passed attempts to discover this based on input type. orient Orientates the molecule to a standard frame or not. validate Validates the molecule or not. **kwargs Additional kwargs to pass to the constructors. kwargs take precedence over data. Returns ------- Molecule A constructed molecule class. \"\"\" if dtype is None : if isinstance ( data , str ): dtype = \"string\" elif isinstance ( data , np . ndarray ): dtype = \"numpy\" elif isinstance ( data , dict ): dtype = \"dict\" elif isinstance ( dtype , bytes ): dtype = \"msgpack\" else : raise TypeError ( \"Input type not understood, please supply the 'dtype' kwarg.\" ) if dtype in [ \"string\" , \"psi4\" , \"xyz\" , \"xyz+\" ]: mol_dict = from_string ( data , dtype if dtype != \"string\" else None ) assert isinstance ( mol_dict , dict ) input_dict = to_schema ( mol_dict [ \"qm\" ], dtype = 2 , np_out = True ) input_dict = _filter_defaults ( input_dict ) input_dict [ \"validated\" ] = True input_dict [ \"_geometry_prep\" ] = True elif dtype == \"numpy\" : data = np . asarray ( data ) data = { \"geom\" : data [:, 1 :], \"elez\" : data [:, 0 ], \"units\" : kwargs . pop ( \"units\" , \"Angstrom\" ), \"fragment_separators\" : kwargs . pop ( \"frags\" , []), } input_dict = to_schema ( from_arrays ( ** data ), dtype = 2 , np_out = True ) input_dict = _filter_defaults ( input_dict ) input_dict [ \"validated\" ] = True input_dict [ \"_geometry_prep\" ] = True elif dtype == \"msgpack\" : assert isinstance ( data , bytes ) input_dict = msgpackext_loads ( data ) elif dtype == \"json\" : assert isinstance ( data , str ) input_dict = json . loads ( data ) elif dtype == \"dict\" : assert isinstance ( data , dict ) input_dict = data else : raise KeyError ( \"Dtype not understood ' {} '.\" . format ( dtype )) input_dict . update ( kwargs ) # if charge/spin options are given, invalidate charge and spin options that are missing charge_spin_opts = { \"molecular_charge\" , \"fragment_charges\" , \"molecular_multiplicity\" , \"fragment_multiplicities\" } kwarg_keys = set ( kwargs . keys ()) if len ( charge_spin_opts & kwarg_keys ) > 0 : for key in charge_spin_opts - kwarg_keys : input_dict . pop ( key , None ) input_dict . pop ( \"validated\" , None ) return cls ( orient = orient , validate = validate , ** input_dict ) @classmethod def from_file ( cls , filename : str , dtype : Optional [ str ] = None , * , orient : bool = False , ** kwargs ): r \"\"\" Constructs a molecule object from a file. Parameters ---------- filename The filename to build dtype The type of file to interpret. orient Orientates the molecule to a standard frame or not. **kwargs Any additional keywords to pass to the constructor Returns ------- Molecule A constructed molecule class. \"\"\" ext = Path ( filename ) . suffix if dtype is None : if ext in _extension_map : dtype = _extension_map [ ext ] else : # Let `from_string` try to sort it dtype = \"string\" # Raw string type, read and pass through if dtype in [ \"string\" , \"xyz\" , \"xyz+\" , \"psi4\" ]: with open ( filename , \"r\" ) as infile : data = infile . read () elif dtype == \"numpy\" : data = np . load ( filename ) elif dtype in [ \"json\" , \"json-ext\" ]: with open ( filename , \"r\" ) as infile : data = deserialize ( infile . read (), encoding = \"json-ext\" ) dtype = \"dict\" elif dtype in [ \"msgpack\" , \"msgpack-ext\" ]: with open ( filename , \"rb\" ) as infile_bytes : data = deserialize ( infile_bytes . read (), encoding = \"msgpack-ext\" ) dtype = \"dict\" else : raise KeyError ( \"Dtype not understood ' {} '.\" . format ( dtype )) return cls . from_data ( data , dtype , orient = orient , ** kwargs ) def to_file ( self , filename : str , dtype : Optional [ str ] = None ) -> None : r \"\"\"Writes the Molecule to a file. Parameters ---------- filename The filename to write to dtype The type of file to write, attempts to infer dtype from the filename if not provided. \"\"\" ext = Path ( filename ) . suffix if dtype is None : if ext in _extension_map : dtype = _extension_map [ ext ] else : raise KeyError ( f \"Could not infer dtype from filename: ` { filename } `\" ) if dtype in [ \"xyz\" , \"xyz+\" , \"psi4\" ]: stringified = self . to_string ( dtype ) elif dtype in [ \"json\" , \"json-ext\" , \"msgpack\" , \"msgpack-ext\" ]: stringified = self . serialize ( dtype ) elif dtype in [ \"numpy\" ]: elements = np . array ( self . atomic_numbers ) . reshape ( - 1 , 1 ) npmol = np . hstack (( elements , self . geometry * constants . conversion_factor ( \"bohr\" , \"angstroms\" ))) np . save ( filename , npmol ) return else : raise KeyError ( f \"Dtype ` { dtype } ` is not valid\" ) flags = \"wb\" if dtype . startswith ( \"msgpack\" ) else \"w\" with open ( filename , flags ) as handle : handle . write ( stringified ) ### Non-Pydantic internal functions def _orient_molecule_internal ( self ): r \"\"\" Centers the molecule and orients via inertia tensor before returning a new set of the molecule geometry \"\"\" new_geometry = self . geometry . copy () # Ensure we get a copy # Get the mass as an array # Masses are needed for orientation np_mass = np . array ( self . masses ) # Center on Mass new_geometry -= np . average ( new_geometry , axis = 0 , weights = np_mass ) # Rotate into inertial frame tensor = self . _inertial_tensor ( new_geometry , weight = np_mass ) _ , evecs = np . linalg . eigh ( tensor ) new_geometry = np . dot ( new_geometry , evecs ) # Phases? Lets do the simplest thing and ensure the first atom in each column # that is not on a plane is positve phase_check = [ False , False , False ] geom_noise = 10 ** ( - GEOMETRY_NOISE ) for num in range ( new_geometry . shape [ 0 ]): for x in range ( 3 ): if phase_check [ x ]: continue val = new_geometry [ num , x ] if abs ( val ) < geom_noise : continue phase_check [ x ] = True if val < 0 : new_geometry [:, x ] *= - 1 if sum ( phase_check ) == 3 : break return new_geometry def __repr_args__ ( self ) -> \"ReprArgs\" : return [( \"name\" , self . name ), ( \"formula\" , self . get_molecular_formula ()), ( \"hash\" , self . get_hash ()[: 7 ])] def _ipython_display_ ( self , ** kwargs ) -> None : try : self . show () . _ipython_display_ ( ** kwargs ) except ModuleNotFoundError : from IPython.display import display display ( f \"Install nglview for interactive visualization.\" , f \" { repr ( self ) } \" ) @staticmethod def _inertial_tensor ( geom , * , weight ): r \"\"\" Compute the moment inertia tensor for a given geometry. \"\"\" # Build inertia tensor tensor = np . zeros (( 3 , 3 )) # Diagonal tensor [ 0 ][ 0 ] = np . sum ( weight * ( geom [:, 1 ] ** 2.0 + geom [:, 2 ] ** 2.0 )) tensor [ 1 ][ 1 ] = np . sum ( weight * ( geom [:, 0 ] ** 2.0 + geom [:, 2 ] ** 2.0 )) tensor [ 2 ][ 2 ] = np . sum ( weight * ( geom [:, 0 ] ** 2.0 + geom [:, 1 ] ** 2.0 )) # I(alpha, beta) # Off diagonal tensor [ 1 ][ 0 ] = tensor [ 0 ][ 1 ] = - 1.0 * np . sum ( weight * geom [:, 0 ] * geom [:, 1 ]) tensor [ 2 ][ 0 ] = tensor [ 0 ][ 2 ] = - 1.0 * np . sum ( weight * geom [:, 0 ] * geom [:, 2 ]) tensor [ 2 ][ 1 ] = tensor [ 1 ][ 2 ] = - 1.0 * np . sum ( weight * geom [:, 1 ] * geom [:, 2 ]) return tensor def nuclear_repulsion_energy ( self , ifr : int = None ) -> float : r \"\"\"Nuclear repulsion energy. Parameters ---------- ifr If not `None`, only compute for the `ifr`-th (0-indexed) fragment. Returns ------- nre : float Nuclear repulsion energy in entire molecule or in fragment. \"\"\" Zeff = [ z * int ( real ) for z , real in zip ( cast ( Iterable [ int ], self . atomic_numbers ), self . real )] atoms = list ( range ( self . geometry . shape [ 0 ])) if ifr is not None : atoms = self . fragments [ ifr ] nre = 0.0 for iat1 , at1 in enumerate ( atoms ): for at2 in atoms [: iat1 ]: dist = np . linalg . norm ( self . geometry [ at1 ] - self . geometry [ at2 ]) nre += Zeff [ at1 ] * Zeff [ at2 ] / dist return nre def nelectrons ( self , ifr : int = None ) -> int : r \"\"\"Number of electrons. Parameters ---------- ifr If not `None`, only compute for the `ifr`-th (0-indexed) fragment. Returns ------- nelec : int Number of electrons in entire molecule or in fragment. \"\"\" Zeff = [ z * int ( real ) for z , real in zip ( cast ( Iterable [ int ], self . atomic_numbers ), self . real )] if ifr is None : nel = sum ( Zeff ) - self . molecular_charge else : nel = sum ([ zf for iat , zf in enumerate ( Zeff ) if iat in self . fragments [ ifr ]]) - self . fragment_charges [ ifr ] return int ( nel ) def align ( self , ref_mol : \"Molecule\" , * , do_plot : bool = False , verbose : int = 0 , atoms_map : bool = False , run_resorting : bool = False , mols_align : Union [ bool , float ] = False , run_to_completion : bool = False , uno_cutoff : float = 1.0e-3 , run_mirror : bool = False , generic_ghosts : bool = False , ) -> Tuple [ \"Molecule\" , Dict [ str , Any ]]: r \"\"\"Finds shift, rotation, and atom reordering of `concern_mol` (self) that best aligns with `ref_mol`. Wraps :py:func:`qcelemental.molutil.B787` for :py:class:`qcelemental.models.Molecule`. Employs the Kabsch, Hungarian, and Uno algorithms to exhaustively locate the best alignment for non-oriented, non-ordered structures. Parameters ---------- ref_mol : qcelemental.models.Molecule Molecule to match. atoms_map Whether atom1 of `ref_mol` corresponds to atom1 of `concern_mol`, etc. If true, specifying `True` can save much time. mols_align Whether ref_mol and concern_mol have identical geometries (barring orientation or atom mapping) and expected final RMSD = 0. If `True`, procedure is truncated when RMSD condition met, saving time. If float, RMSD tolerance at which search for alignment stops. If provided, the alignment routine will throw an error if it fails to align the molecule within the specified RMSD tolerance. do_plot Pops up a mpl plot showing before, after, and ref geometries. run_to_completion Run reorderings to completion (past RMSD = 0) even if unnecessary because `mols_align=True`. Used to test worst-case timings. run_resorting Run the resorting machinery even if unnecessary because `atoms_map=True`. uno_cutoff TODO run_mirror Run alternate geometries potentially allowing best match to `ref_mol` from mirror image of `concern_mol`. Only run if system confirmed to be nonsuperimposable upon mirror reflection. generic_ghosts When one or both molecules doesn't have meaningful element info for ghosts (can happen when harvesting from a printout with a generic ghost symbol), set this to True to place all real=False atoms into the same space for alignment. Only allowed when ``atoms_map=True``. verbose Print level. Returns ------- mol : Molecule data : Dict[key, Any] Molecule is internal geometry of `self` optimally aligned and atom-ordered to `ref_mol`. Presently all fragment information is discarded. `data['rmsd']` is RMSD [A] between `ref_mol` and the optimally aligned geometry computed. `data['mill']` is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from `concern_mol` and the optimally aligned geometry. \"\"\" from ..molutil.align import B787 rgeom = np . array ( ref_mol . geometry ) runiq = np . asarray ( [ hashlib . sha1 (( sym + str ( mas )) . encode ( \"utf-8\" )) . hexdigest () for sym , mas in zip ( cast ( Iterable [ str ], ref_mol . symbols ), ref_mol . masses ) ] ) concern_mol = self cgeom = np . array ( concern_mol . geometry ) cuniq = np . asarray ( [ hashlib . sha1 (( sym + str ( mas )) . encode ( \"utf-8\" )) . hexdigest () for sym , mas in zip ( cast ( Iterable [ str ], concern_mol . symbols ), concern_mol . masses ) ] ) if generic_ghosts : if not mols_align : raise ValueError ( \"Too risky to lump ghosts together when mols not superimposable.\" ) bq_hash = hashlib . sha1 (( \"bq\" ) . encode ( \"utf-8\" )) . hexdigest () runiq = np . asarray ([( rl_hash if rl else bq_hash ) for rl , rl_hash in zip ( ref_mol . real , runiq )]) cuniq = np . asarray ([( rl_hash if rl else bq_hash ) for rl , rl_hash in zip ( concern_mol . real , cuniq )]) rmsd , solution = B787 ( cgeom = cgeom , rgeom = rgeom , cuniq = cuniq , runiq = runiq , do_plot = do_plot , verbose = verbose , atoms_map = atoms_map , run_resorting = run_resorting , mols_align = mols_align , run_to_completion = run_to_completion , run_mirror = run_mirror , uno_cutoff = uno_cutoff , ) aupdate = { \"symbols\" : solution . align_atoms ( concern_mol . symbols ), \"geometry\" : solution . align_coordinates ( concern_mol . geometry , reverse = False ), \"masses\" : solution . align_atoms ( concern_mol . masses ), \"real\" : solution . align_atoms ( concern_mol . real ), \"atom_labels\" : solution . align_atoms ( concern_mol . atom_labels ), \"atomic_numbers\" : solution . align_atoms ( concern_mol . atomic_numbers ), \"mass_numbers\" : solution . align_atoms ( concern_mol . mass_numbers ), } adict = { ** concern_mol . dict (), ** aupdate } # preserve intrinsic symmetry with lighter truncation amol = Molecule ( validate = True , ** adict , geometry_noise = 13 ) # TODO -- can probably do more with fragments in amol now that # Mol is something with non-contig frags. frags now discarded. assert compare_values ( concern_mol . nuclear_repulsion_energy (), amol . nuclear_repulsion_energy (), \"Q: concern_mol-->returned_mol NRE uncorrupted\" , atol = 1.0e-4 , quiet = ( verbose > 1 ), ) if mols_align : assert compare_values ( ref_mol . nuclear_repulsion_energy (), amol . nuclear_repulsion_energy (), \"Q: concern_mol-->returned_mol NRE matches ref_mol\" , atol = 1.0e-4 , quiet = ( verbose > 1 ), ) assert compare ( True , np . allclose ( ref_mol . geometry , amol . geometry , atol = 4 ), \"Q: concern_mol-->returned_mol geometry matches ref_mol\" , quiet = ( verbose > 1 ), ) return amol , { \"rmsd\" : rmsd , \"mill\" : solution } def scramble ( self , * , do_shift : Union [ bool , Array [ float ], List ] = True , do_rotate : Union [ bool , Array [ float ], List [ List ]] = True , do_resort : Union [ bool , List ] = True , deflection : float = 1.0 , do_mirror : bool = False , do_plot : bool = False , do_test : bool = False , run_to_completion : bool = False , run_resorting : bool = False , verbose : int = 0 , ) -> Tuple [ \"Molecule\" , Dict [ str , Any ]]: r \"\"\"Generate a Molecule with random or directed translation, rotation, and atom shuffling. Optionally, check that the aligner returns the opposite transformation. Parameters ---------- ref_mol : qcelemental.models.Molecule Molecule to perturb. do_shift Whether to generate a random atom shift on interval [-3, 3) in each dimension (`True`) or leave at current origin. To shift by a specified vector, supply a 3-element list. do_rotate Whether to generate a random 3D rotation according to algorithm of Arvo. To rotate by a specified matrix, supply a 9-element list of lists. do_resort Whether to shuffle atoms (`True`) or leave 1st atom 1st, etc. (`False`). To specify shuffle, supply a nat-element list of indices. deflection If `do_rotate`, how random a rotation: 0.0 is no change, 0.1 is small perturbation, 1.0 is completely random. do_mirror Whether to construct the mirror image structure by inverting y-axis. do_plot Pops up a mpl plot showing before, after, and ref geometries. do_test Additionally, run the aligner on the returned Molecule and check that opposite transformations obtained. run_to_completion By construction, scrambled systems are fully alignable (final RMSD=0). Even so, `True` turns off the mechanism to stop when RMSD reaches zero and instead proceed to worst possible time. run_resorting Even if atoms not shuffled, test the resorting machinery. verbose Print level. Returns ------- mol : Molecule data : Dict[key, Any] Molecule is scrambled copy of `ref_mol` (self). `data['rmsd']` is RMSD [A] between `ref_mol` and the scrambled geometry. `data['mill']` is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from `ref_mol` to the returned geometry. Raises ------ AssertionError If `do_test=True` and aligner sanity check fails for any of the reverse transformations. \"\"\" from ..molutil.align import compute_scramble ref_mol = self rgeom = ref_mol . geometry nat = rgeom . shape [ 0 ] perturbation = compute_scramble ( nat , do_shift = do_shift , do_rotate = do_rotate , deflection = deflection , do_resort = do_resort , do_mirror = do_mirror , ) cgeom = perturbation . align_coordinates ( rgeom , reverse = True ) cupdate = { \"symbols\" : perturbation . align_atoms ( ref_mol . symbols ), \"geometry\" : cgeom , \"masses\" : perturbation . align_atoms ( ref_mol . masses ), \"real\" : perturbation . align_atoms ( ref_mol . real ), \"atom_labels\" : perturbation . align_atoms ( ref_mol . atom_labels ), \"atomic_numbers\" : perturbation . align_atoms ( ref_mol . atomic_numbers ), \"mass_numbers\" : perturbation . align_atoms ( ref_mol . mass_numbers ), } cdict = { ** ref_mol . dict (), ** cupdate } # preserve intrinsic symmetry with lighter truncation cmol = Molecule ( validate = True , ** cdict , geometry_noise = 13 ) rmsd = np . linalg . norm ( cgeom - rgeom ) * constants . bohr2angstroms / np . sqrt ( nat ) if verbose >= 1 : print ( \"Start RMSD = {:8.4f} [A]\" . format ( rmsd )) if do_test : _ , data = cmol . align ( ref_mol , do_plot = do_plot , atoms_map = ( not do_resort ), run_resorting = run_resorting , mols_align = True , run_to_completion = run_to_completion , run_mirror = do_mirror , verbose = verbose , ) solution = data [ \"mill\" ] assert compare ( True , np . allclose ( solution . shift , perturbation . shift , atol = 1.0e-6 ), \"shifts equiv\" , quiet = ( verbose > 1 ) ) if not do_resort : assert compare ( True , np . allclose ( solution . rotation . T , perturbation . rotation ), \"rotations transpose\" , quiet = ( verbose > 1 ), ) if solution . mirror : assert compare ( True , do_mirror , \"mirror allowed\" , quiet = ( verbose > 1 )) return cmol , { \"rmsd\" : rmsd , \"mill\" : perturbation }","title":"Notes"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule-attributes","text":"","title":"Attributes"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.atom_labels","text":"","title":"atom_labels"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.atom_labels_","text":"Additional per-atom labels as an array of strings. Typical use is in model conversions, such as Elemental <-> Molpro and not typically something which should be user assigned. See the comments field for general human-consumable text to affix to the molecule.","title":"atom_labels_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.atomic_numbers","text":"","title":"atomic_numbers"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.atomic_numbers_","text":"An optional ordered 1-D array-like object of atomic numbers of shape (nat,). Index matches the 0-indexed indices of all other per-atom settings like symbols and real . Values are inferred from the symbols list if not explicitly set. Ghostedness should be indicated through real field, not zeros here.","title":"atomic_numbers_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.comment","text":"Additional comments for this molecule. Intended for pure human/user consumption and clarity.","title":"comment"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.connectivity","text":"","title":"connectivity"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.connectivity_","text":"A list of bonds within the molecule. Each entry is a tuple of (atom_index_A, atom_index_B, bond_order) where the atom_index matches the 0-indexed indices of all other per-atom settings like symbols and real . Bonds may be freely reordered and inverted.","title":"connectivity_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.extras","text":"Additional information to bundle with the molecule. Use for schema development and scratch space.","title":"extras"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fix_com","text":"Whether translation of geometry is allowed (fix F) or disallowed (fix T).When False, QCElemental will pre-process the Molecule object to translate the center of mass to (0,0,0) in Euclidean coordinate space, resulting in a different geometry than the one provided. 'Fix' is used in the sense of 'specify': that is, fix_com=True signals that the origin in geometry is a deliberate part of the Molecule spec, whereas fix_com=False (default) allows that the origin is happenstance and may be adjusted. guidance: A consumer who translates the geometry must not reattach the input (pre-translation) molecule schema instance to any output (post-translation) origin-sensitive results (e.g., an ordinary energy when EFP present).","title":"fix_com"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fix_orientation","text":"Whether rotation of geometry is allowed (fix F) or disallowed (fix T). When False, QCElemental will pre-process the Molecule object to orient via the intertial tensor, resulting in a different geometry than the one provided. 'Fix' is used in the sense of 'specify': that is, fix_orientation=True signals that the frame orientation in geometry is a deliberate part of the Molecule spec, whereas fix_orientation=False (default) allows that the frame is happenstance and may be adjusted. guidance: A consumer who rotates the geometry must not reattach the input (pre-rotation) molecule schema instance to any output (post-rotation) frame-sensitive results (e.g., molecular vibrations).","title":"fix_orientation"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fix_symmetry","text":"Maximal point group symmetry which geometry should be treated. Lowercase.","title":"fix_symmetry"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fragment_charges","text":"","title":"fragment_charges"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fragment_charges_","text":"The total charge of each fragment in the fragments list. The index of this list matches the 0-index indices of fragments list. Will be filled in based on a set of rules if not provided (and fragments are specified).","title":"fragment_charges_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fragment_multiplicities","text":"","title":"fragment_multiplicities"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fragment_multiplicities_","text":"The multiplicity of each fragment in the fragments list. The index of this list matches the 0-index indices of fragments list. Will be filled in based on a set of rules if not provided (and fragments are specified).","title":"fragment_multiplicities_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fragments","text":"","title":"fragments"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fragments_","text":"List of indices grouping atoms (0-indexed) into molecular fragments within the molecule. Each entry in the outer list is a new fragment; index matches the ordering in fragment_charges and fragment_multiplicities . Inner lists are 0-indexed atoms which compose the fragment; every atom must be in exactly one inner list. Noncontiguous fragments are allowed, though no QM program is known to support them. Fragment ordering is fixed; that is, a consumer who shuffles fragments must not reattach the input (pre-shuffling) molecule schema instance to any output (post-shuffling) per-fragment results (e.g., n-body energy arrays).","title":"fragments_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.geometry","text":"The ordered array for Cartesian XYZ atomic coordinates [a0]. Atom ordering is fixed; that is, a consumer who shuffles atoms must not reattach the input (pre-shuffling) molecule schema instance to any output (post-shuffling) per-atom results (e.g., gradient). Index of the first dimension matches the 0-indexed indices of all other per-atom settings like symbols and real . Serialized storage is always flat, (3 nat,), but QCSchema implementations will want to reshape it. QCElemental can also accept array-likes which can be mapped to (nat,3) such as a 1-D list of length 3 nat, or the serialized version of the array in (3*nat,) shape; all forms will be reshaped to (nat,3) for this attribute.","title":"geometry"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.hash_fields","text":"","title":"hash_fields"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.id","text":"A unique identifier for this Molecule object. This field exists primarily for Databases (e.g. Fractal's Server) to track and lookup this specific object and should virtually never need to be manually set.","title":"id"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.identifiers","text":"An optional dictionary of additional identifiers by which this molecule can be referenced, such as INCHI, canonical SMILES, etc. See the :class: Identifiers model for more details.","title":"identifiers"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.mass_numbers","text":"","title":"mass_numbers"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.mass_numbers_","text":"An optional ordered 1-D array-like object of atomic mass numbers of shape (nat). Index matches the 0-indexed indices of all other per-atom settings like symbols and real . Values are inferred from the most common isotopes of the symbols list if not explicitly set. If single isotope not (yet) known for an atom, -1 is placeholder.","title":"mass_numbers_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.masses","text":"","title":"masses"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.masses_","text":"The ordered array of atomic masses. Index order matches the 0-indexed indices of all other per-atom fields like symbols and real . If this is not provided, the mass of each atom is inferred from its most common isotope. If this is provided, it must be the same length as symbols but can accept None entries for standard masses to infer from the same index in the symbols field.","title":"masses_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.molecular_charge","text":"The net electrostatic charge of the molecule.","title":"molecular_charge"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.molecular_multiplicity","text":"The total multiplicity of the molecule.","title":"molecular_multiplicity"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.name","text":"Common or human-readable name to assign to this molecule. This field can be arbitrary; see identifiers for well-defined labels.","title":"name"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.provenance","text":"The provenance information about how this Molecule (and its attributes) were generated, provided, and manipulated.","title":"provenance"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.real","text":"","title":"real"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.real_","text":"The ordered array indicating if each atom is real ( True ) or ghost/virtual ( False ). Index matches the 0-indexed indices of all other per-atom settings like symbols and the first dimension of geometry . If this is not provided, all atoms are assumed to be real ( True ).If this is provided, the reality or ghostedness of every atom must be specified.","title":"real_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.schema_name","text":"The QCSchema specification to which this model conforms. Explicitly fixed as qcschema_molecule.","title":"schema_name"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.schema_version","text":"The version number of schema_name to which this model conforms.","title":"schema_version"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.symbols","text":"The ordered array of atomic elemental symbols in title case. This field's index sets atomic order for all other per-atom fields like real and the first dimension of geometry . Ghost/virtual atoms must have an entry here in symbols ; ghostedness is indicated through the real field.","title":"symbols"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.validated","text":"A boolean indicator (for speed purposes) that the input Molecule data has been previously checked for schema (data layout and type) and physics (e.g., non-overlapping atoms, feasible multiplicity) compliance. This should be False in most cases. A True setting should only ever be set by the constructor for this class itself or other trusted sources such as a Fractal Server or previously serialized Molecules.","title":"validated"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config","text":"Source code in qcelemental/models/molecule.py class Config ( ProtoModel . Config ): serialize_skip_defaults = True","title":"Config"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config.allow_mutation","text":"","title":"allow_mutation"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config.extra","text":"","title":"extra"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config.force_skip_defaults","text":"","title":"force_skip_defaults"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config.json_encoders","text":"","title":"json_encoders"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config.serialize_default_excludes","text":"","title":"serialize_default_excludes"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config.serialize_skip_defaults","text":"","title":"serialize_skip_defaults"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config.repr_style","text":"Source code in qcelemental/models/molecule.py repr_style = lambda self : [ ( \"name\" , self . name ), ( \"formula\" , self . get_molecular_formula ()), ( \"hash\" , self . get_hash ()[: 7 ]), ]","title":"repr_style()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config.schema_extra","text":"Source code in qcelemental/models/molecule.py def schema_extra ( schema , model ): # below addresses the draft-04 issue until https://github.com/samuelcolvin/pydantic/issues/1478 . schema [ \"$schema\" ] = qcschema_draft","title":"schema_extra()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule-methods","text":"","title":"Methods"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.__init__","text":"Initializes the molecule object from dictionary-like values.","title":"__init__()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.__init__--parameters","text":"orient If True, orientates the Molecule to a common reference frame. validate If None validation is always applied unless the validated flag is set. Otherwise uses the boolean to decide to validate the Molecule or not. **kwargs The values of the Molecule object attributes. Source code in qcelemental/models/molecule.py def __init__ ( self , orient : bool = False , validate : Optional [ bool ] = None , ** kwargs : Any ) -> None : r \"\"\"Initializes the molecule object from dictionary-like values. Parameters ---------- orient If True, orientates the Molecule to a common reference frame. validate If ``None`` validation is always applied unless the ``validated`` flag is set. Otherwise uses the boolean to decide to validate the Molecule or not. **kwargs The values of the Molecule object attributes. \"\"\" if validate is None : validate = not kwargs . get ( \"validated\" , False ) geometry_prep = kwargs . pop ( \"_geometry_prep\" , False ) geometry_noise = kwargs . pop ( \"geometry_noise\" , GEOMETRY_NOISE ) if validate : kwargs [ \"schema_name\" ] = kwargs . pop ( \"schema_name\" , \"qcschema_molecule\" ) kwargs [ \"schema_version\" ] = kwargs . pop ( \"schema_version\" , 2 ) # original_keys = set(kwargs.keys()) # revive when ready to revisit sparsity nonphysical = kwargs . pop ( \"nonphysical\" , False ) schema = to_schema ( from_schema ( kwargs , nonphysical = nonphysical ), dtype = kwargs [ \"schema_version\" ], copy = False , np_out = True ) schema = _filter_defaults ( schema ) kwargs [ \"validated\" ] = True kwargs = { ** kwargs , ** schema } # Allow any extra fields validate = True super () . __init__ ( ** kwargs ) # We are pulling out the values *explicitly* so that the pydantic skip_defaults works as expected # All attributes set below are equivalent to the default set. values = self . __dict__ if validate : values [ \"symbols\" ] = np . core . defchararray . title ( self . symbols ) # Title case for consistency if orient : values [ \"geometry\" ] = float_prep ( self . _orient_molecule_internal (), geometry_noise ) elif validate or geometry_prep : values [ \"geometry\" ] = float_prep ( values [ \"geometry\" ], geometry_noise )","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.align","text":"Finds shift, rotation, and atom reordering of concern_mol (self) that best aligns with ref_mol . Wraps func: qcelemental.molutil.B787 for class: qcelemental.models.Molecule . Employs the Kabsch, Hungarian, and Uno algorithms to exhaustively locate the best alignment for non-oriented, non-ordered structures.","title":"align()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.align--parameters","text":"ref_mol : qcelemental.models.Molecule Molecule to match. atoms_map Whether atom1 of ref_mol corresponds to atom1 of concern_mol , etc. If true, specifying True can save much time. mols_align Whether ref_mol and concern_mol have identical geometries (barring orientation or atom mapping) and expected final RMSD = 0. If True , procedure is truncated when RMSD condition met, saving time. If float, RMSD tolerance at which search for alignment stops. If provided, the alignment routine will throw an error if it fails to align the molecule within the specified RMSD tolerance. do_plot Pops up a mpl plot showing before, after, and ref geometries. run_to_completion Run reorderings to completion (past RMSD = 0) even if unnecessary because mols_align=True . Used to test worst-case timings. run_resorting Run the resorting machinery even if unnecessary because atoms_map=True . uno_cutoff TODO run_mirror Run alternate geometries potentially allowing best match to ref_mol from mirror image of concern_mol . Only run if system confirmed to be nonsuperimposable upon mirror reflection. generic_ghosts When one or both molecules doesn't have meaningful element info for ghosts (can happen when harvesting from a printout with a generic ghost symbol), set this to True to place all real=False atoms into the same space for alignment. Only allowed when atoms_map=True . verbose Print level.","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.align--returns","text":"mol : Molecule data : Dict[key, Any] Molecule is internal geometry of self optimally aligned and atom-ordered to ref_mol . Presently all fragment information is discarded. data['rmsd'] is RMSD [A] between ref_mol and the optimally aligned geometry computed. data['mill'] is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from concern_mol and the optimally aligned geometry. Source code in qcelemental/models/molecule.py def align ( self , ref_mol : \"Molecule\" , * , do_plot : bool = False , verbose : int = 0 , atoms_map : bool = False , run_resorting : bool = False , mols_align : Union [ bool , float ] = False , run_to_completion : bool = False , uno_cutoff : float = 1.0e-3 , run_mirror : bool = False , generic_ghosts : bool = False , ) -> Tuple [ \"Molecule\" , Dict [ str , Any ]]: r \"\"\"Finds shift, rotation, and atom reordering of `concern_mol` (self) that best aligns with `ref_mol`. Wraps :py:func:`qcelemental.molutil.B787` for :py:class:`qcelemental.models.Molecule`. Employs the Kabsch, Hungarian, and Uno algorithms to exhaustively locate the best alignment for non-oriented, non-ordered structures. Parameters ---------- ref_mol : qcelemental.models.Molecule Molecule to match. atoms_map Whether atom1 of `ref_mol` corresponds to atom1 of `concern_mol`, etc. If true, specifying `True` can save much time. mols_align Whether ref_mol and concern_mol have identical geometries (barring orientation or atom mapping) and expected final RMSD = 0. If `True`, procedure is truncated when RMSD condition met, saving time. If float, RMSD tolerance at which search for alignment stops. If provided, the alignment routine will throw an error if it fails to align the molecule within the specified RMSD tolerance. do_plot Pops up a mpl plot showing before, after, and ref geometries. run_to_completion Run reorderings to completion (past RMSD = 0) even if unnecessary because `mols_align=True`. Used to test worst-case timings. run_resorting Run the resorting machinery even if unnecessary because `atoms_map=True`. uno_cutoff TODO run_mirror Run alternate geometries potentially allowing best match to `ref_mol` from mirror image of `concern_mol`. Only run if system confirmed to be nonsuperimposable upon mirror reflection. generic_ghosts When one or both molecules doesn't have meaningful element info for ghosts (can happen when harvesting from a printout with a generic ghost symbol), set this to True to place all real=False atoms into the same space for alignment. Only allowed when ``atoms_map=True``. verbose Print level. Returns ------- mol : Molecule data : Dict[key, Any] Molecule is internal geometry of `self` optimally aligned and atom-ordered to `ref_mol`. Presently all fragment information is discarded. `data['rmsd']` is RMSD [A] between `ref_mol` and the optimally aligned geometry computed. `data['mill']` is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from `concern_mol` and the optimally aligned geometry. \"\"\" from ..molutil.align import B787 rgeom = np . array ( ref_mol . geometry ) runiq = np . asarray ( [ hashlib . sha1 (( sym + str ( mas )) . encode ( \"utf-8\" )) . hexdigest () for sym , mas in zip ( cast ( Iterable [ str ], ref_mol . symbols ), ref_mol . masses ) ] ) concern_mol = self cgeom = np . array ( concern_mol . geometry ) cuniq = np . asarray ( [ hashlib . sha1 (( sym + str ( mas )) . encode ( \"utf-8\" )) . hexdigest () for sym , mas in zip ( cast ( Iterable [ str ], concern_mol . symbols ), concern_mol . masses ) ] ) if generic_ghosts : if not mols_align : raise ValueError ( \"Too risky to lump ghosts together when mols not superimposable.\" ) bq_hash = hashlib . sha1 (( \"bq\" ) . encode ( \"utf-8\" )) . hexdigest () runiq = np . asarray ([( rl_hash if rl else bq_hash ) for rl , rl_hash in zip ( ref_mol . real , runiq )]) cuniq = np . asarray ([( rl_hash if rl else bq_hash ) for rl , rl_hash in zip ( concern_mol . real , cuniq )]) rmsd , solution = B787 ( cgeom = cgeom , rgeom = rgeom , cuniq = cuniq , runiq = runiq , do_plot = do_plot , verbose = verbose , atoms_map = atoms_map , run_resorting = run_resorting , mols_align = mols_align , run_to_completion = run_to_completion , run_mirror = run_mirror , uno_cutoff = uno_cutoff , ) aupdate = { \"symbols\" : solution . align_atoms ( concern_mol . symbols ), \"geometry\" : solution . align_coordinates ( concern_mol . geometry , reverse = False ), \"masses\" : solution . align_atoms ( concern_mol . masses ), \"real\" : solution . align_atoms ( concern_mol . real ), \"atom_labels\" : solution . align_atoms ( concern_mol . atom_labels ), \"atomic_numbers\" : solution . align_atoms ( concern_mol . atomic_numbers ), \"mass_numbers\" : solution . align_atoms ( concern_mol . mass_numbers ), } adict = { ** concern_mol . dict (), ** aupdate } # preserve intrinsic symmetry with lighter truncation amol = Molecule ( validate = True , ** adict , geometry_noise = 13 ) # TODO -- can probably do more with fragments in amol now that # Mol is something with non-contig frags. frags now discarded. assert compare_values ( concern_mol . nuclear_repulsion_energy (), amol . nuclear_repulsion_energy (), \"Q: concern_mol-->returned_mol NRE uncorrupted\" , atol = 1.0e-4 , quiet = ( verbose > 1 ), ) if mols_align : assert compare_values ( ref_mol . nuclear_repulsion_energy (), amol . nuclear_repulsion_energy (), \"Q: concern_mol-->returned_mol NRE matches ref_mol\" , atol = 1.0e-4 , quiet = ( verbose > 1 ), ) assert compare ( True , np . allclose ( ref_mol . geometry , amol . geometry , atol = 4 ), \"Q: concern_mol-->returned_mol geometry matches ref_mol\" , quiet = ( verbose > 1 ), ) return amol , { \"rmsd\" : rmsd , \"mill\" : solution }","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.compare","text":"Compares the current object to the provided object recursively.","title":"compare()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.compare--parameters","text":"other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive .","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.compare--returns","text":"bool True if the objects match. Source code in qcelemental/models/molecule.py def compare ( self , other ): warnings . warn ( \"Molecule.compare is deprecated and will be removed in v0.13.0. Use == instead.\" , DeprecationWarning ) return self == other","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.dict","text":"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/molecule.py def dict ( self , * args , ** kwargs ): kwargs [ \"by_alias\" ] = True kwargs [ \"exclude_unset\" ] = True return super () . dict ( * args , ** kwargs )","title":"dict()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.from_data","text":"Constructs a molecule object from a data structure.","title":"from_data()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.from_data--parameters","text":"data Data to construct Molecule from dtype How to interpret the data, if not passed attempts to discover this based on input type. orient Orientates the molecule to a standard frame or not. validate Validates the molecule or not. **kwargs Additional kwargs to pass to the constructors. kwargs take precedence over data.","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.from_data--returns","text":"Molecule A constructed molecule class. Source code in qcelemental/models/molecule.py @classmethod def from_data ( cls , data : Union [ str , Dict [ str , Any ], np . ndarray , bytes ], dtype : Optional [ str ] = None , * , orient : bool = False , validate : bool = None , ** kwargs : Dict [ str , Any ], ) -> \"Molecule\" : r \"\"\" Constructs a molecule object from a data structure. Parameters ---------- data Data to construct Molecule from dtype How to interpret the data, if not passed attempts to discover this based on input type. orient Orientates the molecule to a standard frame or not. validate Validates the molecule or not. **kwargs Additional kwargs to pass to the constructors. kwargs take precedence over data. Returns ------- Molecule A constructed molecule class. \"\"\" if dtype is None : if isinstance ( data , str ): dtype = \"string\" elif isinstance ( data , np . ndarray ): dtype = \"numpy\" elif isinstance ( data , dict ): dtype = \"dict\" elif isinstance ( dtype , bytes ): dtype = \"msgpack\" else : raise TypeError ( \"Input type not understood, please supply the 'dtype' kwarg.\" ) if dtype in [ \"string\" , \"psi4\" , \"xyz\" , \"xyz+\" ]: mol_dict = from_string ( data , dtype if dtype != \"string\" else None ) assert isinstance ( mol_dict , dict ) input_dict = to_schema ( mol_dict [ \"qm\" ], dtype = 2 , np_out = True ) input_dict = _filter_defaults ( input_dict ) input_dict [ \"validated\" ] = True input_dict [ \"_geometry_prep\" ] = True elif dtype == \"numpy\" : data = np . asarray ( data ) data = { \"geom\" : data [:, 1 :], \"elez\" : data [:, 0 ], \"units\" : kwargs . pop ( \"units\" , \"Angstrom\" ), \"fragment_separators\" : kwargs . pop ( \"frags\" , []), } input_dict = to_schema ( from_arrays ( ** data ), dtype = 2 , np_out = True ) input_dict = _filter_defaults ( input_dict ) input_dict [ \"validated\" ] = True input_dict [ \"_geometry_prep\" ] = True elif dtype == \"msgpack\" : assert isinstance ( data , bytes ) input_dict = msgpackext_loads ( data ) elif dtype == \"json\" : assert isinstance ( data , str ) input_dict = json . loads ( data ) elif dtype == \"dict\" : assert isinstance ( data , dict ) input_dict = data else : raise KeyError ( \"Dtype not understood ' {} '.\" . format ( dtype )) input_dict . update ( kwargs ) # if charge/spin options are given, invalidate charge and spin options that are missing charge_spin_opts = { \"molecular_charge\" , \"fragment_charges\" , \"molecular_multiplicity\" , \"fragment_multiplicities\" } kwarg_keys = set ( kwargs . keys ()) if len ( charge_spin_opts & kwarg_keys ) > 0 : for key in charge_spin_opts - kwarg_keys : input_dict . pop ( key , None ) input_dict . pop ( \"validated\" , None ) return cls ( orient = orient , validate = validate , ** input_dict )","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.from_file","text":"Constructs a molecule object from a file.","title":"from_file()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.from_file--parameters","text":"filename The filename to build dtype The type of file to interpret. orient Orientates the molecule to a standard frame or not. **kwargs Any additional keywords to pass to the constructor","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.from_file--returns","text":"Molecule A constructed molecule class. Source code in qcelemental/models/molecule.py @classmethod def from_file ( cls , filename : str , dtype : Optional [ str ] = None , * , orient : bool = False , ** kwargs ): r \"\"\" Constructs a molecule object from a file. Parameters ---------- filename The filename to build dtype The type of file to interpret. orient Orientates the molecule to a standard frame or not. **kwargs Any additional keywords to pass to the constructor Returns ------- Molecule A constructed molecule class. \"\"\" ext = Path ( filename ) . suffix if dtype is None : if ext in _extension_map : dtype = _extension_map [ ext ] else : # Let `from_string` try to sort it dtype = \"string\" # Raw string type, read and pass through if dtype in [ \"string\" , \"xyz\" , \"xyz+\" , \"psi4\" ]: with open ( filename , \"r\" ) as infile : data = infile . read () elif dtype == \"numpy\" : data = np . load ( filename ) elif dtype in [ \"json\" , \"json-ext\" ]: with open ( filename , \"r\" ) as infile : data = deserialize ( infile . read (), encoding = \"json-ext\" ) dtype = \"dict\" elif dtype in [ \"msgpack\" , \"msgpack-ext\" ]: with open ( filename , \"rb\" ) as infile_bytes : data = deserialize ( infile_bytes . read (), encoding = \"msgpack-ext\" ) dtype = \"dict\" else : raise KeyError ( \"Dtype not understood ' {} '.\" . format ( dtype )) return cls . from_data ( data , dtype , orient = orient , ** kwargs )","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.get_fragment","text":"Get new Molecule with fragments preserved, dropped, or ghosted.","title":"get_fragment()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.get_fragment--parameters","text":"real Fragment index or list of indices (0-indexed) to be real atoms in new Molecule. ghost Fragment index or list of indices (0-indexed) to be ghost atoms (basis fns only) in new Molecule. orient Whether or not to align (inertial frame) and phase geometry upon new Molecule instantiation (according to _orient_molecule_internal)? group_fragments Whether or not to group real fragments at the start of the atom list and ghost fragments toward the back. Previous to v0.5 , this was always effectively True. True is handy for finding duplicate (atom-order-independent) molecules by hash. False preserves fragment order (though collapsing gaps for absent fragments) like Psi4's extract_subsets . False is handy for gradients where atom order of returned values matters.","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.get_fragment--returns","text":"Molecule New qcelemental.models.Molecule with self \\'s fragments present, ghosted, or absent. Source code in qcelemental/models/molecule.py def get_fragment ( self , real : Union [ int , List ], ghost : Optional [ Union [ int , List ]] = None , orient : bool = False , group_fragments : bool = True , ) -> \"Molecule\" : r \"\"\"Get new Molecule with fragments preserved, dropped, or ghosted. Parameters ---------- real Fragment index or list of indices (0-indexed) to be real atoms in new Molecule. ghost Fragment index or list of indices (0-indexed) to be ghost atoms (basis fns only) in new Molecule. orient Whether or not to align (inertial frame) and phase geometry upon new Molecule instantiation (according to _orient_molecule_internal)? group_fragments Whether or not to group real fragments at the start of the atom list and ghost fragments toward the back. Previous to ``v0.5``, this was always effectively True. True is handy for finding duplicate (atom-order-independent) molecules by hash. False preserves fragment order (though collapsing gaps for absent fragments) like Psi4's ``extract_subsets``. False is handy for gradients where atom order of returned values matters. Returns ------- Molecule New qcelemental.models.Molecule with ``self``\\'s fragments present, ghosted, or absent. \"\"\" if isinstance ( real , int ): real = [ real ] if isinstance ( ghost , int ): ghost = [ ghost ] elif ghost is None : ghost = [] constructor_dict : Dict = {} ret_name = ( self . name if self . name is not None else \"\" ) + \" (\" + str ( real ) + \",\" + str ( ghost ) + \")\" constructor_dict [ \"name\" ] = ret_name # ret = Molecule(None, name=ret_name) if len ( set ( real ) & set ( ghost )): raise TypeError ( \"Molecule:get_fragment: real and ghost sets are overlapping! ( {0} , {1} ).\" . format ( str ( real ), str ( ghost )) ) geom_blocks = [] symbols = [] masses = [] real_atoms = [] fragments = [] fragment_charges = [] fragment_multiplicities = [] atom_size = 0 if group_fragments : # Loop through the real blocks frag_start = 0 for frag in real : frag_size = len ( self . fragments [ frag ]) geom_blocks . append ( self . geometry [ self . fragments [ frag ]]) for idx in self . fragments [ frag ]: symbols . append ( self . symbols [ idx ]) real_atoms . append ( True ) masses . append ( self . masses [ idx ]) fragments . append ( list ( range ( frag_start , frag_start + frag_size ))) frag_start += frag_size fragment_charges . append ( float ( self . fragment_charges [ frag ])) fragment_multiplicities . append ( self . fragment_multiplicities [ frag ]) # Set charge and multiplicity constructor_dict [ \"molecular_charge\" ] = sum ( fragment_charges ) constructor_dict [ \"molecular_multiplicity\" ] = sum ( x - 1 for x in fragment_multiplicities ) + 1 # Loop through the ghost blocks for frag in ghost : frag_size = len ( self . fragments [ frag ]) geom_blocks . append ( self . geometry [ self . fragments [ frag ]]) for idx in self . fragments [ frag ]: symbols . append ( self . symbols [ idx ]) real_atoms . append ( False ) masses . append ( self . masses [ idx ]) fragments . append ( list ( range ( frag_start , frag_start + frag_size ))) frag_start += frag_size fragment_charges . append ( 0 ) fragment_multiplicities . append ( 1 ) else : # List[Array[np.int32]] at2fr : List [ Union [ int , None ]] = [ None ] * len ( self . symbols ) for ifr , fr in enumerate ( self . fragments ): for iat in fr : at2fr [ iat ] = ifr at2at : List [ Union [ int , None ]] = [ None ] * len ( self . symbols ) for iat in range ( len ( self . symbols )): ifr = at2fr [ iat ] if ifr in real or ifr in ghost : geom_blocks . append ( self . geometry [ iat ]) symbols . append ( self . symbols [ iat ]) real_atoms . append ( ifr in real ) masses . append ( self . masses [ iat ]) at2at [ iat ] = atom_size atom_size += 1 else : at2at [ iat ] = None for ifr , fr in enumerate ( self . fragments ): if ifr in real or ifr in ghost : fragments . append ([ at2at [ iat ] for iat in fr ]) if ifr in real : fragment_charges . append ( self . fragment_charges [ ifr ]) fragment_multiplicities . append ( self . fragment_multiplicities [ ifr ]) elif ifr in ghost : fragment_charges . append ( 0 ) fragment_multiplicities . append ( 1 ) assert None not in fragments constructor_dict [ \"fragments\" ] = fragments constructor_dict [ \"fragment_charges\" ] = fragment_charges constructor_dict [ \"fragment_multiplicities\" ] = fragment_multiplicities constructor_dict [ \"symbols\" ] = symbols constructor_dict [ \"geometry\" ] = np . vstack ( geom_blocks ) constructor_dict [ \"real\" ] = real_atoms constructor_dict [ \"masses\" ] = masses return Molecule ( orient = orient , ** constructor_dict )","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.get_hash","text":"Returns the hash of the molecule. Source code in qcelemental/models/molecule.py def get_hash ( self ): r \"\"\" Returns the hash of the molecule. \"\"\" m = hashlib . sha1 () concat = \"\" np . set_printoptions ( precision = 16 ) for field in self . hash_fields : data = getattr ( self , field ) if field == \"geometry\" : data = float_prep ( data , GEOMETRY_NOISE ) elif field == \"fragment_charges\" : data = float_prep ( data , CHARGE_NOISE ) elif field == \"molecular_charge\" : data = float_prep ( data , CHARGE_NOISE ) elif field == \"masses\" : data = float_prep ( data , MASS_NOISE ) concat += json . dumps ( data , default = lambda x : x . ravel () . tolist ()) m . update ( concat . encode ( \"utf-8\" )) return m . hexdigest ()","title":"get_hash()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.get_molecular_formula","text":"Returns the molecular formula for a molecule.","title":"get_molecular_formula()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.get_molecular_formula--parameters","text":"str, optional Sorting order of the formula. Valid choices are \"alphabetical\" and \"hill\".","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.get_molecular_formula--returns","text":"str The molecular formula.","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.get_molecular_formula--examples","text":"methane = qcelemental.models.Molecule(''' ... H 0.5288 0.1610 0.9359 ... C 0.0000 0.0000 0.0000 ... H 0.2051 0.8240 -0.6786 ... H 0.3345 -0.9314 -0.4496 ... H -1.0685 -0.0537 0.1921 ... ''') methane.get_molecular_formula() CH4 hcl = qcelemental.models.Molecule(''' ... H 0.0000 0.0000 0.0000 ... Cl 0.0000 0.0000 1.2000 ... ''') hcl.get_molecular_formula() ClH Source code in qcelemental/models/molecule.py def get_molecular_formula ( self , order : str = \"alphabetical\" ) -> str : r \"\"\" Returns the molecular formula for a molecule. Parameters ---------- order: str, optional Sorting order of the formula. Valid choices are \"alphabetical\" and \"hill\". Returns ------- str The molecular formula. Examples -------- >>> methane = qcelemental.models.Molecule(''' ... H 0.5288 0.1610 0.9359 ... C 0.0000 0.0000 0.0000 ... H 0.2051 0.8240 -0.6786 ... H 0.3345 -0.9314 -0.4496 ... H -1.0685 -0.0537 0.1921 ... ''') >>> methane.get_molecular_formula() CH4 >>> hcl = qcelemental.models.Molecule(''' ... H 0.0000 0.0000 0.0000 ... Cl 0.0000 0.0000 1.2000 ... ''') >>> hcl.get_molecular_formula() ClH \"\"\" from ..molutil import molecular_formula_from_symbols return molecular_formula_from_symbols ( symbols = self . symbols , order = order )","title":"Examples"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.json","text":"Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/molecule.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs )","title":"json()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.measure","text":"Takes a measurement of the moleucle from the indicies provided.","title":"measure()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.measure--parameters","text":"measurements Either a single list of indices or multiple. Return a distance, angle, or dihedral depending if 2, 3, or 4 indices is provided, respectively. Values are returned in Bohr (distance) or degree. degrees Returns degrees by default, radians otherwise.","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.measure--returns","text":"Union[float, List[float]] Either a value or list of the measured values. Source code in qcelemental/models/molecule.py def measure ( self , measurements : Union [ List [ int ], List [ List [ int ]]], * , degrees : bool = True ) -> Union [ float , List [ float ]]: r \"\"\" Takes a measurement of the moleucle from the indicies provided. Parameters ---------- measurements Either a single list of indices or multiple. Return a distance, angle, or dihedral depending if 2, 3, or 4 indices is provided, respectively. Values are returned in Bohr (distance) or degree. degrees Returns degrees by default, radians otherwise. Returns ------- Union[float, List[float]] Either a value or list of the measured values. \"\"\" return measure_coordinates ( self . geometry , measurements , degrees = degrees )","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.nelectrons","text":"Number of electrons.","title":"nelectrons()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.nelectrons--parameters","text":"ifr If not None , only compute for the ifr -th (0-indexed) fragment.","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.nelectrons--returns","text":"nelec : int Number of electrons in entire molecule or in fragment. Source code in qcelemental/models/molecule.py def nelectrons ( self , ifr : int = None ) -> int : r \"\"\"Number of electrons. Parameters ---------- ifr If not `None`, only compute for the `ifr`-th (0-indexed) fragment. Returns ------- nelec : int Number of electrons in entire molecule or in fragment. \"\"\" Zeff = [ z * int ( real ) for z , real in zip ( cast ( Iterable [ int ], self . atomic_numbers ), self . real )] if ifr is None : nel = sum ( Zeff ) - self . molecular_charge else : nel = sum ([ zf for iat , zf in enumerate ( Zeff ) if iat in self . fragments [ ifr ]]) - self . fragment_charges [ ifr ] return int ( nel )","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.nuclear_repulsion_energy","text":"Nuclear repulsion energy.","title":"nuclear_repulsion_energy()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.nuclear_repulsion_energy--parameters","text":"ifr If not None , only compute for the ifr -th (0-indexed) fragment.","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.nuclear_repulsion_energy--returns","text":"nre : float Nuclear repulsion energy in entire molecule or in fragment. Source code in qcelemental/models/molecule.py def nuclear_repulsion_energy ( self , ifr : int = None ) -> float : r \"\"\"Nuclear repulsion energy. Parameters ---------- ifr If not `None`, only compute for the `ifr`-th (0-indexed) fragment. Returns ------- nre : float Nuclear repulsion energy in entire molecule or in fragment. \"\"\" Zeff = [ z * int ( real ) for z , real in zip ( cast ( Iterable [ int ], self . atomic_numbers ), self . real )] atoms = list ( range ( self . geometry . shape [ 0 ])) if ifr is not None : atoms = self . fragments [ ifr ] nre = 0.0 for iat1 , at1 in enumerate ( atoms ): for at2 in atoms [: iat1 ]: dist = np . linalg . norm ( self . geometry [ at1 ] - self . geometry [ at2 ]) nre += Zeff [ at1 ] * Zeff [ at2 ] / dist return nre","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.orient_molecule","text":"Centers the molecule and orients via inertia tensor before returning a new Molecule Source code in qcelemental/models/molecule.py def orient_molecule ( self ): r \"\"\" Centers the molecule and orients via inertia tensor before returning a new Molecule \"\"\" return Molecule ( orient = True , ** self . dict ())","title":"orient_molecule()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.pretty_print","text":"Print the molecule in Angstroms. Same as func: print_out only always in Angstroms. (method name in libmints is print_in_angstrom) Source code in qcelemental/models/molecule.py def pretty_print ( self ): r \"\"\"Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms. (method name in libmints is print_in_angstrom) \"\"\" text = \"\" text += \"\"\" Geometry (in {0:s} ), charge = {1:.1f} , multiplicity = {2:d} : \\n\\n \"\"\" . format ( \"Angstrom\" , self . molecular_charge , self . molecular_multiplicity ) text += \"\"\" Center X Y Z \\n \"\"\" text += \"\"\" ------------ ----------------- ----------------- ----------------- \\n \"\"\" for i in range ( len ( self . geometry )): text += \"\"\" {0:8s}{1:4s} \"\"\" . format ( self . symbols [ i ], \"\" if self . real [ i ] else \"(Gh)\" ) for j in range ( 3 ): text += \"\"\" {0:17.12f} \"\"\" . format ( self . geometry [ i ][ j ] * constants . conversion_factor ( \"bohr\" , \"angstroms\" ) ) text += \" \\n \" # text += \"\\n\" return text","title":"pretty_print()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.scramble","text":"Generate a Molecule with random or directed translation, rotation, and atom shuffling. Optionally, check that the aligner returns the opposite transformation.","title":"scramble()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.scramble--parameters","text":"ref_mol : qcelemental.models.Molecule Molecule to perturb. do_shift Whether to generate a random atom shift on interval [-3, 3) in each dimension ( True ) or leave at current origin. To shift by a specified vector, supply a 3-element list. do_rotate Whether to generate a random 3D rotation according to algorithm of Arvo. To rotate by a specified matrix, supply a 9-element list of lists. do_resort Whether to shuffle atoms ( True ) or leave 1st atom 1st, etc. ( False ). To specify shuffle, supply a nat-element list of indices. deflection If do_rotate , how random a rotation: 0.0 is no change, 0.1 is small perturbation, 1.0 is completely random. do_mirror Whether to construct the mirror image structure by inverting y-axis. do_plot Pops up a mpl plot showing before, after, and ref geometries. do_test Additionally, run the aligner on the returned Molecule and check that opposite transformations obtained. run_to_completion By construction, scrambled systems are fully alignable (final RMSD=0). Even so, True turns off the mechanism to stop when RMSD reaches zero and instead proceed to worst possible time. run_resorting Even if atoms not shuffled, test the resorting machinery. verbose Print level.","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.scramble--returns","text":"mol : Molecule data : Dict[key, Any] Molecule is scrambled copy of ref_mol (self). data['rmsd'] is RMSD [A] between ref_mol and the scrambled geometry. data['mill'] is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from ref_mol to the returned geometry.","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.scramble--raises","text":"AssertionError If do_test=True and aligner sanity check fails for any of the reverse transformations. Source code in qcelemental/models/molecule.py def scramble ( self , * , do_shift : Union [ bool , Array [ float ], List ] = True , do_rotate : Union [ bool , Array [ float ], List [ List ]] = True , do_resort : Union [ bool , List ] = True , deflection : float = 1.0 , do_mirror : bool = False , do_plot : bool = False , do_test : bool = False , run_to_completion : bool = False , run_resorting : bool = False , verbose : int = 0 , ) -> Tuple [ \"Molecule\" , Dict [ str , Any ]]: r \"\"\"Generate a Molecule with random or directed translation, rotation, and atom shuffling. Optionally, check that the aligner returns the opposite transformation. Parameters ---------- ref_mol : qcelemental.models.Molecule Molecule to perturb. do_shift Whether to generate a random atom shift on interval [-3, 3) in each dimension (`True`) or leave at current origin. To shift by a specified vector, supply a 3-element list. do_rotate Whether to generate a random 3D rotation according to algorithm of Arvo. To rotate by a specified matrix, supply a 9-element list of lists. do_resort Whether to shuffle atoms (`True`) or leave 1st atom 1st, etc. (`False`). To specify shuffle, supply a nat-element list of indices. deflection If `do_rotate`, how random a rotation: 0.0 is no change, 0.1 is small perturbation, 1.0 is completely random. do_mirror Whether to construct the mirror image structure by inverting y-axis. do_plot Pops up a mpl plot showing before, after, and ref geometries. do_test Additionally, run the aligner on the returned Molecule and check that opposite transformations obtained. run_to_completion By construction, scrambled systems are fully alignable (final RMSD=0). Even so, `True` turns off the mechanism to stop when RMSD reaches zero and instead proceed to worst possible time. run_resorting Even if atoms not shuffled, test the resorting machinery. verbose Print level. Returns ------- mol : Molecule data : Dict[key, Any] Molecule is scrambled copy of `ref_mol` (self). `data['rmsd']` is RMSD [A] between `ref_mol` and the scrambled geometry. `data['mill']` is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from `ref_mol` to the returned geometry. Raises ------ AssertionError If `do_test=True` and aligner sanity check fails for any of the reverse transformations. \"\"\" from ..molutil.align import compute_scramble ref_mol = self rgeom = ref_mol . geometry nat = rgeom . shape [ 0 ] perturbation = compute_scramble ( nat , do_shift = do_shift , do_rotate = do_rotate , deflection = deflection , do_resort = do_resort , do_mirror = do_mirror , ) cgeom = perturbation . align_coordinates ( rgeom , reverse = True ) cupdate = { \"symbols\" : perturbation . align_atoms ( ref_mol . symbols ), \"geometry\" : cgeom , \"masses\" : perturbation . align_atoms ( ref_mol . masses ), \"real\" : perturbation . align_atoms ( ref_mol . real ), \"atom_labels\" : perturbation . align_atoms ( ref_mol . atom_labels ), \"atomic_numbers\" : perturbation . align_atoms ( ref_mol . atomic_numbers ), \"mass_numbers\" : perturbation . align_atoms ( ref_mol . mass_numbers ), } cdict = { ** ref_mol . dict (), ** cupdate } # preserve intrinsic symmetry with lighter truncation cmol = Molecule ( validate = True , ** cdict , geometry_noise = 13 ) rmsd = np . linalg . norm ( cgeom - rgeom ) * constants . bohr2angstroms / np . sqrt ( nat ) if verbose >= 1 : print ( \"Start RMSD = {:8.4f} [A]\" . format ( rmsd )) if do_test : _ , data = cmol . align ( ref_mol , do_plot = do_plot , atoms_map = ( not do_resort ), run_resorting = run_resorting , mols_align = True , run_to_completion = run_to_completion , run_mirror = do_mirror , verbose = verbose , ) solution = data [ \"mill\" ] assert compare ( True , np . allclose ( solution . shift , perturbation . shift , atol = 1.0e-6 ), \"shifts equiv\" , quiet = ( verbose > 1 ) ) if not do_resort : assert compare ( True , np . allclose ( solution . rotation . T , perturbation . rotation ), \"rotations transpose\" , quiet = ( verbose > 1 ), ) if solution . mirror : assert compare ( True , do_mirror , \"mirror allowed\" , quiet = ( verbose > 1 )) return cmol , { \"rmsd\" : rmsd , \"mill\" : perturbation }","title":"Raises"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.serialize","text":"Generates a serialized representation of the model","title":"serialize()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.serialize--parameters","text":"encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None .","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.serialize--returns","text":"Union[bytes, str] The serialized model. Source code in qcelemental/models/molecule.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: r \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.show","text":"Creates a 3D representation of a molecule that can be manipulated in Jupyter Notebooks and exported as images ( .png ).","title":"show()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.show--parameters","text":"ngl_kwargs Addition nglview NGLWidget kwargs","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.show--returns","text":"nglview.NGLWidget A nglview view of the molecule Source code in qcelemental/models/molecule.py def show ( self , ngl_kwargs : Optional [ Dict [ str , Any ]] = None ) -> \"nglview.NGLWidget\" : # type: ignore r \"\"\"Creates a 3D representation of a molecule that can be manipulated in Jupyter Notebooks and exported as images (`.png`). Parameters ---------- ngl_kwargs Addition nglview NGLWidget kwargs Returns ------- nglview.NGLWidget A nglview view of the molecule \"\"\" if not which_import ( \"nglview\" , return_bool = True ): raise ModuleNotFoundError ( f \"Python module nglwview not found. Solve by installing it: `conda install -c conda-forge nglview`\" ) # pragma: no cover import nglview as nv # type: ignore if ngl_kwargs is None : ngl_kwargs = {} structure = nv . TextStructure ( self . to_string ( \"nglview-sdf\" ), ext = \"sdf\" ) widget = nv . NGLWidget ( structure , ** ngl_kwargs ) return widget","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.to_file","text":"Writes the Molecule to a file.","title":"to_file()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.to_file--parameters","text":"filename The filename to write to dtype The type of file to write, attempts to infer dtype from the filename if not provided. Source code in qcelemental/models/molecule.py def to_file ( self , filename : str , dtype : Optional [ str ] = None ) -> None : r \"\"\"Writes the Molecule to a file. Parameters ---------- filename The filename to write to dtype The type of file to write, attempts to infer dtype from the filename if not provided. \"\"\" ext = Path ( filename ) . suffix if dtype is None : if ext in _extension_map : dtype = _extension_map [ ext ] else : raise KeyError ( f \"Could not infer dtype from filename: ` { filename } `\" ) if dtype in [ \"xyz\" , \"xyz+\" , \"psi4\" ]: stringified = self . to_string ( dtype ) elif dtype in [ \"json\" , \"json-ext\" , \"msgpack\" , \"msgpack-ext\" ]: stringified = self . serialize ( dtype ) elif dtype in [ \"numpy\" ]: elements = np . array ( self . atomic_numbers ) . reshape ( - 1 , 1 ) npmol = np . hstack (( elements , self . geometry * constants . conversion_factor ( \"bohr\" , \"angstroms\" ))) np . save ( filename , npmol ) return else : raise KeyError ( f \"Dtype ` { dtype } ` is not valid\" ) flags = \"wb\" if dtype . startswith ( \"msgpack\" ) else \"w\" with open ( filename , flags ) as handle : handle . write ( stringified )","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.to_string","text":"Returns a string that can be used by a variety of programs. Unclear if this will be removed or renamed to \"to_psi4_string\" in the future Suggest psi4 --> psi4frag and psi4 route to to_string Source code in qcelemental/models/molecule.py def to_string ( # type: ignore self , dtype : str , units : str = None , * , atom_format : str = None , ghost_format : str = None , width : int = 17 , prec : int = 12 , return_data : bool = False , ): r \"\"\"Returns a string that can be used by a variety of programs. Unclear if this will be removed or renamed to \"to_psi4_string\" in the future Suggest psi4 --> psi4frag and psi4 route to to_string \"\"\" molrec = from_schema ( self . dict (), nonphysical = True ) return to_string ( molrec , dtype = dtype , units = units , atom_format = atom_format , ghost_format = ghost_format , width = width , prec = prec , return_data = return_data , )","title":"to_string()"},{"location":"code_reference/OptimizationInput/","text":"Optimization Input \ud83d\udd17 Parameters \ud83d\udd17 id : str, Optional hash_index : str, Optional schema_name : ConstrainedStrValue, Default: qcschema_optimization_input schema_version : int, Default: 1 keywords : Dict[Any], Default: {} The optimization specific keywords to be used. extras : Dict[Any], Default: {} Extra fields that are not part of the schema. protocols : :class: OptimizationProtocols , Optional Protocols regarding the manipulation of a Optimization output data. Parameters ---------- trajectory : {all,initial_and_final,final,none}, Default: all Which gradient evaluations to keep in an optimization trajectory. input_specification : :class: QCInputSpecification A compute description for energy, gradient, and Hessian computations used in a geometry optimization. Parameters ---------- schema_name : ConstrainedStrValue, Default: qcschema_input schema_version : int, Default: 1 driver : {energy,gradient,hessian,properties}, Default: gradient Allowed computation driver values. model : :class:`Model` The computational molecular sciences model to run. Parameters ---------- method : str The quantum chemistry method to evaluate (e.g., B3LYP, PBE, ...). For MM, name of the force field. basis : Union[str, :class:`BasisSet`], Optional The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...). Can be ``None`` for methods without basis sets. For molecular mechanics, name of the atom-typer. keywords : Dict[Any], Default: {} The program specific keywords to be used. extras : Dict[Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. initial_molecule : :class: Molecule The starting molecule for the geometry optimization. provenance : :class: Provenance , Optional Provenance information. Parameters ---------- creator : str The name of the program, library, or person who created the object. version : str, Default: The version of the creator, blank otherwise. This should be sortable by the very broad [PEP 440](https://www.python.org/dev/peps/pep-0440/). routine : str, Default: The name of the routine or function within the creator, blank otherwise. Source code in qcelemental/models/procedures.py class OptimizationInput ( ProtoModel ): id : Optional [ str ] = None hash_index : Optional [ str ] = None schema_name : constr ( # type: ignore strip_whitespace = True , regex = qcschema_optimization_input_default ) = qcschema_optimization_input_default schema_version : int = 1 keywords : Dict [ str , Any ] = Field ({}, description = \"The optimization specific keywords to be used.\" ) extras : Dict [ str , Any ] = Field ({}, description = \"Extra fields that are not part of the schema.\" ) protocols : OptimizationProtocols = Field ( OptimizationProtocols (), description = str ( OptimizationProtocols . __doc__ )) input_specification : QCInputSpecification = Field ( ... , description = str ( QCInputSpecification . __doc__ )) initial_molecule : Molecule = Field ( ... , description = \"The starting molecule for the geometry optimization.\" ) provenance : Provenance = Field ( Provenance ( ** provenance_stamp ( __name__ )), description = str ( Provenance . __doc__ )) def __repr_args__ ( self ) -> \"ReprArgs\" : return [ ( \"model\" , self . input_specification . model . dict ()), ( \"molecule_hash\" , self . initial_molecule . get_hash ()[: 7 ]), ] Attributes \ud83d\udd17 extras : Dict [ str , Any ] pydantic-field \ud83d\udd17 Extra fields that are not part of the schema. hash_index : str pydantic-field \ud83d\udd17 id : str pydantic-field \ud83d\udd17 initial_molecule : Molecule pydantic-field required \ud83d\udd17 The starting molecule for the geometry optimization. input_specification : QCInputSpecification pydantic-field required \ud83d\udd17 A compute description for energy, gradient, and Hessian computations used in a geometry optimization. Parameters \ud83d\udd17 schema_name : ConstrainedStrValue, Default: qcschema_input schema_version : int, Default: 1 driver : {energy,gradient,hessian,properties}, Default: gradient Allowed computation driver values. model : :class: Model The computational molecular sciences model to run. Parameters ---------- method : str The quantum chemistry method to evaluate (e.g., B3LYP, PBE, ...). For MM, name of the force field. basis : Union[str, :class:`BasisSet`], Optional The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...). Can be ``None`` for methods without basis sets. For molecular mechanics, name of the atom-typer. keywords : Dict[Any], Default: {} The program specific keywords to be used. extras : Dict[Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. keywords : Dict [ str , Any ] pydantic-field \ud83d\udd17 The optimization specific keywords to be used. protocols : OptimizationProtocols pydantic-field \ud83d\udd17 Protocols regarding the manipulation of a Optimization output data. Parameters \ud83d\udd17 trajectory : {all,initial_and_final,final,none}, Default: all Which gradient evaluations to keep in an optimization trajectory. provenance : Provenance pydantic-field \ud83d\udd17 Provenance information. Parameters \ud83d\udd17 creator : str The name of the program, library, or person who created the object. version : str, Default: The version of the creator, blank otherwise. This should be sortable by the very broad PEP 440 . routine : str, Default: The name of the routine or function within the creator, blank otherwise. schema_name : ConstrainedStrValue pydantic-field \ud83d\udd17 schema_version : int pydantic-field \ud83d\udd17 Config inherited \ud83d\udd17 Source code in qcelemental/models/procedures.py class Config : allow_mutation : bool = False extra : str = \"forbid\" json_encoders : Dict [ str , Any ] = { np . ndarray : lambda v : v . flatten () . tolist ()} serialize_default_excludes : Set = set () serialize_skip_defaults : bool = False force_skip_defaults : bool = False allow_mutation : bool \ud83d\udd17 extra : str \ud83d\udd17 force_skip_defaults : bool \ud83d\udd17 json_encoders : Dict [ str , Any ] \ud83d\udd17 serialize_default_excludes : Set \ud83d\udd17 serialize_skip_defaults : bool \ud83d\udd17 Methods \ud83d\udd17 compare ( self , other : Union [ ProtoModel , pydantic . main . BaseModel ], ** kwargs ) -> bool inherited \ud83d\udd17 Compares the current object to the provided object recursively. Parameters \ud83d\udd17 other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive . Returns \ud83d\udd17 bool True if the objects match. Source code in qcelemental/models/procedures.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : r \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs ) dict ( self , ** kwargs ) -> Dict [ str , Any ] inherited \ud83d\udd17 Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/procedures.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" ) json ( self , ** kwargs ) inherited \ud83d\udd17 Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/procedures.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs ) serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None ) -> Union [ bytes , str ] inherited \ud83d\udd17 Generates a serialized representation of the model Parameters \ud83d\udd17 encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None . Returns \ud83d\udd17 Union[bytes, str] The serialized model. Source code in qcelemental/models/procedures.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: r \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Optimization Input"},{"location":"code_reference/OptimizationInput/#optimization-input","text":"","title":"Optimization Input"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput--parameters","text":"id : str, Optional hash_index : str, Optional schema_name : ConstrainedStrValue, Default: qcschema_optimization_input schema_version : int, Default: 1 keywords : Dict[Any], Default: {} The optimization specific keywords to be used. extras : Dict[Any], Default: {} Extra fields that are not part of the schema. protocols : :class: OptimizationProtocols , Optional Protocols regarding the manipulation of a Optimization output data. Parameters ---------- trajectory : {all,initial_and_final,final,none}, Default: all Which gradient evaluations to keep in an optimization trajectory. input_specification : :class: QCInputSpecification A compute description for energy, gradient, and Hessian computations used in a geometry optimization. Parameters ---------- schema_name : ConstrainedStrValue, Default: qcschema_input schema_version : int, Default: 1 driver : {energy,gradient,hessian,properties}, Default: gradient Allowed computation driver values. model : :class:`Model` The computational molecular sciences model to run. Parameters ---------- method : str The quantum chemistry method to evaluate (e.g., B3LYP, PBE, ...). For MM, name of the force field. basis : Union[str, :class:`BasisSet`], Optional The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...). Can be ``None`` for methods without basis sets. For molecular mechanics, name of the atom-typer. keywords : Dict[Any], Default: {} The program specific keywords to be used. extras : Dict[Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. initial_molecule : :class: Molecule The starting molecule for the geometry optimization. provenance : :class: Provenance , Optional Provenance information. Parameters ---------- creator : str The name of the program, library, or person who created the object. version : str, Default: The version of the creator, blank otherwise. This should be sortable by the very broad [PEP 440](https://www.python.org/dev/peps/pep-0440/). routine : str, Default: The name of the routine or function within the creator, blank otherwise. Source code in qcelemental/models/procedures.py class OptimizationInput ( ProtoModel ): id : Optional [ str ] = None hash_index : Optional [ str ] = None schema_name : constr ( # type: ignore strip_whitespace = True , regex = qcschema_optimization_input_default ) = qcschema_optimization_input_default schema_version : int = 1 keywords : Dict [ str , Any ] = Field ({}, description = \"The optimization specific keywords to be used.\" ) extras : Dict [ str , Any ] = Field ({}, description = \"Extra fields that are not part of the schema.\" ) protocols : OptimizationProtocols = Field ( OptimizationProtocols (), description = str ( OptimizationProtocols . __doc__ )) input_specification : QCInputSpecification = Field ( ... , description = str ( QCInputSpecification . __doc__ )) initial_molecule : Molecule = Field ( ... , description = \"The starting molecule for the geometry optimization.\" ) provenance : Provenance = Field ( Provenance ( ** provenance_stamp ( __name__ )), description = str ( Provenance . __doc__ )) def __repr_args__ ( self ) -> \"ReprArgs\" : return [ ( \"model\" , self . input_specification . model . dict ()), ( \"molecule_hash\" , self . initial_molecule . get_hash ()[: 7 ]), ]","title":"Parameters"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput-attributes","text":"","title":"Attributes"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.extras","text":"Extra fields that are not part of the schema.","title":"extras"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.hash_index","text":"","title":"hash_index"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.id","text":"","title":"id"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.initial_molecule","text":"The starting molecule for the geometry optimization.","title":"initial_molecule"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.input_specification","text":"A compute description for energy, gradient, and Hessian computations used in a geometry optimization.","title":"input_specification"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.input_specification--parameters","text":"schema_name : ConstrainedStrValue, Default: qcschema_input schema_version : int, Default: 1 driver : {energy,gradient,hessian,properties}, Default: gradient Allowed computation driver values. model : :class: Model The computational molecular sciences model to run. Parameters ---------- method : str The quantum chemistry method to evaluate (e.g., B3LYP, PBE, ...). For MM, name of the force field. basis : Union[str, :class:`BasisSet`], Optional The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...). Can be ``None`` for methods without basis sets. For molecular mechanics, name of the atom-typer. keywords : Dict[Any], Default: {} The program specific keywords to be used. extras : Dict[Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space.","title":"Parameters"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.keywords","text":"The optimization specific keywords to be used.","title":"keywords"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.protocols","text":"Protocols regarding the manipulation of a Optimization output data.","title":"protocols"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.protocols--parameters","text":"trajectory : {all,initial_and_final,final,none}, Default: all Which gradient evaluations to keep in an optimization trajectory.","title":"Parameters"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.provenance","text":"Provenance information.","title":"provenance"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.provenance--parameters","text":"creator : str The name of the program, library, or person who created the object. version : str, Default: The version of the creator, blank otherwise. This should be sortable by the very broad PEP 440 . routine : str, Default: The name of the routine or function within the creator, blank otherwise.","title":"Parameters"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.schema_name","text":"","title":"schema_name"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.schema_version","text":"","title":"schema_version"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.Config","text":"Source code in qcelemental/models/procedures.py class Config : allow_mutation : bool = False extra : str = \"forbid\" json_encoders : Dict [ str , Any ] = { np . ndarray : lambda v : v . flatten () . tolist ()} serialize_default_excludes : Set = set () serialize_skip_defaults : bool = False force_skip_defaults : bool = False","title":"Config"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.Config.allow_mutation","text":"","title":"allow_mutation"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.Config.extra","text":"","title":"extra"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.Config.force_skip_defaults","text":"","title":"force_skip_defaults"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.Config.json_encoders","text":"","title":"json_encoders"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.Config.serialize_default_excludes","text":"","title":"serialize_default_excludes"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.Config.serialize_skip_defaults","text":"","title":"serialize_skip_defaults"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput-methods","text":"","title":"Methods"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.compare","text":"Compares the current object to the provided object recursively.","title":"compare()"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.compare--parameters","text":"other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive .","title":"Parameters"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.compare--returns","text":"bool True if the objects match. Source code in qcelemental/models/procedures.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : r \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs )","title":"Returns"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.dict","text":"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/procedures.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" )","title":"dict()"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.json","text":"Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/procedures.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs )","title":"json()"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.serialize","text":"Generates a serialized representation of the model","title":"serialize()"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.serialize--parameters","text":"encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None .","title":"Parameters"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.serialize--returns","text":"Union[bytes, str] The serialized model. Source code in qcelemental/models/procedures.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: r \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Returns"},{"location":"code_reference/OptimizationResult/","text":"Optimization Result \ud83d\udd17 Parameters \ud83d\udd17 id : str, Optional hash_index : str, Optional schema_name : ConstrainedStrValue, Default: qcschema_optimization_output schema_version : int, Default: 1 keywords : Dict[Any], Default: {} The optimization specific keywords to be used. extras : Dict[Any], Default: {} Extra fields that are not part of the schema. protocols : :class: OptimizationProtocols , Optional Protocols regarding the manipulation of a Optimization output data. Parameters ---------- trajectory : {all,initial_and_final,final,none}, Default: all Which gradient evaluations to keep in an optimization trajectory. input_specification : :class: QCInputSpecification A compute description for energy, gradient, and Hessian computations used in a geometry optimization. Parameters ---------- schema_name : ConstrainedStrValue, Default: qcschema_input schema_version : int, Default: 1 driver : {energy,gradient,hessian,properties}, Default: gradient Allowed computation driver values. model : :class:`Model` The computational molecular sciences model to run. Parameters ---------- method : str The quantum chemistry method to evaluate (e.g., B3LYP, PBE, ...). For MM, name of the force field. basis : Union[str, :class:`BasisSet`], Optional The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...). Can be ``None`` for methods without basis sets. For molecular mechanics, name of the atom-typer. keywords : Dict[Any], Default: {} The program specific keywords to be used. extras : Dict[Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. initial_molecule : :class: Molecule The starting molecule for the geometry optimization. provenance : :class: Provenance Provenance information. Parameters ---------- creator : str The name of the program, library, or person who created the object. version : str, Default: The version of the creator, blank otherwise. This should be sortable by the very broad [PEP 440](https://www.python.org/dev/peps/pep-0440/). routine : str, Default: The name of the routine or function within the creator, blank otherwise. final_molecule : :class: Molecule The final molecule of the geometry optimization. trajectory : :class: AtomicResult A list of ordered Result objects for each step in the optimization. energies : List[float] A list of ordered energies for each step in the optimization. stdout : str, Optional The standard output of the program. stderr : str, Optional The standard error of the program. success : bool The success of a given programs execution. If False, other fields may be blank. error : :class: ComputeError , Optional Complete description of the error from an unsuccessful program execution. Parameters ---------- error_type : str The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py error_message : str Text associated with the thrown error. This is often the backtrace, but it can contain additional information as well. extras : Dict[Any], Optional Additional information to bundle with the error. Source code in qcelemental/models/procedures.py class OptimizationResult ( OptimizationInput ): schema_name : constr ( # type: ignore strip_whitespace = True , regex = qcschema_optimization_output_default ) = qcschema_optimization_output_default final_molecule : Optional [ Molecule ] = Field ( ... , description = \"The final molecule of the geometry optimization.\" ) trajectory : List [ AtomicResult ] = Field ( ... , description = \"A list of ordered Result objects for each step in the optimization.\" ) energies : List [ float ] = Field ( ... , description = \"A list of ordered energies for each step in the optimization.\" ) stdout : Optional [ str ] = Field ( None , description = \"The standard output of the program.\" ) stderr : Optional [ str ] = Field ( None , description = \"The standard error of the program.\" ) success : bool = Field ( ... , description = \"The success of a given programs execution. If False, other fields may be blank.\" ) error : Optional [ ComputeError ] = Field ( None , description = str ( ComputeError . __doc__ )) provenance : Provenance = Field ( ... , description = str ( Provenance . __doc__ )) @validator ( \"trajectory\" , each_item = False ) def _trajectory_protocol ( cls , v , values ): # Do not propogate validation errors if \"protocols\" not in values : raise ValueError ( \"Protocols was not properly formed.\" ) keep_enum = values [ \"protocols\" ] . trajectory if keep_enum == \"all\" : pass elif keep_enum == \"initial_and_final\" : if len ( v ) != 2 : v = [ v [ 0 ], v [ - 1 ]] elif keep_enum == \"final\" : if len ( v ) != 1 : v = [ v [ - 1 ]] elif keep_enum == \"none\" : v = [] else : raise ValueError ( f \"Protocol `trajectory: { keep_enum } ` is not understood.\" ) return v Attributes \ud83d\udd17 energies : List [ float ] pydantic-field required \ud83d\udd17 A list of ordered energies for each step in the optimization. error : ComputeError pydantic-field \ud83d\udd17 Complete description of the error from an unsuccessful program execution. Parameters \ud83d\udd17 error_type : str The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py error_message : str Text associated with the thrown error. This is often the backtrace, but it can contain additional information as well. extras : Dict[Any], Optional Additional information to bundle with the error. extras : Dict [ str , Any ] pydantic-field \ud83d\udd17 Extra fields that are not part of the schema. final_molecule : Molecule pydantic-field required \ud83d\udd17 The final molecule of the geometry optimization. hash_index : str pydantic-field \ud83d\udd17 id : str pydantic-field \ud83d\udd17 initial_molecule : Molecule pydantic-field required \ud83d\udd17 The starting molecule for the geometry optimization. input_specification : QCInputSpecification pydantic-field required \ud83d\udd17 A compute description for energy, gradient, and Hessian computations used in a geometry optimization. Parameters \ud83d\udd17 schema_name : ConstrainedStrValue, Default: qcschema_input schema_version : int, Default: 1 driver : {energy,gradient,hessian,properties}, Default: gradient Allowed computation driver values. model : :class: Model The computational molecular sciences model to run. Parameters ---------- method : str The quantum chemistry method to evaluate (e.g., B3LYP, PBE, ...). For MM, name of the force field. basis : Union[str, :class:`BasisSet`], Optional The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...). Can be ``None`` for methods without basis sets. For molecular mechanics, name of the atom-typer. keywords : Dict[Any], Default: {} The program specific keywords to be used. extras : Dict[Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. keywords : Dict [ str , Any ] pydantic-field \ud83d\udd17 The optimization specific keywords to be used. protocols : OptimizationProtocols pydantic-field \ud83d\udd17 Protocols regarding the manipulation of a Optimization output data. Parameters \ud83d\udd17 trajectory : {all,initial_and_final,final,none}, Default: all Which gradient evaluations to keep in an optimization trajectory. provenance : Provenance pydantic-field required \ud83d\udd17 Provenance information. Parameters \ud83d\udd17 creator : str The name of the program, library, or person who created the object. version : str, Default: The version of the creator, blank otherwise. This should be sortable by the very broad PEP 440 . routine : str, Default: The name of the routine or function within the creator, blank otherwise. schema_name : ConstrainedStrValue pydantic-field \ud83d\udd17 schema_version : int pydantic-field \ud83d\udd17 stderr : str pydantic-field \ud83d\udd17 The standard error of the program. stdout : str pydantic-field \ud83d\udd17 The standard output of the program. success : bool pydantic-field required \ud83d\udd17 The success of a given programs execution. If False, other fields may be blank. trajectory : List [ qcelemental . models . results . AtomicResult ] pydantic-field required \ud83d\udd17 A list of ordered Result objects for each step in the optimization. Config inherited \ud83d\udd17 Source code in qcelemental/models/procedures.py class Config : allow_mutation : bool = False extra : str = \"forbid\" json_encoders : Dict [ str , Any ] = { np . ndarray : lambda v : v . flatten () . tolist ()} serialize_default_excludes : Set = set () serialize_skip_defaults : bool = False force_skip_defaults : bool = False allow_mutation : bool \ud83d\udd17 extra : str \ud83d\udd17 force_skip_defaults : bool \ud83d\udd17 json_encoders : Dict [ str , Any ] \ud83d\udd17 serialize_default_excludes : Set \ud83d\udd17 serialize_skip_defaults : bool \ud83d\udd17 Methods \ud83d\udd17 compare ( self , other : Union [ ProtoModel , pydantic . main . BaseModel ], ** kwargs ) -> bool inherited \ud83d\udd17 Compares the current object to the provided object recursively. Parameters \ud83d\udd17 other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive . Returns \ud83d\udd17 bool True if the objects match. Source code in qcelemental/models/procedures.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : r \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs ) dict ( self , ** kwargs ) -> Dict [ str , Any ] inherited \ud83d\udd17 Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/procedures.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" ) json ( self , ** kwargs ) inherited \ud83d\udd17 Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/procedures.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs ) serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None ) -> Union [ bytes , str ] inherited \ud83d\udd17 Generates a serialized representation of the model Parameters \ud83d\udd17 encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None . Returns \ud83d\udd17 Union[bytes, str] The serialized model. Source code in qcelemental/models/procedures.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: r \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Optimization Result"},{"location":"code_reference/OptimizationResult/#optimization-result","text":"","title":"Optimization Result"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult--parameters","text":"id : str, Optional hash_index : str, Optional schema_name : ConstrainedStrValue, Default: qcschema_optimization_output schema_version : int, Default: 1 keywords : Dict[Any], Default: {} The optimization specific keywords to be used. extras : Dict[Any], Default: {} Extra fields that are not part of the schema. protocols : :class: OptimizationProtocols , Optional Protocols regarding the manipulation of a Optimization output data. Parameters ---------- trajectory : {all,initial_and_final,final,none}, Default: all Which gradient evaluations to keep in an optimization trajectory. input_specification : :class: QCInputSpecification A compute description for energy, gradient, and Hessian computations used in a geometry optimization. Parameters ---------- schema_name : ConstrainedStrValue, Default: qcschema_input schema_version : int, Default: 1 driver : {energy,gradient,hessian,properties}, Default: gradient Allowed computation driver values. model : :class:`Model` The computational molecular sciences model to run. Parameters ---------- method : str The quantum chemistry method to evaluate (e.g., B3LYP, PBE, ...). For MM, name of the force field. basis : Union[str, :class:`BasisSet`], Optional The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...). Can be ``None`` for methods without basis sets. For molecular mechanics, name of the atom-typer. keywords : Dict[Any], Default: {} The program specific keywords to be used. extras : Dict[Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. initial_molecule : :class: Molecule The starting molecule for the geometry optimization. provenance : :class: Provenance Provenance information. Parameters ---------- creator : str The name of the program, library, or person who created the object. version : str, Default: The version of the creator, blank otherwise. This should be sortable by the very broad [PEP 440](https://www.python.org/dev/peps/pep-0440/). routine : str, Default: The name of the routine or function within the creator, blank otherwise. final_molecule : :class: Molecule The final molecule of the geometry optimization. trajectory : :class: AtomicResult A list of ordered Result objects for each step in the optimization. energies : List[float] A list of ordered energies for each step in the optimization. stdout : str, Optional The standard output of the program. stderr : str, Optional The standard error of the program. success : bool The success of a given programs execution. If False, other fields may be blank. error : :class: ComputeError , Optional Complete description of the error from an unsuccessful program execution. Parameters ---------- error_type : str The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py error_message : str Text associated with the thrown error. This is often the backtrace, but it can contain additional information as well. extras : Dict[Any], Optional Additional information to bundle with the error. Source code in qcelemental/models/procedures.py class OptimizationResult ( OptimizationInput ): schema_name : constr ( # type: ignore strip_whitespace = True , regex = qcschema_optimization_output_default ) = qcschema_optimization_output_default final_molecule : Optional [ Molecule ] = Field ( ... , description = \"The final molecule of the geometry optimization.\" ) trajectory : List [ AtomicResult ] = Field ( ... , description = \"A list of ordered Result objects for each step in the optimization.\" ) energies : List [ float ] = Field ( ... , description = \"A list of ordered energies for each step in the optimization.\" ) stdout : Optional [ str ] = Field ( None , description = \"The standard output of the program.\" ) stderr : Optional [ str ] = Field ( None , description = \"The standard error of the program.\" ) success : bool = Field ( ... , description = \"The success of a given programs execution. If False, other fields may be blank.\" ) error : Optional [ ComputeError ] = Field ( None , description = str ( ComputeError . __doc__ )) provenance : Provenance = Field ( ... , description = str ( Provenance . __doc__ )) @validator ( \"trajectory\" , each_item = False ) def _trajectory_protocol ( cls , v , values ): # Do not propogate validation errors if \"protocols\" not in values : raise ValueError ( \"Protocols was not properly formed.\" ) keep_enum = values [ \"protocols\" ] . trajectory if keep_enum == \"all\" : pass elif keep_enum == \"initial_and_final\" : if len ( v ) != 2 : v = [ v [ 0 ], v [ - 1 ]] elif keep_enum == \"final\" : if len ( v ) != 1 : v = [ v [ - 1 ]] elif keep_enum == \"none\" : v = [] else : raise ValueError ( f \"Protocol `trajectory: { keep_enum } ` is not understood.\" ) return v","title":"Parameters"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult-attributes","text":"","title":"Attributes"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.energies","text":"A list of ordered energies for each step in the optimization.","title":"energies"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.error","text":"Complete description of the error from an unsuccessful program execution.","title":"error"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.error--parameters","text":"error_type : str The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py error_message : str Text associated with the thrown error. This is often the backtrace, but it can contain additional information as well. extras : Dict[Any], Optional Additional information to bundle with the error.","title":"Parameters"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.extras","text":"Extra fields that are not part of the schema.","title":"extras"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.final_molecule","text":"The final molecule of the geometry optimization.","title":"final_molecule"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.hash_index","text":"","title":"hash_index"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.id","text":"","title":"id"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.initial_molecule","text":"The starting molecule for the geometry optimization.","title":"initial_molecule"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.input_specification","text":"A compute description for energy, gradient, and Hessian computations used in a geometry optimization.","title":"input_specification"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.input_specification--parameters","text":"schema_name : ConstrainedStrValue, Default: qcschema_input schema_version : int, Default: 1 driver : {energy,gradient,hessian,properties}, Default: gradient Allowed computation driver values. model : :class: Model The computational molecular sciences model to run. Parameters ---------- method : str The quantum chemistry method to evaluate (e.g., B3LYP, PBE, ...). For MM, name of the force field. basis : Union[str, :class:`BasisSet`], Optional The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...). Can be ``None`` for methods without basis sets. For molecular mechanics, name of the atom-typer. keywords : Dict[Any], Default: {} The program specific keywords to be used. extras : Dict[Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space.","title":"Parameters"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.keywords","text":"The optimization specific keywords to be used.","title":"keywords"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.protocols","text":"Protocols regarding the manipulation of a Optimization output data.","title":"protocols"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.protocols--parameters","text":"trajectory : {all,initial_and_final,final,none}, Default: all Which gradient evaluations to keep in an optimization trajectory.","title":"Parameters"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.provenance","text":"Provenance information.","title":"provenance"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.provenance--parameters","text":"creator : str The name of the program, library, or person who created the object. version : str, Default: The version of the creator, blank otherwise. This should be sortable by the very broad PEP 440 . routine : str, Default: The name of the routine or function within the creator, blank otherwise.","title":"Parameters"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.schema_name","text":"","title":"schema_name"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.schema_version","text":"","title":"schema_version"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.stderr","text":"The standard error of the program.","title":"stderr"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.stdout","text":"The standard output of the program.","title":"stdout"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.success","text":"The success of a given programs execution. If False, other fields may be blank.","title":"success"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.trajectory","text":"A list of ordered Result objects for each step in the optimization.","title":"trajectory"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.Config","text":"Source code in qcelemental/models/procedures.py class Config : allow_mutation : bool = False extra : str = \"forbid\" json_encoders : Dict [ str , Any ] = { np . ndarray : lambda v : v . flatten () . tolist ()} serialize_default_excludes : Set = set () serialize_skip_defaults : bool = False force_skip_defaults : bool = False","title":"Config"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.Config.allow_mutation","text":"","title":"allow_mutation"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.Config.extra","text":"","title":"extra"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.Config.force_skip_defaults","text":"","title":"force_skip_defaults"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.Config.json_encoders","text":"","title":"json_encoders"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.Config.serialize_default_excludes","text":"","title":"serialize_default_excludes"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.Config.serialize_skip_defaults","text":"","title":"serialize_skip_defaults"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult-methods","text":"","title":"Methods"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.compare","text":"Compares the current object to the provided object recursively.","title":"compare()"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.compare--parameters","text":"other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive .","title":"Parameters"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.compare--returns","text":"bool True if the objects match. Source code in qcelemental/models/procedures.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : r \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs )","title":"Returns"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.dict","text":"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/procedures.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" )","title":"dict()"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.json","text":"Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/procedures.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs )","title":"json()"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.serialize","text":"Generates a serialized representation of the model","title":"serialize()"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.serialize--parameters","text":"encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None .","title":"Parameters"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.serialize--returns","text":"Union[bytes, str] The serialized model. Source code in qcelemental/models/procedures.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: r \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Returns"},{"location":"code_reference/TCClient/","text":"TCClient \ud83d\udd17 Main client object to perform computations using TeraChem Cloud. Source code in tccloud/client.py class TCClient : \"\"\"Main client object to perform computations using TeraChem Cloud.\"\"\" def __init__ ( self , * , tccloud_username : Optional [ str ] = None , tccloud_password : Optional [ str ] = None , profile : Optional [ str ] = None , tccloud_domain : Optional [ str ] = None , ): \"\"\" Initialize a TCClient object. Parameters: tccloud_username: TeraChem Cloud username tccloud_password: TeraChem Cloud password profile: Authentication profile name tccloud_domain: Domain of TeraChem Cloud instance to connect to !!! Danger It is not recommended to pass your TeraChem Cloud username and password directly to a `TCClient`. Instead instantiate a client with no credentials `client = TCClient()` and then run `client.configure()` to securely set up your authentication credentials for TeraChem Cloud. \"\"\" self . _client = _RequestsClient ( tccloud_username = tccloud_username , tccloud_password = tccloud_password , profile = profile , tccloud_domain = tccloud_domain , ) self . _openapi_spec : Optional [ Dict ] = None def __repr__ ( self ) -> str : return f \" { type ( self ) . __name__ } ( { self . _client . _tccloud_domain } , profile= { self . profile } )\" def _set_openapi_specification ( self ): \"\"\"Gets OpenAPI specification from TeraChem Cloud Server\"\"\" self . _openapi_spec = self . _client . _request ( \"get\" , \"/openapi.json\" , api_call = False ) @property def version ( self ) -> str : \"\"\"Return tccloud version\"\"\" return __version__ @property def profile ( self ) -> str : \"\"\"Profile being used for authentication with TeraChem Cloud. Returns: The name of the name of the credentials profile being used with the current client. NOTE: This is a note! \"\"\" return self . _client . _profile @property def supported_engines ( self ) -> List [ str ]: \"\"\"Compute engines currently supported by TeraChem Cloud. Returns: List of engines currently supported by TeraChem Cloud.\"\"\" if not self . _openapi_spec : self . _set_openapi_specification () try : assert self . _openapi_spec is not None engines = self . _openapi_spec [ \"components\" ][ \"schemas\" ][ \"SupportedEngines\" ][ \"enum\" ] except IndexError : print ( \"Cannot locate currently supported engines.\" ) engines = [ \"\" ] return engines @property def supported_procedures ( self ) -> List [ str ]: \"\"\"Compute procedures currently supported by TeraChem Cloud. Returns: List of procedures currently supported by TeraChem Cloud.\"\"\" if not self . _openapi_spec : self . _set_openapi_specification () try : assert self . _openapi_spec is not None procedures = self . _openapi_spec [ \"components\" ][ \"schemas\" ][ \"SupportedProcedures\" ][ \"enum\" ] except IndexError : print ( \"Cannot locate currently supported procedures.\" ) procedures = [ \"\" ] return procedures def hello_world ( self , name : Optional [ str ] = None ) -> str : \"\"\"A simple endpoint to check connectivity to TeraChem Cloud. Parameters: name: Your name Returns: A message from TeraChem Cloud if the client was able to successfully connect. \"\"\" return self . _client . hello_world ( name ) def compute ( self , input_data : AtomicInputOrList , engine : str , queue : Optional [ str ] = None ) -> Union [ FutureResult , FutureResultGroup ]: \"\"\"Submit a computation to TeraChem Cloud. Parameters: input_data: Defines the structure of the desired computation. engine: A string matching one of the `self.supported_engines` queue: The name of a private compute queue. If None, default queue is used Returns: Object providing access to a computation's eventual result. You can check a computation's status by runing `.status` on the `FutureResult` object or `.get()` to block and retrieve the computation's final result. \"\"\" if self . supported_engines is not None : assert ( engine in self . supported_engines ), f \"Please use one of the following engines: { self . supported_engines } \" return self . _client . compute ( input_data , engine , queue ) def compute_procedure ( self , input_data : OptimizationInputOrList , procedure : str , queue : Optional [ str ] = None , ) -> Union [ FutureResult , FutureResultGroup ]: \"\"\"Submit a procedure computation to TeraChem Cloud Parameters: input_data: Defines the inputs for an optimization computation procedure: The name of the procedure, e.g., 'berny' queue: The name of a private compute queue. If None, default queue is used Returns: Object providing access to a computation's eventual result. You can check a computation's status by runing `.status` on the `FutureResult` object or `.get()` to block and retrieve the computation's final result. \"\"\" if self . supported_procedures is not None : assert ( procedure in self . supported_procedures ), f \"Please use one of the following procedures: { self . supported_procedures } \" return self . _client . compute_procedure ( input_data , procedure , queue ) def configure ( self , profile : str = settings . tccloud_default_credentials_profile ) -> None : \"\"\"Configure profiles for authentication with TeraChem Cloud. Parameters: profile: Optional value to create a named profile for use with TeraChem Cloud. No value needs to be passed and most users will only have one login with TeraChem Cloud. TCClient will access the profile by default without a specific name being passed. Pass a value if you have multiple logins to TeraChem Cloud. Note: Configures `tccloud` to use the passed credentials automatically in the future. You will not need to run `.configure()` the next time you use the `tccloud`. \"\"\" print ( f \"\u2705 If you don't get have an account please signup at: { settings . tccloud_domain } /signup\" ) access_token , refresh_token = self . _client . _set_tokens_from_user_input () self . _client . write_tokens_to_credentials_file ( access_token , refresh_token , profile = profile ) print ( f \"' { profile } ' profile configured! Username/password not required for future use of TCClient\" ) Attributes \ud83d\udd17 profile : str property readonly \ud83d\udd17 Profile being used for authentication with TeraChem Cloud. Returns: Type Description str The name of the name of the credentials profile being used with the current client. NOTE: This is a note! supported_engines : List [ str ] property readonly \ud83d\udd17 Compute engines currently supported by TeraChem Cloud. Returns: Type Description List[str] List of engines currently supported by TeraChem Cloud. supported_procedures : List [ str ] property readonly \ud83d\udd17 Compute procedures currently supported by TeraChem Cloud. Returns: Type Description List[str] List of procedures currently supported by TeraChem Cloud. version : str property readonly \ud83d\udd17 Return tccloud version Methods \ud83d\udd17 __init__ ( self , * , tccloud_username : Optional [ str ] = None , tccloud_password : Optional [ str ] = None , profile : Optional [ str ] = None , tccloud_domain : Optional [ str ] = None ) special \ud83d\udd17 Initialize a TCClient object. Parameters: Name Type Description Default tccloud_username Optional[str] TeraChem Cloud username None tccloud_password Optional[str] TeraChem Cloud password None profile Optional[str] Authentication profile name None tccloud_domain Optional[str] Domain of TeraChem Cloud instance to connect to None Danger It is not recommended to pass your TeraChem Cloud username and password directly to a TCClient . Instead instantiate a client with no credentials client = TCClient() and then run client.configure() to securely set up your authentication credentials for TeraChem Cloud. Source code in tccloud/client.py def __init__ ( self , * , tccloud_username : Optional [ str ] = None , tccloud_password : Optional [ str ] = None , profile : Optional [ str ] = None , tccloud_domain : Optional [ str ] = None , ): \"\"\" Initialize a TCClient object. Parameters: tccloud_username: TeraChem Cloud username tccloud_password: TeraChem Cloud password profile: Authentication profile name tccloud_domain: Domain of TeraChem Cloud instance to connect to !!! Danger It is not recommended to pass your TeraChem Cloud username and password directly to a `TCClient`. Instead instantiate a client with no credentials `client = TCClient()` and then run `client.configure()` to securely set up your authentication credentials for TeraChem Cloud. \"\"\" self . _client = _RequestsClient ( tccloud_username = tccloud_username , tccloud_password = tccloud_password , profile = profile , tccloud_domain = tccloud_domain , ) self . _openapi_spec : Optional [ Dict ] = None compute ( self , input_data : Union [ qcelemental . models . results . AtomicInput , List [ qcelemental . models . results . AtomicInput ]], engine : str , queue : Optional [ str ] = None ) -> Union [ tccloud . models . FutureResult , tccloud . models . FutureResultGroup ] \ud83d\udd17 Submit a computation to TeraChem Cloud. Parameters: Name Type Description Default input_data Union[qcelemental.models.results.AtomicInput, List[qcelemental.models.results.AtomicInput]] Defines the structure of the desired computation. required engine str A string matching one of the self.supported_engines required queue Optional[str] The name of a private compute queue. If None, default queue is used None Returns: Type Description Union[tccloud.models.FutureResult, tccloud.models.FutureResultGroup] Object providing access to a computation's eventual result. You can check a computation's status by runing .status on the FutureResult object or .get() to block and retrieve the computation's final result. Source code in tccloud/client.py def compute ( self , input_data : AtomicInputOrList , engine : str , queue : Optional [ str ] = None ) -> Union [ FutureResult , FutureResultGroup ]: \"\"\"Submit a computation to TeraChem Cloud. Parameters: input_data: Defines the structure of the desired computation. engine: A string matching one of the `self.supported_engines` queue: The name of a private compute queue. If None, default queue is used Returns: Object providing access to a computation's eventual result. You can check a computation's status by runing `.status` on the `FutureResult` object or `.get()` to block and retrieve the computation's final result. \"\"\" if self . supported_engines is not None : assert ( engine in self . supported_engines ), f \"Please use one of the following engines: { self . supported_engines } \" return self . _client . compute ( input_data , engine , queue ) compute_procedure ( self , input_data : Union [ qcelemental . models . procedures . OptimizationInput , List [ qcelemental . models . procedures . OptimizationInput ]], procedure : str , queue : Optional [ str ] = None ) -> Union [ tccloud . models . FutureResult , tccloud . models . FutureResultGroup ] \ud83d\udd17 Submit a procedure computation to TeraChem Cloud Parameters: Name Type Description Default input_data Union[qcelemental.models.procedures.OptimizationInput, List[qcelemental.models.procedures.OptimizationInput]] Defines the inputs for an optimization computation required procedure str The name of the procedure, e.g., 'berny' required queue Optional[str] The name of a private compute queue. If None, default queue is used None Returns: Type Description Union[tccloud.models.FutureResult, tccloud.models.FutureResultGroup] Object providing access to a computation's eventual result. You can check a computation's status by runing .status on the FutureResult object or .get() to block and retrieve the computation's final result. Source code in tccloud/client.py def compute_procedure ( self , input_data : OptimizationInputOrList , procedure : str , queue : Optional [ str ] = None , ) -> Union [ FutureResult , FutureResultGroup ]: \"\"\"Submit a procedure computation to TeraChem Cloud Parameters: input_data: Defines the inputs for an optimization computation procedure: The name of the procedure, e.g., 'berny' queue: The name of a private compute queue. If None, default queue is used Returns: Object providing access to a computation's eventual result. You can check a computation's status by runing `.status` on the `FutureResult` object or `.get()` to block and retrieve the computation's final result. \"\"\" if self . supported_procedures is not None : assert ( procedure in self . supported_procedures ), f \"Please use one of the following procedures: { self . supported_procedures } \" return self . _client . compute_procedure ( input_data , procedure , queue ) configure ( self , profile : str = 'default' ) -> None \ud83d\udd17 Configure profiles for authentication with TeraChem Cloud. Parameters: Name Type Description Default profile str Optional value to create a named profile for use with TeraChem Cloud. No value needs to be passed and most users will only have one login with TeraChem Cloud. TCClient will access the profile by default without a specific name being passed. Pass a value if you have multiple logins to TeraChem Cloud. 'default' Note Configures tccloud to use the passed credentials automatically in the future. You will not need to run .configure() the next time you use the tccloud . Source code in tccloud/client.py def configure ( self , profile : str = settings . tccloud_default_credentials_profile ) -> None : \"\"\"Configure profiles for authentication with TeraChem Cloud. Parameters: profile: Optional value to create a named profile for use with TeraChem Cloud. No value needs to be passed and most users will only have one login with TeraChem Cloud. TCClient will access the profile by default without a specific name being passed. Pass a value if you have multiple logins to TeraChem Cloud. Note: Configures `tccloud` to use the passed credentials automatically in the future. You will not need to run `.configure()` the next time you use the `tccloud`. \"\"\" print ( f \"\u2705 If you don't get have an account please signup at: { settings . tccloud_domain } /signup\" ) access_token , refresh_token = self . _client . _set_tokens_from_user_input () self . _client . write_tokens_to_credentials_file ( access_token , refresh_token , profile = profile ) print ( f \"' { profile } ' profile configured! Username/password not required for future use of TCClient\" ) hello_world ( self , name : Optional [ str ] = None ) -> str \ud83d\udd17 A simple endpoint to check connectivity to TeraChem Cloud. Parameters: Name Type Description Default name Optional[str] Your name None Returns: Type Description str A message from TeraChem Cloud if the client was able to successfully connect. Source code in tccloud/client.py def hello_world ( self , name : Optional [ str ] = None ) -> str : \"\"\"A simple endpoint to check connectivity to TeraChem Cloud. Parameters: name: Your name Returns: A message from TeraChem Cloud if the client was able to successfully connect. \"\"\" return self . _client . hello_world ( name )","title":"TCClient"},{"location":"code_reference/TCClient/#tcclient","text":"Main client object to perform computations using TeraChem Cloud. Source code in tccloud/client.py class TCClient : \"\"\"Main client object to perform computations using TeraChem Cloud.\"\"\" def __init__ ( self , * , tccloud_username : Optional [ str ] = None , tccloud_password : Optional [ str ] = None , profile : Optional [ str ] = None , tccloud_domain : Optional [ str ] = None , ): \"\"\" Initialize a TCClient object. Parameters: tccloud_username: TeraChem Cloud username tccloud_password: TeraChem Cloud password profile: Authentication profile name tccloud_domain: Domain of TeraChem Cloud instance to connect to !!! Danger It is not recommended to pass your TeraChem Cloud username and password directly to a `TCClient`. Instead instantiate a client with no credentials `client = TCClient()` and then run `client.configure()` to securely set up your authentication credentials for TeraChem Cloud. \"\"\" self . _client = _RequestsClient ( tccloud_username = tccloud_username , tccloud_password = tccloud_password , profile = profile , tccloud_domain = tccloud_domain , ) self . _openapi_spec : Optional [ Dict ] = None def __repr__ ( self ) -> str : return f \" { type ( self ) . __name__ } ( { self . _client . _tccloud_domain } , profile= { self . profile } )\" def _set_openapi_specification ( self ): \"\"\"Gets OpenAPI specification from TeraChem Cloud Server\"\"\" self . _openapi_spec = self . _client . _request ( \"get\" , \"/openapi.json\" , api_call = False ) @property def version ( self ) -> str : \"\"\"Return tccloud version\"\"\" return __version__ @property def profile ( self ) -> str : \"\"\"Profile being used for authentication with TeraChem Cloud. Returns: The name of the name of the credentials profile being used with the current client. NOTE: This is a note! \"\"\" return self . _client . _profile @property def supported_engines ( self ) -> List [ str ]: \"\"\"Compute engines currently supported by TeraChem Cloud. Returns: List of engines currently supported by TeraChem Cloud.\"\"\" if not self . _openapi_spec : self . _set_openapi_specification () try : assert self . _openapi_spec is not None engines = self . _openapi_spec [ \"components\" ][ \"schemas\" ][ \"SupportedEngines\" ][ \"enum\" ] except IndexError : print ( \"Cannot locate currently supported engines.\" ) engines = [ \"\" ] return engines @property def supported_procedures ( self ) -> List [ str ]: \"\"\"Compute procedures currently supported by TeraChem Cloud. Returns: List of procedures currently supported by TeraChem Cloud.\"\"\" if not self . _openapi_spec : self . _set_openapi_specification () try : assert self . _openapi_spec is not None procedures = self . _openapi_spec [ \"components\" ][ \"schemas\" ][ \"SupportedProcedures\" ][ \"enum\" ] except IndexError : print ( \"Cannot locate currently supported procedures.\" ) procedures = [ \"\" ] return procedures def hello_world ( self , name : Optional [ str ] = None ) -> str : \"\"\"A simple endpoint to check connectivity to TeraChem Cloud. Parameters: name: Your name Returns: A message from TeraChem Cloud if the client was able to successfully connect. \"\"\" return self . _client . hello_world ( name ) def compute ( self , input_data : AtomicInputOrList , engine : str , queue : Optional [ str ] = None ) -> Union [ FutureResult , FutureResultGroup ]: \"\"\"Submit a computation to TeraChem Cloud. Parameters: input_data: Defines the structure of the desired computation. engine: A string matching one of the `self.supported_engines` queue: The name of a private compute queue. If None, default queue is used Returns: Object providing access to a computation's eventual result. You can check a computation's status by runing `.status` on the `FutureResult` object or `.get()` to block and retrieve the computation's final result. \"\"\" if self . supported_engines is not None : assert ( engine in self . supported_engines ), f \"Please use one of the following engines: { self . supported_engines } \" return self . _client . compute ( input_data , engine , queue ) def compute_procedure ( self , input_data : OptimizationInputOrList , procedure : str , queue : Optional [ str ] = None , ) -> Union [ FutureResult , FutureResultGroup ]: \"\"\"Submit a procedure computation to TeraChem Cloud Parameters: input_data: Defines the inputs for an optimization computation procedure: The name of the procedure, e.g., 'berny' queue: The name of a private compute queue. If None, default queue is used Returns: Object providing access to a computation's eventual result. You can check a computation's status by runing `.status` on the `FutureResult` object or `.get()` to block and retrieve the computation's final result. \"\"\" if self . supported_procedures is not None : assert ( procedure in self . supported_procedures ), f \"Please use one of the following procedures: { self . supported_procedures } \" return self . _client . compute_procedure ( input_data , procedure , queue ) def configure ( self , profile : str = settings . tccloud_default_credentials_profile ) -> None : \"\"\"Configure profiles for authentication with TeraChem Cloud. Parameters: profile: Optional value to create a named profile for use with TeraChem Cloud. No value needs to be passed and most users will only have one login with TeraChem Cloud. TCClient will access the profile by default without a specific name being passed. Pass a value if you have multiple logins to TeraChem Cloud. Note: Configures `tccloud` to use the passed credentials automatically in the future. You will not need to run `.configure()` the next time you use the `tccloud`. \"\"\" print ( f \"\u2705 If you don't get have an account please signup at: { settings . tccloud_domain } /signup\" ) access_token , refresh_token = self . _client . _set_tokens_from_user_input () self . _client . write_tokens_to_credentials_file ( access_token , refresh_token , profile = profile ) print ( f \"' { profile } ' profile configured! Username/password not required for future use of TCClient\" )","title":"TCClient"},{"location":"code_reference/TCClient/#tccloud.client.TCClient-attributes","text":"","title":"Attributes"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.profile","text":"Profile being used for authentication with TeraChem Cloud. Returns: Type Description str The name of the name of the credentials profile being used with the current client. NOTE: This is a note!","title":"profile"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.supported_engines","text":"Compute engines currently supported by TeraChem Cloud. Returns: Type Description List[str] List of engines currently supported by TeraChem Cloud.","title":"supported_engines"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.supported_procedures","text":"Compute procedures currently supported by TeraChem Cloud. Returns: Type Description List[str] List of procedures currently supported by TeraChem Cloud.","title":"supported_procedures"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.version","text":"Return tccloud version","title":"version"},{"location":"code_reference/TCClient/#tccloud.client.TCClient-methods","text":"","title":"Methods"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.__init__","text":"Initialize a TCClient object. Parameters: Name Type Description Default tccloud_username Optional[str] TeraChem Cloud username None tccloud_password Optional[str] TeraChem Cloud password None profile Optional[str] Authentication profile name None tccloud_domain Optional[str] Domain of TeraChem Cloud instance to connect to None Danger It is not recommended to pass your TeraChem Cloud username and password directly to a TCClient . Instead instantiate a client with no credentials client = TCClient() and then run client.configure() to securely set up your authentication credentials for TeraChem Cloud. Source code in tccloud/client.py def __init__ ( self , * , tccloud_username : Optional [ str ] = None , tccloud_password : Optional [ str ] = None , profile : Optional [ str ] = None , tccloud_domain : Optional [ str ] = None , ): \"\"\" Initialize a TCClient object. Parameters: tccloud_username: TeraChem Cloud username tccloud_password: TeraChem Cloud password profile: Authentication profile name tccloud_domain: Domain of TeraChem Cloud instance to connect to !!! Danger It is not recommended to pass your TeraChem Cloud username and password directly to a `TCClient`. Instead instantiate a client with no credentials `client = TCClient()` and then run `client.configure()` to securely set up your authentication credentials for TeraChem Cloud. \"\"\" self . _client = _RequestsClient ( tccloud_username = tccloud_username , tccloud_password = tccloud_password , profile = profile , tccloud_domain = tccloud_domain , ) self . _openapi_spec : Optional [ Dict ] = None","title":"__init__()"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.compute","text":"Submit a computation to TeraChem Cloud. Parameters: Name Type Description Default input_data Union[qcelemental.models.results.AtomicInput, List[qcelemental.models.results.AtomicInput]] Defines the structure of the desired computation. required engine str A string matching one of the self.supported_engines required queue Optional[str] The name of a private compute queue. If None, default queue is used None Returns: Type Description Union[tccloud.models.FutureResult, tccloud.models.FutureResultGroup] Object providing access to a computation's eventual result. You can check a computation's status by runing .status on the FutureResult object or .get() to block and retrieve the computation's final result. Source code in tccloud/client.py def compute ( self , input_data : AtomicInputOrList , engine : str , queue : Optional [ str ] = None ) -> Union [ FutureResult , FutureResultGroup ]: \"\"\"Submit a computation to TeraChem Cloud. Parameters: input_data: Defines the structure of the desired computation. engine: A string matching one of the `self.supported_engines` queue: The name of a private compute queue. If None, default queue is used Returns: Object providing access to a computation's eventual result. You can check a computation's status by runing `.status` on the `FutureResult` object or `.get()` to block and retrieve the computation's final result. \"\"\" if self . supported_engines is not None : assert ( engine in self . supported_engines ), f \"Please use one of the following engines: { self . supported_engines } \" return self . _client . compute ( input_data , engine , queue )","title":"compute()"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.compute_procedure","text":"Submit a procedure computation to TeraChem Cloud Parameters: Name Type Description Default input_data Union[qcelemental.models.procedures.OptimizationInput, List[qcelemental.models.procedures.OptimizationInput]] Defines the inputs for an optimization computation required procedure str The name of the procedure, e.g., 'berny' required queue Optional[str] The name of a private compute queue. If None, default queue is used None Returns: Type Description Union[tccloud.models.FutureResult, tccloud.models.FutureResultGroup] Object providing access to a computation's eventual result. You can check a computation's status by runing .status on the FutureResult object or .get() to block and retrieve the computation's final result. Source code in tccloud/client.py def compute_procedure ( self , input_data : OptimizationInputOrList , procedure : str , queue : Optional [ str ] = None , ) -> Union [ FutureResult , FutureResultGroup ]: \"\"\"Submit a procedure computation to TeraChem Cloud Parameters: input_data: Defines the inputs for an optimization computation procedure: The name of the procedure, e.g., 'berny' queue: The name of a private compute queue. If None, default queue is used Returns: Object providing access to a computation's eventual result. You can check a computation's status by runing `.status` on the `FutureResult` object or `.get()` to block and retrieve the computation's final result. \"\"\" if self . supported_procedures is not None : assert ( procedure in self . supported_procedures ), f \"Please use one of the following procedures: { self . supported_procedures } \" return self . _client . compute_procedure ( input_data , procedure , queue )","title":"compute_procedure()"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.configure","text":"Configure profiles for authentication with TeraChem Cloud. Parameters: Name Type Description Default profile str Optional value to create a named profile for use with TeraChem Cloud. No value needs to be passed and most users will only have one login with TeraChem Cloud. TCClient will access the profile by default without a specific name being passed. Pass a value if you have multiple logins to TeraChem Cloud. 'default' Note Configures tccloud to use the passed credentials automatically in the future. You will not need to run .configure() the next time you use the tccloud . Source code in tccloud/client.py def configure ( self , profile : str = settings . tccloud_default_credentials_profile ) -> None : \"\"\"Configure profiles for authentication with TeraChem Cloud. Parameters: profile: Optional value to create a named profile for use with TeraChem Cloud. No value needs to be passed and most users will only have one login with TeraChem Cloud. TCClient will access the profile by default without a specific name being passed. Pass a value if you have multiple logins to TeraChem Cloud. Note: Configures `tccloud` to use the passed credentials automatically in the future. You will not need to run `.configure()` the next time you use the `tccloud`. \"\"\" print ( f \"\u2705 If you don't get have an account please signup at: { settings . tccloud_domain } /signup\" ) access_token , refresh_token = self . _client . _set_tokens_from_user_input () self . _client . write_tokens_to_credentials_file ( access_token , refresh_token , profile = profile ) print ( f \"' { profile } ' profile configured! Username/password not required for future use of TCClient\" )","title":"configure()"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.hello_world","text":"A simple endpoint to check connectivity to TeraChem Cloud. Parameters: Name Type Description Default name Optional[str] Your name None Returns: Type Description str A message from TeraChem Cloud if the client was able to successfully connect. Source code in tccloud/client.py def hello_world ( self , name : Optional [ str ] = None ) -> str : \"\"\"A simple endpoint to check connectivity to TeraChem Cloud. Parameters: name: Your name Returns: A message from TeraChem Cloud if the client was able to successfully connect. \"\"\" return self . _client . hello_world ( name )","title":"hello_world()"},{"location":"code_reference/exceptions/","text":"Exceptions \ud83d\udd17 Classes \ud83d\udd17 BaseError ( Exception ) \ud83d\udd17 Exception Base for client. Source code in tccloud/exceptions.py class BaseError ( Exception ): \"\"\"Exception Base for client.\"\"\" TimeoutError ( BaseError ) \ud83d\udd17 A timeout parameter was exceeded Source code in tccloud/exceptions.py class TimeoutError ( BaseError ): \"\"\"A timeout parameter was exceeded\"\"\"","title":"Exceptions"},{"location":"code_reference/exceptions/#exceptions","text":"","title":"Exceptions"},{"location":"code_reference/exceptions/#tccloud.exceptions-classes","text":"","title":"Classes"},{"location":"code_reference/exceptions/#tccloud.exceptions.BaseError","text":"Exception Base for client. Source code in tccloud/exceptions.py class BaseError ( Exception ): \"\"\"Exception Base for client.\"\"\"","title":"BaseError"},{"location":"code_reference/exceptions/#tccloud.exceptions.TimeoutError","text":"A timeout parameter was exceeded Source code in tccloud/exceptions.py class TimeoutError ( BaseError ): \"\"\"A timeout parameter was exceeded\"\"\"","title":"TimeoutError"},{"location":"code_reference/models/","text":"Models \ud83d\udd17 AtomicInputOrList \ud83d\udd17 GROUP_ID_PREFIX \ud83d\udd17 OptimizationInputOrList \ud83d\udd17 PossibleResults \ud83d\udd17 PossibleResultsOrList \ud83d\udd17 Classes \ud83d\udd17 FutureResult ( FutureResultBase ) pydantic-model \ud83d\udd17 Single computation result Source code in tccloud/models.py class FutureResult ( FutureResultBase ): \"\"\"Single computation result\"\"\" result : Optional [ PossibleResults ] = None Attributes \ud83d\udd17 client : Any pydantic-field \ud83d\udd17 id : str pydantic-field required \ud83d\udd17 result : Union [ qcelemental . models . results . AtomicResult , qcelemental . models . procedures . OptimizationResult , qcelemental . models . common_models . FailedOperation ] pydantic-field \ud83d\udd17 status : str inherited property readonly \ud83d\udd17 Check status of compute task. Returns: Type Description str Status of computation. Note Sets self.result if task is complete. Config inherited \ud83d\udd17 Source code in tccloud/models.py class Config : underscore_attrs_are_private = True validate_assignment = True underscore_attrs_are_private \ud83d\udd17 validate_assignment \ud83d\udd17 Methods \ud83d\udd17 get ( self , timeout : Optional [ float ] = None , interval : float = 1.0 ) -> Union [ qcelemental . models . results . AtomicResult , qcelemental . models . procedures . OptimizationResult , qcelemental . models . common_models . FailedOperation , List [ Union [ qcelemental . models . results . AtomicResult , qcelemental . models . procedures . OptimizationResult , qcelemental . models . common_models . FailedOperation ]]] inherited \ud83d\udd17 Block and return result. Parameters: Name Type Description Default timeout Optional[float] The number of seconds to wait for a computation before raising a TimeOutError. None interval float The amount of time to wait between calls to TeraChem Cloud to check a computation's status. 1.0 Returns: Type Description Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation, List[Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation]]] Resultant values from a computation. Exceptions: Type Description TimeoutError Raised if timout interval exceeded. Source code in tccloud/models.py def get ( self , timeout : Optional [ float ] = None , # in seconds interval : float = 1.0 , ) -> PossibleResultsOrList : \"\"\"Block and return result. Parameters: timeout: The number of seconds to wait for a computation before raising a TimeOutError. interval: The amount of time to wait between calls to TeraChem Cloud to check a computation's status. Returns: Resultant values from a computation. Exceptions: TimeoutError: Raised if timout interval exceeded. \"\"\" if self . result : return self . result start_time = time () while not self . result : # Calling self.status returns status and sets self.result if task complete self . status if timeout : if ( time () - start_time ) > timeout : raise TimeoutError ( f \"Your timeout limit of { timeout } seconds was exceeded\" ) sleep ( interval ) return self . result FutureResultBase ( BaseModel , ABC ) pydantic-model \ud83d\udd17 Base class for FutureResults Parameters: Name Type Description Default id The id for primary task submitted to TeraChem Cloud. May correspond to a single task or group of tasks required client The _RequestsClient to use for http requests to TeraChem Cloud required result Primary return value resulting from computation required Caution A FutureResult should never be instantiated directly. TCClient.compute(...) will return one when you submit a computation. Source code in tccloud/models.py class FutureResultBase ( BaseModel , ABC ): \"\"\"Base class for FutureResults Parameters: id: The id for primary task submitted to TeraChem Cloud. May correspond to a single task or group of tasks client: The _RequestsClient to use for http requests to TeraChem Cloud result: Primary return value resulting from computation Caution: A FutureResult should never be instantiated directly. `TCClient.compute(...)` will return one when you submit a computation. \"\"\" id : str result : Optional [ Any ] = None client : Any _state : TaskStatus = TaskStatus . PENDING class Config : underscore_attrs_are_private = True validate_assignment = True def get ( self , timeout : Optional [ float ] = None , # in seconds interval : float = 1.0 , ) -> PossibleResultsOrList : \"\"\"Block and return result. Parameters: timeout: The number of seconds to wait for a computation before raising a TimeOutError. interval: The amount of time to wait between calls to TeraChem Cloud to check a computation's status. Returns: Resultant values from a computation. Exceptions: TimeoutError: Raised if timout interval exceeded. \"\"\" if self . result : return self . result start_time = time () while not self . result : # Calling self.status returns status and sets self.result if task complete self . status if timeout : if ( time () - start_time ) > timeout : raise TimeoutError ( f \"Your timeout limit of { timeout } seconds was exceeded\" ) sleep ( interval ) return self . result def _result ( self ): \"\"\"Return result from server\"\"\" return self . client . result ( self . id ) @property def status ( self ) -> str : \"\"\"Check status of compute task. Returns: Status of computation. Note: Sets self.result if task is complete. \"\"\" if self . result : return self . _state self . _state , self . result = self . _result () return self . _state Attributes \ud83d\udd17 client : Any pydantic-field \ud83d\udd17 id : str pydantic-field required \ud83d\udd17 result : Any pydantic-field \ud83d\udd17 status : str property readonly \ud83d\udd17 Check status of compute task. Returns: Type Description str Status of computation. Note Sets self.result if task is complete. Config \ud83d\udd17 Source code in tccloud/models.py class Config : underscore_attrs_are_private = True validate_assignment = True underscore_attrs_are_private \ud83d\udd17 validate_assignment \ud83d\udd17 Methods \ud83d\udd17 get ( self , timeout : Optional [ float ] = None , interval : float = 1.0 ) -> Union [ qcelemental . models . results . AtomicResult , qcelemental . models . procedures . OptimizationResult , qcelemental . models . common_models . FailedOperation , List [ Union [ qcelemental . models . results . AtomicResult , qcelemental . models . procedures . OptimizationResult , qcelemental . models . common_models . FailedOperation ]]] \ud83d\udd17 Block and return result. Parameters: Name Type Description Default timeout Optional[float] The number of seconds to wait for a computation before raising a TimeOutError. None interval float The amount of time to wait between calls to TeraChem Cloud to check a computation's status. 1.0 Returns: Type Description Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation, List[Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation]]] Resultant values from a computation. Exceptions: Type Description TimeoutError Raised if timout interval exceeded. Source code in tccloud/models.py def get ( self , timeout : Optional [ float ] = None , # in seconds interval : float = 1.0 , ) -> PossibleResultsOrList : \"\"\"Block and return result. Parameters: timeout: The number of seconds to wait for a computation before raising a TimeOutError. interval: The amount of time to wait between calls to TeraChem Cloud to check a computation's status. Returns: Resultant values from a computation. Exceptions: TimeoutError: Raised if timout interval exceeded. \"\"\" if self . result : return self . result start_time = time () while not self . result : # Calling self.status returns status and sets self.result if task complete self . status if timeout : if ( time () - start_time ) > timeout : raise TimeoutError ( f \"Your timeout limit of { timeout } seconds was exceeded\" ) sleep ( interval ) return self . result FutureResultGroup ( FutureResultBase ) pydantic-model \ud83d\udd17 Group computation result Source code in tccloud/models.py class FutureResultGroup ( FutureResultBase ): \"\"\"Group computation result\"\"\" result : Optional [ List [ PossibleResults ]] = None def _result ( self ): \"\"\"Return result from server. Remove GROUP_ID_PREFIX from id.\"\"\" return self . client . result ( self . id . replace ( GROUP_ID_PREFIX , \"\" )) @validator ( \"id\" ) def validate_id ( cls , v ): \"\"\"Prepend id with GROUP_ID_PREFIX. NOTE: This makes instiating FutureResultGroups from saved ids easier because they are differentiated from FutureResult ids. \"\"\" if not v . startswith ( GROUP_ID_PREFIX ): v = GROUP_ID_PREFIX + v return v Attributes \ud83d\udd17 client : Any pydantic-field \ud83d\udd17 id : str pydantic-field required \ud83d\udd17 result : List [ Union [ qcelemental . models . results . AtomicResult , qcelemental . models . procedures . OptimizationResult , qcelemental . models . common_models . FailedOperation ]] pydantic-field \ud83d\udd17 status : str inherited property readonly \ud83d\udd17 Check status of compute task. Returns: Type Description str Status of computation. Note Sets self.result if task is complete. Config inherited \ud83d\udd17 Source code in tccloud/models.py class Config : underscore_attrs_are_private = True validate_assignment = True underscore_attrs_are_private \ud83d\udd17 validate_assignment \ud83d\udd17 Methods \ud83d\udd17 get ( self , timeout : Optional [ float ] = None , interval : float = 1.0 ) -> Union [ qcelemental . models . results . AtomicResult , qcelemental . models . procedures . OptimizationResult , qcelemental . models . common_models . FailedOperation , List [ Union [ qcelemental . models . results . AtomicResult , qcelemental . models . procedures . OptimizationResult , qcelemental . models . common_models . FailedOperation ]]] inherited \ud83d\udd17 Block and return result. Parameters: Name Type Description Default timeout Optional[float] The number of seconds to wait for a computation before raising a TimeOutError. None interval float The amount of time to wait between calls to TeraChem Cloud to check a computation's status. 1.0 Returns: Type Description Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation, List[Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation]]] Resultant values from a computation. Exceptions: Type Description TimeoutError Raised if timout interval exceeded. Source code in tccloud/models.py def get ( self , timeout : Optional [ float ] = None , # in seconds interval : float = 1.0 , ) -> PossibleResultsOrList : \"\"\"Block and return result. Parameters: timeout: The number of seconds to wait for a computation before raising a TimeOutError. interval: The amount of time to wait between calls to TeraChem Cloud to check a computation's status. Returns: Resultant values from a computation. Exceptions: TimeoutError: Raised if timout interval exceeded. \"\"\" if self . result : return self . result start_time = time () while not self . result : # Calling self.status returns status and sets self.result if task complete self . status if timeout : if ( time () - start_time ) > timeout : raise TimeoutError ( f \"Your timeout limit of { timeout } seconds was exceeded\" ) sleep ( interval ) return self . result validate_id ( v ) classmethod \ud83d\udd17 Prepend id with GROUP_ID_PREFIX. Note This makes instiating FutureResultGroups from saved ids easier because they are differentiated from FutureResult ids. Source code in tccloud/models.py @validator ( \"id\" ) def validate_id ( cls , v ): \"\"\"Prepend id with GROUP_ID_PREFIX. NOTE: This makes instiating FutureResultGroups from saved ids easier because they are differentiated from FutureResult ids. \"\"\" if not v . startswith ( GROUP_ID_PREFIX ): v = GROUP_ID_PREFIX + v return v TaskStatus ( str , Enum ) \ud83d\udd17 Tasks status for a submitted compute job. Source code in tccloud/models.py class TaskStatus ( str , Enum ): \"\"\"Tasks status for a submitted compute job.\"\"\" #: Task state is unknown (assumed pending since you know the id). PENDING = \"PENDING\" COMPLETE = \"COMPLETE\" COMPLETE \ud83d\udd17 PENDING \ud83d\udd17 Functions \ud83d\udd17 from_file ( path : Union [ str , pathlib . Path ], client : Any ) -> List [ Union [ tccloud . models . FutureResult , tccloud . models . FutureResultGroup ]] \ud83d\udd17 Instantiate FutureResults or FutureResultGroups from file of result ids Parameters: Name Type Description Default path Union[str, pathlib.Path] Path to file containing the ids required client Any Instantiated TCClient object required Source code in tccloud/models.py def from_file ( path : Union [ str , Path ], client : Any , ) -> List [ Union [ FutureResult , FutureResultGroup ]]: \"\"\"Instantiate FutureResults or FutureResultGroups from file of result ids Params: path: Path to file containing the ids client: Instantiated TCClient object \"\"\" frs : List [ Union [ FutureResult , FutureResultGroup ]] = [] with open ( path ) as f : for id in f . readlines (): id = id . strip () model : Union [ Type [ FutureResult ], Type [ FutureResultGroup ]] if id . startswith ( GROUP_ID_PREFIX ): model = FutureResultGroup else : model = FutureResult frs . append ( model ( id = id , client = client . _client )) assert len ( frs ) > 0 , \"No ids found in file!\" return frs to_file ( future_results : Union [ tccloud . models . FutureResultBase , List [ tccloud . models . FutureResultBase ]], path : Union [ str , pathlib . Path ], * , append : bool = False ) -> None \ud83d\udd17 Write FutureResults to disk for later retrieval Parameters: Name Type Description Default future_results Union[tccloud.models.FutureResultBase, List[tccloud.models.FutureResultBase]] List of or single FutureResult or FutureResultGroup required path Union[str, pathlib.Path] File path to results file required append bool Append results to an existing file if True, else create new file False Source code in tccloud/models.py def to_file ( future_results : Union [ FutureResultBase , List [ FutureResultBase ]], path : Union [ str , Path ], * , append : bool = False , ) -> None : \"\"\"Write FutureResults to disk for later retrieval Params: future_results: List of or single FutureResult or FutureResultGroup path: File path to results file append: Append results to an existing file if True, else create new file \"\"\" if not isinstance ( future_results , list ): future_results = [ future_results ] with open ( path , f \" { 'a' if append else 'w' } \" ) as f : f . writelines ([ f \" { fr . id } \\n \" for fr in future_results ])","title":"Models"},{"location":"code_reference/models/#models","text":"","title":"Models"},{"location":"code_reference/models/#tccloud.models.AtomicInputOrList","text":"","title":"AtomicInputOrList"},{"location":"code_reference/models/#tccloud.models.GROUP_ID_PREFIX","text":"","title":"GROUP_ID_PREFIX"},{"location":"code_reference/models/#tccloud.models.OptimizationInputOrList","text":"","title":"OptimizationInputOrList"},{"location":"code_reference/models/#tccloud.models.PossibleResults","text":"","title":"PossibleResults"},{"location":"code_reference/models/#tccloud.models.PossibleResultsOrList","text":"","title":"PossibleResultsOrList"},{"location":"code_reference/models/#tccloud.models-classes","text":"","title":"Classes"},{"location":"code_reference/models/#tccloud.models.FutureResult","text":"Single computation result Source code in tccloud/models.py class FutureResult ( FutureResultBase ): \"\"\"Single computation result\"\"\" result : Optional [ PossibleResults ] = None","title":"FutureResult"},{"location":"code_reference/models/#tccloud.models.FutureResult-attributes","text":"","title":"Attributes"},{"location":"code_reference/models/#tccloud.models.FutureResult.client","text":"","title":"client"},{"location":"code_reference/models/#tccloud.models.FutureResult.id","text":"","title":"id"},{"location":"code_reference/models/#tccloud.models.FutureResult.result","text":"","title":"result"},{"location":"code_reference/models/#tccloud.models.FutureResult.status","text":"Check status of compute task. Returns: Type Description str Status of computation. Note Sets self.result if task is complete.","title":"status"},{"location":"code_reference/models/#tccloud.models.FutureResult.Config","text":"Source code in tccloud/models.py class Config : underscore_attrs_are_private = True validate_assignment = True underscore_attrs_are_private \ud83d\udd17 validate_assignment \ud83d\udd17","title":"Config"},{"location":"code_reference/models/#tccloud.models.FutureResult-methods","text":"","title":"Methods"},{"location":"code_reference/models/#tccloud.models.FutureResult.get","text":"Block and return result. Parameters: Name Type Description Default timeout Optional[float] The number of seconds to wait for a computation before raising a TimeOutError. None interval float The amount of time to wait between calls to TeraChem Cloud to check a computation's status. 1.0 Returns: Type Description Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation, List[Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation]]] Resultant values from a computation. Exceptions: Type Description TimeoutError Raised if timout interval exceeded. Source code in tccloud/models.py def get ( self , timeout : Optional [ float ] = None , # in seconds interval : float = 1.0 , ) -> PossibleResultsOrList : \"\"\"Block and return result. Parameters: timeout: The number of seconds to wait for a computation before raising a TimeOutError. interval: The amount of time to wait between calls to TeraChem Cloud to check a computation's status. Returns: Resultant values from a computation. Exceptions: TimeoutError: Raised if timout interval exceeded. \"\"\" if self . result : return self . result start_time = time () while not self . result : # Calling self.status returns status and sets self.result if task complete self . status if timeout : if ( time () - start_time ) > timeout : raise TimeoutError ( f \"Your timeout limit of { timeout } seconds was exceeded\" ) sleep ( interval ) return self . result","title":"get()"},{"location":"code_reference/models/#tccloud.models.FutureResultBase","text":"Base class for FutureResults Parameters: Name Type Description Default id The id for primary task submitted to TeraChem Cloud. May correspond to a single task or group of tasks required client The _RequestsClient to use for http requests to TeraChem Cloud required result Primary return value resulting from computation required Caution A FutureResult should never be instantiated directly. TCClient.compute(...) will return one when you submit a computation. Source code in tccloud/models.py class FutureResultBase ( BaseModel , ABC ): \"\"\"Base class for FutureResults Parameters: id: The id for primary task submitted to TeraChem Cloud. May correspond to a single task or group of tasks client: The _RequestsClient to use for http requests to TeraChem Cloud result: Primary return value resulting from computation Caution: A FutureResult should never be instantiated directly. `TCClient.compute(...)` will return one when you submit a computation. \"\"\" id : str result : Optional [ Any ] = None client : Any _state : TaskStatus = TaskStatus . PENDING class Config : underscore_attrs_are_private = True validate_assignment = True def get ( self , timeout : Optional [ float ] = None , # in seconds interval : float = 1.0 , ) -> PossibleResultsOrList : \"\"\"Block and return result. Parameters: timeout: The number of seconds to wait for a computation before raising a TimeOutError. interval: The amount of time to wait between calls to TeraChem Cloud to check a computation's status. Returns: Resultant values from a computation. Exceptions: TimeoutError: Raised if timout interval exceeded. \"\"\" if self . result : return self . result start_time = time () while not self . result : # Calling self.status returns status and sets self.result if task complete self . status if timeout : if ( time () - start_time ) > timeout : raise TimeoutError ( f \"Your timeout limit of { timeout } seconds was exceeded\" ) sleep ( interval ) return self . result def _result ( self ): \"\"\"Return result from server\"\"\" return self . client . result ( self . id ) @property def status ( self ) -> str : \"\"\"Check status of compute task. Returns: Status of computation. Note: Sets self.result if task is complete. \"\"\" if self . result : return self . _state self . _state , self . result = self . _result () return self . _state","title":"FutureResultBase"},{"location":"code_reference/models/#tccloud.models.FutureResultBase-attributes","text":"","title":"Attributes"},{"location":"code_reference/models/#tccloud.models.FutureResultBase.client","text":"","title":"client"},{"location":"code_reference/models/#tccloud.models.FutureResultBase.id","text":"","title":"id"},{"location":"code_reference/models/#tccloud.models.FutureResultBase.result","text":"","title":"result"},{"location":"code_reference/models/#tccloud.models.FutureResultBase.status","text":"Check status of compute task. Returns: Type Description str Status of computation. Note Sets self.result if task is complete.","title":"status"},{"location":"code_reference/models/#tccloud.models.FutureResultBase.Config","text":"Source code in tccloud/models.py class Config : underscore_attrs_are_private = True validate_assignment = True underscore_attrs_are_private \ud83d\udd17 validate_assignment \ud83d\udd17","title":"Config"},{"location":"code_reference/models/#tccloud.models.FutureResultBase-methods","text":"","title":"Methods"},{"location":"code_reference/models/#tccloud.models.FutureResultBase.get","text":"Block and return result. Parameters: Name Type Description Default timeout Optional[float] The number of seconds to wait for a computation before raising a TimeOutError. None interval float The amount of time to wait between calls to TeraChem Cloud to check a computation's status. 1.0 Returns: Type Description Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation, List[Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation]]] Resultant values from a computation. Exceptions: Type Description TimeoutError Raised if timout interval exceeded. Source code in tccloud/models.py def get ( self , timeout : Optional [ float ] = None , # in seconds interval : float = 1.0 , ) -> PossibleResultsOrList : \"\"\"Block and return result. Parameters: timeout: The number of seconds to wait for a computation before raising a TimeOutError. interval: The amount of time to wait between calls to TeraChem Cloud to check a computation's status. Returns: Resultant values from a computation. Exceptions: TimeoutError: Raised if timout interval exceeded. \"\"\" if self . result : return self . result start_time = time () while not self . result : # Calling self.status returns status and sets self.result if task complete self . status if timeout : if ( time () - start_time ) > timeout : raise TimeoutError ( f \"Your timeout limit of { timeout } seconds was exceeded\" ) sleep ( interval ) return self . result","title":"get()"},{"location":"code_reference/models/#tccloud.models.FutureResultGroup","text":"Group computation result Source code in tccloud/models.py class FutureResultGroup ( FutureResultBase ): \"\"\"Group computation result\"\"\" result : Optional [ List [ PossibleResults ]] = None def _result ( self ): \"\"\"Return result from server. Remove GROUP_ID_PREFIX from id.\"\"\" return self . client . result ( self . id . replace ( GROUP_ID_PREFIX , \"\" )) @validator ( \"id\" ) def validate_id ( cls , v ): \"\"\"Prepend id with GROUP_ID_PREFIX. NOTE: This makes instiating FutureResultGroups from saved ids easier because they are differentiated from FutureResult ids. \"\"\" if not v . startswith ( GROUP_ID_PREFIX ): v = GROUP_ID_PREFIX + v return v","title":"FutureResultGroup"},{"location":"code_reference/models/#tccloud.models.FutureResultGroup-attributes","text":"","title":"Attributes"},{"location":"code_reference/models/#tccloud.models.FutureResultGroup.client","text":"","title":"client"},{"location":"code_reference/models/#tccloud.models.FutureResultGroup.id","text":"","title":"id"},{"location":"code_reference/models/#tccloud.models.FutureResultGroup.result","text":"","title":"result"},{"location":"code_reference/models/#tccloud.models.FutureResultGroup.status","text":"Check status of compute task. Returns: Type Description str Status of computation. Note Sets self.result if task is complete.","title":"status"},{"location":"code_reference/models/#tccloud.models.FutureResultGroup.Config","text":"Source code in tccloud/models.py class Config : underscore_attrs_are_private = True validate_assignment = True underscore_attrs_are_private \ud83d\udd17 validate_assignment \ud83d\udd17","title":"Config"},{"location":"code_reference/models/#tccloud.models.FutureResultGroup-methods","text":"","title":"Methods"},{"location":"code_reference/models/#tccloud.models.FutureResultGroup.get","text":"Block and return result. Parameters: Name Type Description Default timeout Optional[float] The number of seconds to wait for a computation before raising a TimeOutError. None interval float The amount of time to wait between calls to TeraChem Cloud to check a computation's status. 1.0 Returns: Type Description Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation, List[Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation]]] Resultant values from a computation. Exceptions: Type Description TimeoutError Raised if timout interval exceeded. Source code in tccloud/models.py def get ( self , timeout : Optional [ float ] = None , # in seconds interval : float = 1.0 , ) -> PossibleResultsOrList : \"\"\"Block and return result. Parameters: timeout: The number of seconds to wait for a computation before raising a TimeOutError. interval: The amount of time to wait between calls to TeraChem Cloud to check a computation's status. Returns: Resultant values from a computation. Exceptions: TimeoutError: Raised if timout interval exceeded. \"\"\" if self . result : return self . result start_time = time () while not self . result : # Calling self.status returns status and sets self.result if task complete self . status if timeout : if ( time () - start_time ) > timeout : raise TimeoutError ( f \"Your timeout limit of { timeout } seconds was exceeded\" ) sleep ( interval ) return self . result","title":"get()"},{"location":"code_reference/models/#tccloud.models.FutureResultGroup.validate_id","text":"Prepend id with GROUP_ID_PREFIX. Note This makes instiating FutureResultGroups from saved ids easier because they are differentiated from FutureResult ids. Source code in tccloud/models.py @validator ( \"id\" ) def validate_id ( cls , v ): \"\"\"Prepend id with GROUP_ID_PREFIX. NOTE: This makes instiating FutureResultGroups from saved ids easier because they are differentiated from FutureResult ids. \"\"\" if not v . startswith ( GROUP_ID_PREFIX ): v = GROUP_ID_PREFIX + v return v","title":"validate_id()"},{"location":"code_reference/models/#tccloud.models.TaskStatus","text":"Tasks status for a submitted compute job. Source code in tccloud/models.py class TaskStatus ( str , Enum ): \"\"\"Tasks status for a submitted compute job.\"\"\" #: Task state is unknown (assumed pending since you know the id). PENDING = \"PENDING\" COMPLETE = \"COMPLETE\"","title":"TaskStatus"},{"location":"code_reference/models/#tccloud.models.TaskStatus.COMPLETE","text":"","title":"COMPLETE"},{"location":"code_reference/models/#tccloud.models.TaskStatus.PENDING","text":"","title":"PENDING"},{"location":"code_reference/models/#tccloud.models-functions","text":"","title":"Functions"},{"location":"code_reference/models/#tccloud.models.from_file","text":"Instantiate FutureResults or FutureResultGroups from file of result ids Parameters: Name Type Description Default path Union[str, pathlib.Path] Path to file containing the ids required client Any Instantiated TCClient object required Source code in tccloud/models.py def from_file ( path : Union [ str , Path ], client : Any , ) -> List [ Union [ FutureResult , FutureResultGroup ]]: \"\"\"Instantiate FutureResults or FutureResultGroups from file of result ids Params: path: Path to file containing the ids client: Instantiated TCClient object \"\"\" frs : List [ Union [ FutureResult , FutureResultGroup ]] = [] with open ( path ) as f : for id in f . readlines (): id = id . strip () model : Union [ Type [ FutureResult ], Type [ FutureResultGroup ]] if id . startswith ( GROUP_ID_PREFIX ): model = FutureResultGroup else : model = FutureResult frs . append ( model ( id = id , client = client . _client )) assert len ( frs ) > 0 , \"No ids found in file!\" return frs","title":"from_file()"},{"location":"code_reference/models/#tccloud.models.to_file","text":"Write FutureResults to disk for later retrieval Parameters: Name Type Description Default future_results Union[tccloud.models.FutureResultBase, List[tccloud.models.FutureResultBase]] List of or single FutureResult or FutureResultGroup required path Union[str, pathlib.Path] File path to results file required append bool Append results to an existing file if True, else create new file False Source code in tccloud/models.py def to_file ( future_results : Union [ FutureResultBase , List [ FutureResultBase ]], path : Union [ str , Path ], * , append : bool = False , ) -> None : \"\"\"Write FutureResults to disk for later retrieval Params: future_results: List of or single FutureResult or FutureResultGroup path: File path to results file append: Append results to an existing file if True, else create new file \"\"\" if not isinstance ( future_results , list ): future_results = [ future_results ] with open ( path , f \" { 'a' if append else 'w' } \" ) as f : f . writelines ([ f \" { fr . id } \\n \" for fr in future_results ])","title":"to_file()"},{"location":"development/core_decisions/","text":"Core Development Decisions \ud83d\udd17 _RequestsClient Class \ud83d\udd17 _RequestsClient public http methods (like compute() and result() should always return Python objects. This gives a layer of abstraction between callers who want to think in terms of Python data objects and the _RequestsClient which thinks in terms of http requests and json data structures. I'm starting to have second thoughts about this ^^ decision. It feels like the _RequestsClient is starting to take on too much responsibility. It accepts python data types as parameters, and returns python data types as it if were an end-user class. It isn't. It's meant to be a utility class used by end-user objects such as TCClient and FutureResult objects. I think it should return data more directly from the TeraChem Cloud API and let the other classes handle this data. This becomes more apparent as I add pydantic to my data models and realize I'd rather have them pass rawer data types to the _RequestsClient and then handle the results of an API call inside their own class. Maybe the compute() and compute_procedure() methods on the _RequestsClient should go away and these should live exclusively on the TCClient object which then utilizes request and authenticated_request to access TeraChem Cloud. FutureResult Class \ud83d\udd17 .get() will return either an AtomicResult or a FailedOperation object. From the users perspective they essentially get back a generic \"Result\" object (which will be either an AtomicResult or FailedOperation ) and can check for its status (once complete) by checking result.status . While this separates the user a bit from the \"status\" field returned by the API, I think this is the easiest user interface, i.e., they get back a result from a future_result and can check its status very simply without having to think separately about status fields and results fields They can still access the API returned status field at future_result.status if needed. E.g.,: result = future_result . get () result . success False # If FailedOperation returned result . success True # If AtomicResult returned","title":"Core Development Decisions"},{"location":"development/core_decisions/#core-development-decisions","text":"","title":"Core Development Decisions"},{"location":"development/core_decisions/#_requestsclient-class","text":"_RequestsClient public http methods (like compute() and result() should always return Python objects. This gives a layer of abstraction between callers who want to think in terms of Python data objects and the _RequestsClient which thinks in terms of http requests and json data structures. I'm starting to have second thoughts about this ^^ decision. It feels like the _RequestsClient is starting to take on too much responsibility. It accepts python data types as parameters, and returns python data types as it if were an end-user class. It isn't. It's meant to be a utility class used by end-user objects such as TCClient and FutureResult objects. I think it should return data more directly from the TeraChem Cloud API and let the other classes handle this data. This becomes more apparent as I add pydantic to my data models and realize I'd rather have them pass rawer data types to the _RequestsClient and then handle the results of an API call inside their own class. Maybe the compute() and compute_procedure() methods on the _RequestsClient should go away and these should live exclusively on the TCClient object which then utilizes request and authenticated_request to access TeraChem Cloud.","title":"_RequestsClient Class"},{"location":"development/core_decisions/#futureresult-class","text":".get() will return either an AtomicResult or a FailedOperation object. From the users perspective they essentially get back a generic \"Result\" object (which will be either an AtomicResult or FailedOperation ) and can check for its status (once complete) by checking result.status . While this separates the user a bit from the \"status\" field returned by the API, I think this is the easiest user interface, i.e., they get back a result from a future_result and can check its status very simply without having to think separately about status fields and results fields They can still access the API returned status field at future_result.status if needed. E.g.,: result = future_result . get () result . success False # If FailedOperation returned result . success True # If AtomicResult returned","title":"FutureResult Class"},{"location":"tutorial/authentication/","text":"Authentication \ud83d\udd17 Authentication is the process of supplying your credentials (usually a username and password) to tccloud so that you can perform computation. tccloud provides a few easy ways for you to authenticate. If you do not have a TeraChem Cloud account you can get one for free here: https://tccloud.mtzlab.com/signup Username and Password \ud83d\udd17 client.configure() (recommended for most cases) \ud83d\udd17 >>> from tccloud import TCClient >>> client = TCClient () >>> client . configure () \u2705 If you dont get have an account please signup at : https : // tccloud . mtzlab . com / signup Please enter your TeraChem Cloud username : your_username @email . com Please enter your TeraChem Cloud password : Authenticating ... 'default' profile configured ! Username / password not required for future use of TCClient Performing this action will configure your local client by writing authentication tokens to ~/.tccloud/credentials . You will not need to execute configure() ever again. Under the hood TCClient will access your tokens, refresh them when necessary, and keep you logged in to TeraChem Cloud. Note that this will write a file to your home directory with sensitive access tokens, so if you are on a shared computer or using a device where you would not want to write this information to disk do not use this option. If you would like to write the credentials file to a different directory than ~/.tccloud , set the TCCLOUD_BASE_DIRECTORY environment variable to the path of interest. You can configure multiple profiles in case you have multiple logins to TeraChem cloud by passing a profile name to configure() : >>> client . configure ( 'mtz_lab' ) \u2705 If you dont get have an account please signup at : https : // tccloud . mtzlab . com / signup Please enter your TeraChem Cloud username : your_username @email . om Please enter your TeraChem Cloud password : Authenticating ... 'mtz_lab' profile configured ! Username / password not required for future use of TCClient To use one of these profiles pass the profile option to your client instance. The \"default\" profile is used when no profile name is passed: >>> from tccloud import TCClient # Use default profile >>> client = TCClient () # Use named profile >>> client = TCClient ( profile = \"mtz_lab\" ) Environment Variables \ud83d\udd17 You can set your TeraChem username and password in your environment and the client will find them automatically. Set TCCLOUD_USERNAME and TCCLOUD_PASSWORD . When you create a client it will find these values and maintain all access tokens in memory only. Pass Username/Password when prompted after requesting a compute job \ud83d\udd17 If you have not run client.configure() or set environment variables you will be requested for your username and password when you submit a computation to TeraChem Cloud using client.compute(...) . The client will use your username and password to get access tokens and will maintain access tokens for you in memory only. Your login session will be valid for the duration of your python session. Pass Username/Password to Client (not recommended) \ud83d\udd17 You can directly pass a username and password to the client object. This is not recommended as it opens up the possibility of your credentials accidentally being committed to your code repo. However, it can be used in rare circumstances when necessary. >>> from tccloud import TCClient >>> client = TCClient ( tccloud_username = \"your_username@email.com\" , tccloud_password = \"super_secret_password\" )","title":"Authentication"},{"location":"tutorial/authentication/#authentication","text":"Authentication is the process of supplying your credentials (usually a username and password) to tccloud so that you can perform computation. tccloud provides a few easy ways for you to authenticate. If you do not have a TeraChem Cloud account you can get one for free here: https://tccloud.mtzlab.com/signup","title":"Authentication"},{"location":"tutorial/authentication/#username-and-password","text":"","title":"Username and Password"},{"location":"tutorial/authentication/#clientconfigure-recommended-for-most-cases","text":">>> from tccloud import TCClient >>> client = TCClient () >>> client . configure () \u2705 If you dont get have an account please signup at : https : // tccloud . mtzlab . com / signup Please enter your TeraChem Cloud username : your_username @email . com Please enter your TeraChem Cloud password : Authenticating ... 'default' profile configured ! Username / password not required for future use of TCClient Performing this action will configure your local client by writing authentication tokens to ~/.tccloud/credentials . You will not need to execute configure() ever again. Under the hood TCClient will access your tokens, refresh them when necessary, and keep you logged in to TeraChem Cloud. Note that this will write a file to your home directory with sensitive access tokens, so if you are on a shared computer or using a device where you would not want to write this information to disk do not use this option. If you would like to write the credentials file to a different directory than ~/.tccloud , set the TCCLOUD_BASE_DIRECTORY environment variable to the path of interest. You can configure multiple profiles in case you have multiple logins to TeraChem cloud by passing a profile name to configure() : >>> client . configure ( 'mtz_lab' ) \u2705 If you dont get have an account please signup at : https : // tccloud . mtzlab . com / signup Please enter your TeraChem Cloud username : your_username @email . om Please enter your TeraChem Cloud password : Authenticating ... 'mtz_lab' profile configured ! Username / password not required for future use of TCClient To use one of these profiles pass the profile option to your client instance. The \"default\" profile is used when no profile name is passed: >>> from tccloud import TCClient # Use default profile >>> client = TCClient () # Use named profile >>> client = TCClient ( profile = \"mtz_lab\" )","title":"client.configure() (recommended for most cases)"},{"location":"tutorial/authentication/#environment-variables","text":"You can set your TeraChem username and password in your environment and the client will find them automatically. Set TCCLOUD_USERNAME and TCCLOUD_PASSWORD . When you create a client it will find these values and maintain all access tokens in memory only.","title":"Environment Variables"},{"location":"tutorial/authentication/#pass-usernamepassword-when-prompted-after-requesting-a-compute-job","text":"If you have not run client.configure() or set environment variables you will be requested for your username and password when you submit a computation to TeraChem Cloud using client.compute(...) . The client will use your username and password to get access tokens and will maintain access tokens for you in memory only. Your login session will be valid for the duration of your python session.","title":"Pass Username/Password when prompted after requesting a compute job"},{"location":"tutorial/authentication/#pass-usernamepassword-to-client-not-recommended","text":"You can directly pass a username and password to the client object. This is not recommended as it opens up the possibility of your credentials accidentally being committed to your code repo. However, it can be used in rare circumstances when necessary. >>> from tccloud import TCClient >>> client = TCClient ( tccloud_username = \"your_username@email.com\" , tccloud_password = \"super_secret_password\" )","title":"Pass Username/Password to Client (not recommended)"},{"location":"tutorial/batch_computations/","text":"Batch Computations \ud83d\udd17 Both single point and geometry optimizations can be performed in bulk by submitting up to 100 computations simultaneously. Simply submit an array of AtomicInputs or OptimizationInput objects as input data. from tccloud import TCClient from tccloud.models import AtomicInput , Molecule client = TCClient () water = Molecule . from_data ( \"pubchem:water\" ) atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"energy\" , keywords = { \"closed\" : True , \"restricted\" : True , }, ) future_result = client . compute ([ atomic_input ] * 2 , engine = \"terachem_fe\" ) result = future_result . get () # Array of AtomicResult objects print ( result )","title":"Batch Computations"},{"location":"tutorial/batch_computations/#batch-computations","text":"Both single point and geometry optimizations can be performed in bulk by submitting up to 100 computations simultaneously. Simply submit an array of AtomicInputs or OptimizationInput objects as input data. from tccloud import TCClient from tccloud.models import AtomicInput , Molecule client = TCClient () water = Molecule . from_data ( \"pubchem:water\" ) atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"energy\" , keywords = { \"closed\" : True , \"restricted\" : True , }, ) future_result = client . compute ([ atomic_input ] * 2 , engine = \"terachem_fe\" ) result = future_result . get () # Array of AtomicResult objects print ( result )","title":"Batch Computations"},{"location":"tutorial/compute/","text":"Compute \ud83d\udd17 Overview \ud83d\udd17 Computations are physically executed on TeraChem Cloud . The tccloud python client submits jobs to and retrieves work from TeraChem Cloud. Computations are submitted using the TCClient object. Computations require an AtomicInput object and the specification of a compute engine. from tccloud import TCClient from tccloud.models import AtomicInput , Molecule client = TCClient () water = Molecule . from_data ( \"pubchem:water\" ) atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"energy\" , keywords = { \"closed\" : True , \"restricted\" : True , }, protocols = { \"stdout\" : True , \"native_files\" : \"all\" }, extras = { \"tcfe:keywords\" : { \"native_files\" : [ \"c0\" ]}}, ) future_result = client . compute ( atomic_input , engine = \"terachem_fe\" ) result = future_result . get () # AtomicResult object containing all returned data print ( result ) # The energy value requested print ( result . return_result ) print ( result . stdout ) print ( result . native_files . keys ())","title":"Compute"},{"location":"tutorial/compute/#compute","text":"","title":"Compute"},{"location":"tutorial/compute/#overview","text":"Computations are physically executed on TeraChem Cloud . The tccloud python client submits jobs to and retrieves work from TeraChem Cloud. Computations are submitted using the TCClient object. Computations require an AtomicInput object and the specification of a compute engine. from tccloud import TCClient from tccloud.models import AtomicInput , Molecule client = TCClient () water = Molecule . from_data ( \"pubchem:water\" ) atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"energy\" , keywords = { \"closed\" : True , \"restricted\" : True , }, protocols = { \"stdout\" : True , \"native_files\" : \"all\" }, extras = { \"tcfe:keywords\" : { \"native_files\" : [ \"c0\" ]}}, ) future_result = client . compute ( atomic_input , engine = \"terachem_fe\" ) result = future_result . get () # AtomicResult object containing all returned data print ( result ) # The energy value requested print ( result . return_result ) print ( result . stdout ) print ( result . native_files . keys ())","title":"Overview"},{"location":"tutorial/compute_engines/","text":"Compute Engines \ud83d\udd17 Supported compute engines in tccloud can be checked as follows: from tccloud import TCClient client = TCClient () client . supported_engines [ \"psi4\" , \"terachem_fe\" , \"rdkit\" , ... ] Please see TeraChem Cloud Algorithms for details on parallel execution algorithms unique to the TeraChem Cloud ( tcc ) compute engine. Keywords \ud83d\udd17 Keywords specific to a quantum chemistry engine can be added to an AtomicInput as follows: ai = AtomicInput ( ... , keywords = { \"molden\" : True , \"restricted\" : True , ... } ) TeraChem \ud83d\udd17 Relevant keywords \ud83d\udd17 Keyword Type Description Default Value molden bool If True with mo_ouput=True the result.extras[\"molden\"] field will contain a string of the molden file False mo_output bool Request atomic orbital and molecular orbital information. Needs to be set to True to generate data required for molden file False convthre float Convergence threshold for SCF calculations 3.0e-5 precision str Can be single , double , mixed or other values Unknown dftgrid int Speeds up a computation somehow. 0 makes things quicker Unknown restricted bool Restricted computation True closed bool Closed shell True Psi4 \ud83d\udd17 rdkit \ud83d\udd17 xtb \ud83d\udd17 xtb specific documentation on how to run calculations using the QCSchema specification used TeraChem Cloud can be found here and here .","title":"Compute Engines"},{"location":"tutorial/compute_engines/#compute-engines","text":"Supported compute engines in tccloud can be checked as follows: from tccloud import TCClient client = TCClient () client . supported_engines [ \"psi4\" , \"terachem_fe\" , \"rdkit\" , ... ] Please see TeraChem Cloud Algorithms for details on parallel execution algorithms unique to the TeraChem Cloud ( tcc ) compute engine.","title":"Compute Engines"},{"location":"tutorial/compute_engines/#keywords","text":"Keywords specific to a quantum chemistry engine can be added to an AtomicInput as follows: ai = AtomicInput ( ... , keywords = { \"molden\" : True , \"restricted\" : True , ... } )","title":"Keywords"},{"location":"tutorial/compute_engines/#terachem","text":"","title":"TeraChem"},{"location":"tutorial/compute_engines/#relevant-keywords","text":"Keyword Type Description Default Value molden bool If True with mo_ouput=True the result.extras[\"molden\"] field will contain a string of the molden file False mo_output bool Request atomic orbital and molecular orbital information. Needs to be set to True to generate data required for molden file False convthre float Convergence threshold for SCF calculations 3.0e-5 precision str Can be single , double , mixed or other values Unknown dftgrid int Speeds up a computation somehow. 0 makes things quicker Unknown restricted bool Restricted computation True closed bool Closed shell True","title":"Relevant keywords"},{"location":"tutorial/compute_engines/#psi4","text":"","title":"Psi4"},{"location":"tutorial/compute_engines/#rdkit","text":"","title":"rdkit"},{"location":"tutorial/compute_engines/#xtb","text":"xtb specific documentation on how to run calculations using the QCSchema specification used TeraChem Cloud can be found here and here .","title":"xtb"},{"location":"tutorial/geometry_optimization/","text":"Geometry Optimization \ud83d\udd17 Basic Working Example \ud83d\udd17 Create a Molecule Define parameters for the compute engine Define the optimization parameters for the optimizer and specify the compute engine Specify the optimizer to run from pprint import pprint from tccloud import TCClient from tccloud.models import Molecule , OptimizationInput , QCInputSpecification client = TCClient () water = Molecule . from_data ( \"pubchem:water\" ) input_spec = QCInputSpecification ( model = { \"method\" : \"b3lyp\" , \"basis\" : \"6-31g\" }, # Keywords for the compute engine (e.g., psi4, terachem_fe) keywords = {}, ) opt_input = OptimizationInput ( initial_molecule = water , input_specification = input_spec , # Trajectory molecules to include in result, may be one of: # 'all' or 'initial_and_final' or 'final' or 'none' protocols = { \"trajectory\" : \"all\" }, # Must define compute engine \"program\": \"engine_name\" # Define keywords for optimizer (pyberny or geomeTRIC) keywords = { \"program\" : \"terachem_fe\" , \"maxsteps\" : 3 }, ) # Optimizer can be \"berny\" or \"geometric\" future_result = client . compute_procedure ( opt_input , \"berny\" ) result = future_result . get () if result . success : print ( \"Optimization succeeded!\" ) # Will be OptimizationResult object print ( result ) # The final molecule of the geometry optimization print ( result . final_molecule ) # Initial molecule print ( result . initial_molecule ) # A list of ordered AtomicResult objects for each step in the optimization print ( result . trajectory ) # A list of ordered energies for each step in the optimization print ( result . energies ) else : print ( \"Optimization failed!\" ) # Will be FailedOperation object print ( result ) # Error information print ( result . error ) # Detailed error message pprint ( result . error . error_message ) Using Force Fields \ud83d\udd17 rdkit can be specified as a compute backend to perform optimizations using force field methods instead of quantum chemistry backends. To use rdkit force field methods simply modify the model specification and program specification as shown below. Also note that rdkit requires the molecular connectivity to be defined. # Hack to quickly drop in water's connectivity water = Molecule . from_data ( \"pubchem:water\" ) water = Molecule ( ** { ** water . dict (), \"connectivity\" : [( 0 , 1 , 1.0 ), ( 0 , 2 , 1.0 )]}) input_spec = QCInputSpecification ( ... model = { \"method\" : \"UFF\" } # or any other force field ) opt_input = OptimizationInput ( ... keywords = { \"program\" : \"rdkit\" }, ) future_result = client . compute_procedure ( opt_input , \"geometric\" ) Berny Specifics \ud83d\udd17 The berny procedure uses the pyberny package to perform a geometry optimization. berny specific keywords are subject to change as the berny package evolves, but for simplicity a short list is included here with default values noted: Keyword Description Default Value maxsteps Maximum number of steps in the optimization 100 gradientmax Convergence criteria (AU) 0.45e-3 gradientrms Convergence criteria (AU) 0.15e-3 stepmax Step in internal coordinates, assuming radian units for angles (AU) 1.8e-3 steprms Step in internal coordinates, assuming radian units for angles (AU) 0.45e-3 trust Initial trust radius in AU. It is the maximum RMS of the quadratic step 0.3 dihedral Form dihedral angles True superweakdih Form dihedral angles containing two or more noncovalent bonds False geomeTRIC Specifics \ud83d\udd17 The geometric procedure uses the geomeTRIC package to perform a geometry optimization. geomeTRIC specific keywords are subject to change as the geomeTRIC package evolves. Since geomeTRIC has considerably more keywords, here's the source code that defines varous parameters for an optimization. Keywords noted below can be included in the OptimizationInput keywords dictionary. If these options are overwhelming, keep in mind you can run both the berny and geometric optimizers without any keywords and the optimizers will use sensible defaults. class OptParams ( object ): \"\"\" Container for optimization parameters. The parameters used to be contained in the command-line \"args\", but this was dropped in order to call Optimize() from another script. \"\"\" def __init__ ( self , ** kwargs ): # Whether we are optimizing for a transition state. This changes a number of default parameters. self . transition = kwargs . get ( 'transition' , False ) # CI optimizations sometimes require tiny steps self . meci = kwargs . get ( 'meci' , False ) # Handle convergence criteria; this edits the kwargs self . convergence_criteria ( ** kwargs ) # Threshold (in a.u. / rad) for activating alternative algorithm that enforces precise constraint satisfaction self . enforce = kwargs . get ( 'enforce' , 0.0 ) # Small eigenvalue threshold self . epsilon = kwargs . get ( 'epsilon' , 1e-5 ) # Interval for checking the coordinate system for changes self . check = kwargs . get ( 'check' , 0 ) # More verbose printout self . verbose = kwargs . get ( 'verbose' , False ) # Starting value of the trust radius # Because TS optimization is experimental, use conservative trust radii self . trust = kwargs . get ( 'trust' , 0.01 if self . transition else 0.1 ) # Maximum value of trust radius self . tmax = kwargs . get ( 'tmax' , 0.03 if self . transition else 0.3 ) # Minimum value of the trust radius self . tmin = kwargs . get ( 'tmin' , 0.0 if ( self . transition or self . meci ) else min ( 1.2e-3 , self . Convergence_drms )) # Minimum size of a step that can be rejected self . thre_rj = kwargs . get ( 'thre_rj' , 1e-4 if ( self . transition or self . meci ) else 1e-2 ) # Sanity checks on trust radius if self . tmax < self . tmin : raise ParamError ( \"Max trust radius must be larger than min\" ) # The trust radius should not be outside (tmin, tmax) self . trust = min ( self . tmax , self . trust ) self . trust = max ( self . tmin , self . trust ) # Maximum number of optimization cycles self . maxiter = kwargs . get ( 'maxiter' , 300 ) # Use updated constraint algorithm implemented 2019-03-20 self . conmethod = kwargs . get ( 'conmethod' , 0 ) # Write Hessian matrix at optimized structure to text file self . write_cart_hess = kwargs . get ( 'write_cart_hess' , None ) # Output .xyz file name may be set separately in # run_optimizer() prior to calling Optimize(). self . xyzout = kwargs . get ( 'xyzout' , None ) # Name of the qdata.txt file to be written. # The CLI is designed so the user passes true/false instead of the file name. self . qdata = 'qdata.txt' if kwargs . get ( 'qdata' , False ) else None # Whether to calculate or read a Hessian matrix. self . hessian = kwargs . get ( 'hessian' , None ) if self . hessian is None : # Default is to calculate Hessian in the first step if searching for a transition state. # Otherwise the default is to never calculate the Hessian. if self . transition : self . hessian = 'first' else : self . hessian = 'never' if self . hessian . startswith ( 'file:' ): if os . path . exists ( self . hessian [ 5 :]): # If a path is provided for reading a Hessian file, read it now. self . hess_data = np . loadtxt ( self . hessian [ 5 :]) else : raise IOError ( \"No Hessian data file found at %s \" % self . hessian ) elif self . hessian . lower () in [ 'never' , 'first' , 'each' , 'stop' , 'last' , 'first+last' ]: self . hessian = self . hessian . lower () else : raise RuntimeError ( \"Hessian command line argument can only be never, first, last, first+last, each, stop, or file:<path>\" ) # Perform a frequency analysis whenever a cartesian Hessian is computed self . frequency = kwargs . get ( 'frequency' , None ) if self . frequency is None : self . frequency = True # Temperature and pressure for harmonic free energy self . temperature , self . pressure = kwargs . get ( 'thermo' , [ 300.0 , 1.0 ]) # Number of desired samples from Wigner distribution self . wigner = kwargs . get ( 'wigner' , 0 ) if self . wigner and not self . frequency : raise ParamError ( 'Wigner sampling requires frequency analysis' ) # Reset Hessian to guess whenever eigenvalues drop below epsilon self . reset = kwargs . get ( 'reset' , None ) if self . reset is None : self . reset = not ( self . transition or self . meci or self . hessian == 'each' ) And convergence criteria: def convergence_criteria ( self , ** kwargs ): criteria = kwargs . get ( 'converge' , []) if len ( criteria ) % 2 != 0 : raise RuntimeError ( 'Please pass an even number of options to --converge' ) for i in range ( int ( len ( criteria ) / 2 )): key = 'convergence_' + criteria [ 2 * i ] . lower () try : val = float ( criteria [ 2 * i + 1 ]) logger . info ( 'Using convergence criteria: %s %.2e \\n ' % ( key , val )) except ValueError : # This must be a set val = str ( criteria [ 2 * i + 1 ]) logger . info ( 'Using convergence criteria set: %s %s \\n ' % ( key , val )) kwargs [ key ] = val # convergence dictionary to store criteria stored in order of energy, grms, gmax, drms, dmax # 'GAU' contains the default convergence criteria that are used when nothing is passed. convergence_sets = { 'GAU' : [ 1e-6 , 3e-4 , 4.5e-4 , 1.2e-3 , 1.8e-3 ], 'NWCHEM_LOOSE' : [ 1e-6 , 3e-3 , 4.5e-3 , 3.6e-3 , 5.4e-3 ], 'GAU_LOOSE' : [ 1e-6 , 1.7e-3 , 2.5e-3 , 6.7e-3 , 1e-2 ], 'TURBOMOLE' : [ 1e-6 , 5e-4 , 1e-3 , 5.0e-4 , 1e-3 ], 'INTERFRAG_TIGHT' : [ 1e-6 , 1e-5 , 1.5e-5 , 4.0e-4 , 6.0e-4 ], 'GAU_TIGHT' : [ 1e-6 , 1e-5 , 1.5e-5 , 4e-5 , 6e-5 ], 'GAU_VERYTIGHT' : [ 1e-6 , 1e-6 , 2e-6 , 4e-6 , 6e-6 ]} # Q-Chem style convergence criteria (i.e. gradient and either energy or displacement) self . qccnv = kwargs . get ( 'qccnv' , False ) # Molpro style convergence criteria (i.e. gradient and either energy or displacement, with different defaults) self . molcnv = kwargs . get ( 'molcnv' , False ) # Check if there is a convergence set passed else use the default set_name = kwargs . get ( 'convergence_set' , 'GAU' ) . upper () # If we have extra keywords apply them here else use the set # Convergence criteria in a.u. and Angstrom self . Convergence_energy = kwargs . get ( 'convergence_energy' , convergence_sets [ set_name ][ 0 ]) self . Convergence_grms = kwargs . get ( 'convergence_grms' , convergence_sets [ set_name ][ 1 ]) self . Convergence_gmax = kwargs . get ( 'convergence_gmax' , convergence_sets [ set_name ][ 2 ]) self . Convergence_drms = kwargs . get ( 'convergence_drms' , convergence_sets [ set_name ][ 3 ]) self . Convergence_dmax = kwargs . get ( 'convergence_dmax' , convergence_sets [ set_name ][ 4 ]) # Convergence criteria that are only used if molconv is set to True self . Convergence_molpro_gmax = kwargs . get ( 'convergence_molpro_gmax' , 3e-4 ) self . Convergence_molpro_dmax = kwargs . get ( 'convergence_molpro_dmax' , 1.2e-3 )","title":"Geometry Optimization"},{"location":"tutorial/geometry_optimization/#geometry-optimization","text":"","title":"Geometry Optimization"},{"location":"tutorial/geometry_optimization/#basic-working-example","text":"Create a Molecule Define parameters for the compute engine Define the optimization parameters for the optimizer and specify the compute engine Specify the optimizer to run from pprint import pprint from tccloud import TCClient from tccloud.models import Molecule , OptimizationInput , QCInputSpecification client = TCClient () water = Molecule . from_data ( \"pubchem:water\" ) input_spec = QCInputSpecification ( model = { \"method\" : \"b3lyp\" , \"basis\" : \"6-31g\" }, # Keywords for the compute engine (e.g., psi4, terachem_fe) keywords = {}, ) opt_input = OptimizationInput ( initial_molecule = water , input_specification = input_spec , # Trajectory molecules to include in result, may be one of: # 'all' or 'initial_and_final' or 'final' or 'none' protocols = { \"trajectory\" : \"all\" }, # Must define compute engine \"program\": \"engine_name\" # Define keywords for optimizer (pyberny or geomeTRIC) keywords = { \"program\" : \"terachem_fe\" , \"maxsteps\" : 3 }, ) # Optimizer can be \"berny\" or \"geometric\" future_result = client . compute_procedure ( opt_input , \"berny\" ) result = future_result . get () if result . success : print ( \"Optimization succeeded!\" ) # Will be OptimizationResult object print ( result ) # The final molecule of the geometry optimization print ( result . final_molecule ) # Initial molecule print ( result . initial_molecule ) # A list of ordered AtomicResult objects for each step in the optimization print ( result . trajectory ) # A list of ordered energies for each step in the optimization print ( result . energies ) else : print ( \"Optimization failed!\" ) # Will be FailedOperation object print ( result ) # Error information print ( result . error ) # Detailed error message pprint ( result . error . error_message )","title":"Basic Working Example"},{"location":"tutorial/geometry_optimization/#using-force-fields","text":"rdkit can be specified as a compute backend to perform optimizations using force field methods instead of quantum chemistry backends. To use rdkit force field methods simply modify the model specification and program specification as shown below. Also note that rdkit requires the molecular connectivity to be defined. # Hack to quickly drop in water's connectivity water = Molecule . from_data ( \"pubchem:water\" ) water = Molecule ( ** { ** water . dict (), \"connectivity\" : [( 0 , 1 , 1.0 ), ( 0 , 2 , 1.0 )]}) input_spec = QCInputSpecification ( ... model = { \"method\" : \"UFF\" } # or any other force field ) opt_input = OptimizationInput ( ... keywords = { \"program\" : \"rdkit\" }, ) future_result = client . compute_procedure ( opt_input , \"geometric\" )","title":"Using Force Fields"},{"location":"tutorial/geometry_optimization/#berny-specifics","text":"The berny procedure uses the pyberny package to perform a geometry optimization. berny specific keywords are subject to change as the berny package evolves, but for simplicity a short list is included here with default values noted: Keyword Description Default Value maxsteps Maximum number of steps in the optimization 100 gradientmax Convergence criteria (AU) 0.45e-3 gradientrms Convergence criteria (AU) 0.15e-3 stepmax Step in internal coordinates, assuming radian units for angles (AU) 1.8e-3 steprms Step in internal coordinates, assuming radian units for angles (AU) 0.45e-3 trust Initial trust radius in AU. It is the maximum RMS of the quadratic step 0.3 dihedral Form dihedral angles True superweakdih Form dihedral angles containing two or more noncovalent bonds False","title":"Berny Specifics"},{"location":"tutorial/geometry_optimization/#geometric-specifics","text":"The geometric procedure uses the geomeTRIC package to perform a geometry optimization. geomeTRIC specific keywords are subject to change as the geomeTRIC package evolves. Since geomeTRIC has considerably more keywords, here's the source code that defines varous parameters for an optimization. Keywords noted below can be included in the OptimizationInput keywords dictionary. If these options are overwhelming, keep in mind you can run both the berny and geometric optimizers without any keywords and the optimizers will use sensible defaults. class OptParams ( object ): \"\"\" Container for optimization parameters. The parameters used to be contained in the command-line \"args\", but this was dropped in order to call Optimize() from another script. \"\"\" def __init__ ( self , ** kwargs ): # Whether we are optimizing for a transition state. This changes a number of default parameters. self . transition = kwargs . get ( 'transition' , False ) # CI optimizations sometimes require tiny steps self . meci = kwargs . get ( 'meci' , False ) # Handle convergence criteria; this edits the kwargs self . convergence_criteria ( ** kwargs ) # Threshold (in a.u. / rad) for activating alternative algorithm that enforces precise constraint satisfaction self . enforce = kwargs . get ( 'enforce' , 0.0 ) # Small eigenvalue threshold self . epsilon = kwargs . get ( 'epsilon' , 1e-5 ) # Interval for checking the coordinate system for changes self . check = kwargs . get ( 'check' , 0 ) # More verbose printout self . verbose = kwargs . get ( 'verbose' , False ) # Starting value of the trust radius # Because TS optimization is experimental, use conservative trust radii self . trust = kwargs . get ( 'trust' , 0.01 if self . transition else 0.1 ) # Maximum value of trust radius self . tmax = kwargs . get ( 'tmax' , 0.03 if self . transition else 0.3 ) # Minimum value of the trust radius self . tmin = kwargs . get ( 'tmin' , 0.0 if ( self . transition or self . meci ) else min ( 1.2e-3 , self . Convergence_drms )) # Minimum size of a step that can be rejected self . thre_rj = kwargs . get ( 'thre_rj' , 1e-4 if ( self . transition or self . meci ) else 1e-2 ) # Sanity checks on trust radius if self . tmax < self . tmin : raise ParamError ( \"Max trust radius must be larger than min\" ) # The trust radius should not be outside (tmin, tmax) self . trust = min ( self . tmax , self . trust ) self . trust = max ( self . tmin , self . trust ) # Maximum number of optimization cycles self . maxiter = kwargs . get ( 'maxiter' , 300 ) # Use updated constraint algorithm implemented 2019-03-20 self . conmethod = kwargs . get ( 'conmethod' , 0 ) # Write Hessian matrix at optimized structure to text file self . write_cart_hess = kwargs . get ( 'write_cart_hess' , None ) # Output .xyz file name may be set separately in # run_optimizer() prior to calling Optimize(). self . xyzout = kwargs . get ( 'xyzout' , None ) # Name of the qdata.txt file to be written. # The CLI is designed so the user passes true/false instead of the file name. self . qdata = 'qdata.txt' if kwargs . get ( 'qdata' , False ) else None # Whether to calculate or read a Hessian matrix. self . hessian = kwargs . get ( 'hessian' , None ) if self . hessian is None : # Default is to calculate Hessian in the first step if searching for a transition state. # Otherwise the default is to never calculate the Hessian. if self . transition : self . hessian = 'first' else : self . hessian = 'never' if self . hessian . startswith ( 'file:' ): if os . path . exists ( self . hessian [ 5 :]): # If a path is provided for reading a Hessian file, read it now. self . hess_data = np . loadtxt ( self . hessian [ 5 :]) else : raise IOError ( \"No Hessian data file found at %s \" % self . hessian ) elif self . hessian . lower () in [ 'never' , 'first' , 'each' , 'stop' , 'last' , 'first+last' ]: self . hessian = self . hessian . lower () else : raise RuntimeError ( \"Hessian command line argument can only be never, first, last, first+last, each, stop, or file:<path>\" ) # Perform a frequency analysis whenever a cartesian Hessian is computed self . frequency = kwargs . get ( 'frequency' , None ) if self . frequency is None : self . frequency = True # Temperature and pressure for harmonic free energy self . temperature , self . pressure = kwargs . get ( 'thermo' , [ 300.0 , 1.0 ]) # Number of desired samples from Wigner distribution self . wigner = kwargs . get ( 'wigner' , 0 ) if self . wigner and not self . frequency : raise ParamError ( 'Wigner sampling requires frequency analysis' ) # Reset Hessian to guess whenever eigenvalues drop below epsilon self . reset = kwargs . get ( 'reset' , None ) if self . reset is None : self . reset = not ( self . transition or self . meci or self . hessian == 'each' ) And convergence criteria: def convergence_criteria ( self , ** kwargs ): criteria = kwargs . get ( 'converge' , []) if len ( criteria ) % 2 != 0 : raise RuntimeError ( 'Please pass an even number of options to --converge' ) for i in range ( int ( len ( criteria ) / 2 )): key = 'convergence_' + criteria [ 2 * i ] . lower () try : val = float ( criteria [ 2 * i + 1 ]) logger . info ( 'Using convergence criteria: %s %.2e \\n ' % ( key , val )) except ValueError : # This must be a set val = str ( criteria [ 2 * i + 1 ]) logger . info ( 'Using convergence criteria set: %s %s \\n ' % ( key , val )) kwargs [ key ] = val # convergence dictionary to store criteria stored in order of energy, grms, gmax, drms, dmax # 'GAU' contains the default convergence criteria that are used when nothing is passed. convergence_sets = { 'GAU' : [ 1e-6 , 3e-4 , 4.5e-4 , 1.2e-3 , 1.8e-3 ], 'NWCHEM_LOOSE' : [ 1e-6 , 3e-3 , 4.5e-3 , 3.6e-3 , 5.4e-3 ], 'GAU_LOOSE' : [ 1e-6 , 1.7e-3 , 2.5e-3 , 6.7e-3 , 1e-2 ], 'TURBOMOLE' : [ 1e-6 , 5e-4 , 1e-3 , 5.0e-4 , 1e-3 ], 'INTERFRAG_TIGHT' : [ 1e-6 , 1e-5 , 1.5e-5 , 4.0e-4 , 6.0e-4 ], 'GAU_TIGHT' : [ 1e-6 , 1e-5 , 1.5e-5 , 4e-5 , 6e-5 ], 'GAU_VERYTIGHT' : [ 1e-6 , 1e-6 , 2e-6 , 4e-6 , 6e-6 ]} # Q-Chem style convergence criteria (i.e. gradient and either energy or displacement) self . qccnv = kwargs . get ( 'qccnv' , False ) # Molpro style convergence criteria (i.e. gradient and either energy or displacement, with different defaults) self . molcnv = kwargs . get ( 'molcnv' , False ) # Check if there is a convergence set passed else use the default set_name = kwargs . get ( 'convergence_set' , 'GAU' ) . upper () # If we have extra keywords apply them here else use the set # Convergence criteria in a.u. and Angstrom self . Convergence_energy = kwargs . get ( 'convergence_energy' , convergence_sets [ set_name ][ 0 ]) self . Convergence_grms = kwargs . get ( 'convergence_grms' , convergence_sets [ set_name ][ 1 ]) self . Convergence_gmax = kwargs . get ( 'convergence_gmax' , convergence_sets [ set_name ][ 2 ]) self . Convergence_drms = kwargs . get ( 'convergence_drms' , convergence_sets [ set_name ][ 3 ]) self . Convergence_dmax = kwargs . get ( 'convergence_dmax' , convergence_sets [ set_name ][ 4 ]) # Convergence criteria that are only used if molconv is set to True self . Convergence_molpro_gmax = kwargs . get ( 'convergence_molpro_gmax' , 3e-4 ) self . Convergence_molpro_dmax = kwargs . get ( 'convergence_molpro_dmax' , 1.2e-3 )","title":"geomeTRIC Specifics"},{"location":"tutorial/terachem_cloud_algorithms/","text":"TeraChem Cloud Algorithms \ud83d\udd17 TeraChem Cloud implements some of its own concurrent algorithms that leverage its horizontally scalable backend infrastructure. These include a parallel hessian algorithm and parallel frequency analysis algorithm. To use them submit either a hessian or properties computation to TeraChem Cloud using tcc as the engine. Keywords specific to these algorithms are added to .extras['tcc:keywords'] . None are required and all are optional. Hessian \ud83d\udd17 from tccloud import TCClient from tccloud.models import AtomicInput , Molecule client = TCClient () water = Molecule . from_data ( \"pubchem:water\" ) # Hessian computation atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"hessian\" , extras = { \"tcc:keywords\" : { \"dh\" : 5e-3 , # OPTIONAL: displacement for finite difference }, }, ) future_result = client . compute ( atomic_input , engine = \"tcc\" ) result = future_result . get () # AtomicResult object containing all returned data print ( result ) # The hessian matrix print ( result . return_result ) Frequency Analysis \ud83d\udd17 from tccloud import TCClient from tccloud.models import AtomicInput , Molecule client = TCClient () water = Molecule . from_data ( \"pubchem:water\" ) # Frequency Analysis atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"properties\" , extras = { \"tcc:keywords\" : { \"temperature\" : 380.0 , # OPTIONAL: temperature for free energy calculation }, }, ) future_result = client . compute ( atomic_input , engine = \"tcc\" ) result = future_result . get () # AtomicResult object containing all returned data print ( result ) # Dictionary containing frequency analysis results print ( result . return_result ) Keywords \ud83d\udd17 Keywords are passed in AtomicInput.extras['tcc:keywords'] . Keyword Type Description Default Value gradient_engine str The program to use for gradient calculations terachem_fe dh float Displacement for gradient geometries for finite difference 5.0e-3 energy float Electronic energy passed to the harmonic free energy module 0.0 temperature float Temperature passed to the harmonic free energy module 300.0 pressure float Pressure passed to the harmonic free energy module 1.0","title":"TeraChem Cloud Algorithms"},{"location":"tutorial/terachem_cloud_algorithms/#terachem-cloud-algorithms","text":"TeraChem Cloud implements some of its own concurrent algorithms that leverage its horizontally scalable backend infrastructure. These include a parallel hessian algorithm and parallel frequency analysis algorithm. To use them submit either a hessian or properties computation to TeraChem Cloud using tcc as the engine. Keywords specific to these algorithms are added to .extras['tcc:keywords'] . None are required and all are optional.","title":"TeraChem Cloud Algorithms"},{"location":"tutorial/terachem_cloud_algorithms/#hessian","text":"from tccloud import TCClient from tccloud.models import AtomicInput , Molecule client = TCClient () water = Molecule . from_data ( \"pubchem:water\" ) # Hessian computation atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"hessian\" , extras = { \"tcc:keywords\" : { \"dh\" : 5e-3 , # OPTIONAL: displacement for finite difference }, }, ) future_result = client . compute ( atomic_input , engine = \"tcc\" ) result = future_result . get () # AtomicResult object containing all returned data print ( result ) # The hessian matrix print ( result . return_result )","title":"Hessian"},{"location":"tutorial/terachem_cloud_algorithms/#frequency-analysis","text":"from tccloud import TCClient from tccloud.models import AtomicInput , Molecule client = TCClient () water = Molecule . from_data ( \"pubchem:water\" ) # Frequency Analysis atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"properties\" , extras = { \"tcc:keywords\" : { \"temperature\" : 380.0 , # OPTIONAL: temperature for free energy calculation }, }, ) future_result = client . compute ( atomic_input , engine = \"tcc\" ) result = future_result . get () # AtomicResult object containing all returned data print ( result ) # Dictionary containing frequency analysis results print ( result . return_result )","title":"Frequency Analysis"},{"location":"tutorial/terachem_cloud_algorithms/#keywords","text":"Keywords are passed in AtomicInput.extras['tcc:keywords'] . Keyword Type Description Default Value gradient_engine str The program to use for gradient calculations terachem_fe dh float Displacement for gradient geometries for finite difference 5.0e-3 energy float Electronic energy passed to the harmonic free energy module 0.0 temperature float Temperature passed to the harmonic free energy module 300.0 pressure float Pressure passed to the harmonic free energy module 1.0","title":"Keywords"}]}