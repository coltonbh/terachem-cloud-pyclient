{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tccloud \ud83d\udd17 A Python Client for TeraChem Cloud. tccloud is a python client that makes performing quantum chemistry calculations easy, fast, and fun. All input and output data structures are based on the QCSchema specification designed by The Molecular Sciences Software Institute . The client provides a simple, yet powerful interface to perform quantum chemistry calculation using nothing but modern python and an internet connection. Compute is generously provided free of charge by the TeraChem Cloud project. Requirements \ud83d\udd17 Python 3.6+ tccloud stands on the shoulders of giants. It internally depends upon QCElemental , httpx , and toml . The AtomicInput , Molecule , Model , and AtomicResult models used throughout the package come directly from QCElemental . They are included in tccloud.models for your convenience. Installation \ud83d\udd17 pip install tccloud Example \ud83d\udd17 The Absolute Minimum \ud83d\udd17 Create a TeraChem Cloud account at https://tccloud.mtzlab.com/signup . Instantiate a client Configure client (only required the very first time you use TCClient ) >>> from tccloud import TCClient >>> client = TCClient () >>> client . configure () # only run the very first time you use TCClient # See supported compute engines >>> client . supported_engines [ 'psi4' , 'terachem_pbs' , ... ] # Test connection to TeraChem Cloud >>> client . hello_world ( \"Colton\" ) 'Welcome to TeraChem Cloud, Colton' Create a Molecule More details about the Molecule object can be found here and here . Molecules can be created from pubchem , local files, or using pure python. >>> from tccloud.models import Molecule >>> water = Molecule . from_data ( \"pubchem:water\" ) Specify your compute job using an AtomicInput object More details about the AtomicInput object can be found here . >>> from tccloud.models import AtomicInput >>> atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"energy\" ) Submit a computation, specify a target quantum chemistry engine, and get back an AtomicResult >>> future_result = client . compute ( atomic_input , engine = \"terachem_pbs\" ) >>> future_result . status 'STARTED' # Get result >>> result = future_result . get () # Successful computation >>> result . success True >>> result AtomicResult ( driver = 'energy' , model = { 'method' : 'B3LYP' , 'basis' : '6-31g' }, molecule_hash = 'b6ec4fa' ) >>> result . return_result - 76.38545794119997 # Failed computation >>> result . success False # View result >>> result FailedOperation ( error = ComputeError ( error_type = 'input_error' , error_message = 'QCEngine Input Error: Traceback (most recent call last):...' )) >>> from pprint import pprint >>> pprint ( result . error . error_message ) Putting it all together >>> from tccloud import TCClient >>> from tccloud.models import AtomicInput , Molecule >>> client = TCClient () >>> water = Molecule . from_data ( \"pubchem:water\" ) >>> atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"energy\" ) >>> future_result = client . compute ( atomic_input , engine = \"terachem_pbs\" ) >>> result = future_result . get () >>> result AtomicResult ( driver = 'energy' , model = { 'method' : 'B3LYP' , 'basis' : '6-31g' }, molecule_hash = 'b6ec4fa' ) >>> result . return_result - 76.38545794119997 Licence \ud83d\udd17 This project is licensed under the terms of the MIT license.","title":"tccloud"},{"location":"#tccloud","text":"A Python Client for TeraChem Cloud. tccloud is a python client that makes performing quantum chemistry calculations easy, fast, and fun. All input and output data structures are based on the QCSchema specification designed by The Molecular Sciences Software Institute . The client provides a simple, yet powerful interface to perform quantum chemistry calculation using nothing but modern python and an internet connection. Compute is generously provided free of charge by the TeraChem Cloud project.","title":"tccloud"},{"location":"#requirements","text":"Python 3.6+ tccloud stands on the shoulders of giants. It internally depends upon QCElemental , httpx , and toml . The AtomicInput , Molecule , Model , and AtomicResult models used throughout the package come directly from QCElemental . They are included in tccloud.models for your convenience.","title":"Requirements"},{"location":"#installation","text":"pip install tccloud","title":"Installation"},{"location":"#example","text":"","title":"Example"},{"location":"#the-absolute-minimum","text":"Create a TeraChem Cloud account at https://tccloud.mtzlab.com/signup . Instantiate a client Configure client (only required the very first time you use TCClient ) >>> from tccloud import TCClient >>> client = TCClient () >>> client . configure () # only run the very first time you use TCClient # See supported compute engines >>> client . supported_engines [ 'psi4' , 'terachem_pbs' , ... ] # Test connection to TeraChem Cloud >>> client . hello_world ( \"Colton\" ) 'Welcome to TeraChem Cloud, Colton' Create a Molecule More details about the Molecule object can be found here and here . Molecules can be created from pubchem , local files, or using pure python. >>> from tccloud.models import Molecule >>> water = Molecule . from_data ( \"pubchem:water\" ) Specify your compute job using an AtomicInput object More details about the AtomicInput object can be found here . >>> from tccloud.models import AtomicInput >>> atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"energy\" ) Submit a computation, specify a target quantum chemistry engine, and get back an AtomicResult >>> future_result = client . compute ( atomic_input , engine = \"terachem_pbs\" ) >>> future_result . status 'STARTED' # Get result >>> result = future_result . get () # Successful computation >>> result . success True >>> result AtomicResult ( driver = 'energy' , model = { 'method' : 'B3LYP' , 'basis' : '6-31g' }, molecule_hash = 'b6ec4fa' ) >>> result . return_result - 76.38545794119997 # Failed computation >>> result . success False # View result >>> result FailedOperation ( error = ComputeError ( error_type = 'input_error' , error_message = 'QCEngine Input Error: Traceback (most recent call last):...' )) >>> from pprint import pprint >>> pprint ( result . error . error_message ) Putting it all together >>> from tccloud import TCClient >>> from tccloud.models import AtomicInput , Molecule >>> client = TCClient () >>> water = Molecule . from_data ( \"pubchem:water\" ) >>> atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"energy\" ) >>> future_result = client . compute ( atomic_input , engine = \"terachem_pbs\" ) >>> result = future_result . get () >>> result AtomicResult ( driver = 'energy' , model = { 'method' : 'B3LYP' , 'basis' : '6-31g' }, molecule_hash = 'b6ec4fa' ) >>> result . return_result - 76.38545794119997","title":"The Absolute Minimum"},{"location":"#licence","text":"This project is licensed under the terms of the MIT license.","title":"Licence"},{"location":"CHANGELOG/","text":"Changelog \ud83d\udd17 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . unreleased \ud83d\udd17 Added \ud83d\udd17 Batch compute for both compute() and compute_procedure() methods FutureResultGroup for batch computations Change \ud83d\udd17 Added pydantic BaseModel as base for FutureResult objects. 0.2.2 \ud83d\udd17 Added \ud83d\udd17 Extended documentation to include a Code Reference section and much more comprehensive documentation of the main objects. Added compute_procedure to TCClient for geometry optimizations. Added TCClient.version property for quick version checks. 0.2.1 - 2021-03-05 \ud83d\udd17 Added \ud83d\udd17 Changelog User documentation Website for documentation 0.2.0 - 2021-02-26 \ud83d\udd17 Added \ud83d\udd17 Added TaskStatus enum to hold all task statuses. Basic documentation on main classes. core_decisions.md to document thinking behind architectural choices. Changed \ud83d\udd17 FutureResult.get() to return either an AtomicResult or a FailedComputation Simplified README.md overview to use dictionaries instead of classes. Results in simpler tutorial with fewer imports. 0.1.1 - 2021-01-22 \ud83d\udd17 Added \ud83d\udd17 TCClient that can manage credentials, submit AtomicInput computations, and retrieve AtomicResult output from TeraChem Cloud. _RequestsClient class that handles all network requests to TeraChem Cloud server FutureResults object that is created from a task_id and can be used to retrieve a result once finished.","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"","title":"unreleased"},{"location":"CHANGELOG/#added","text":"Batch compute for both compute() and compute_procedure() methods FutureResultGroup for batch computations","title":"Added"},{"location":"CHANGELOG/#change","text":"Added pydantic BaseModel as base for FutureResult objects.","title":"Change"},{"location":"CHANGELOG/#022","text":"","title":"0.2.2"},{"location":"CHANGELOG/#added_1","text":"Extended documentation to include a Code Reference section and much more comprehensive documentation of the main objects. Added compute_procedure to TCClient for geometry optimizations. Added TCClient.version property for quick version checks.","title":"Added"},{"location":"CHANGELOG/#021-2021-03-05","text":"","title":"0.2.1 - 2021-03-05"},{"location":"CHANGELOG/#added_2","text":"Changelog User documentation Website for documentation","title":"Added"},{"location":"CHANGELOG/#020-2021-02-26","text":"","title":"0.2.0 - 2021-02-26"},{"location":"CHANGELOG/#added_3","text":"Added TaskStatus enum to hold all task statuses. Basic documentation on main classes. core_decisions.md to document thinking behind architectural choices.","title":"Added"},{"location":"CHANGELOG/#changed","text":"FutureResult.get() to return either an AtomicResult or a FailedComputation Simplified README.md overview to use dictionaries instead of classes. Results in simpler tutorial with fewer imports.","title":"Changed"},{"location":"CHANGELOG/#011-2021-01-22","text":"","title":"0.1.1 - 2021-01-22"},{"location":"CHANGELOG/#added_4","text":"TCClient that can manage credentials, submit AtomicInput computations, and retrieve AtomicResult output from TeraChem Cloud. _RequestsClient class that handles all network requests to TeraChem Cloud server FutureResults object that is created from a task_id and can be used to retrieve a result once finished.","title":"Added"},{"location":"code_reference/AtomicInput/","text":"AtomicInput \ud83d\udd17 The MolSSI Quantum Chemistry Schema Parameters \ud83d\udd17 id : str, Optional The optional ID for the computation. schema_name : ConstrainedStrValue, Default: qcschema_input The QCSchema specification this model conforms to. Explicitly fixed as qcschema_input. schema_version : int, Default: 1 The version number of schema_name to which this model conforms. molecule : :class: Molecule , Default: Ellipsis The molecule to use in the computation. driver : {energy,gradient,hessian,properties}, Default: Ellipsis Allowed computation driver values. model : :class: Model , Default: Ellipsis The computational molecular sciences model to run. keywords : Dict[str, Any], Default: {} The program-specific keywords to be used. protocols : :class: AtomicResultProtocols , Optional Protocols regarding the manipulation of computational result data. extras : Dict[str, Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. provenance : :class: Provenance , Optional Provenance information. Attributes \ud83d\udd17 driver : DriverEnum pydantic-field required \ud83d\udd17 Allowed computation driver values. extras : Dict [ str , Any ] pydantic-field \ud83d\udd17 Additional information to bundle with the computation. Use for schema development and scratch space. fields : Dict [ str , pydantic . fields . ModelField ] inherited property readonly \ud83d\udd17 id : str pydantic-field \ud83d\udd17 The optional ID for the computation. keywords : Dict [ str , Any ] pydantic-field \ud83d\udd17 The program-specific keywords to be used. model : Model pydantic-field required \ud83d\udd17 The computational molecular sciences model to run. molecule : Molecule pydantic-field required \ud83d\udd17 The molecule to use in the computation. protocols : AtomicResultProtocols pydantic-field \ud83d\udd17 Protocols regarding the manipulation of computational result data. provenance : Provenance pydantic-field \ud83d\udd17 Provenance information. schema_name : ConstrainedStrValue pydantic-field \ud83d\udd17 The QCSchema specification this model conforms to. Explicitly fixed as qcschema_input. schema_version : int pydantic-field \ud83d\udd17 The version number of schema_name to which this model conforms. Config \ud83d\udd17 allow_mutation : bool inherited \ud83d\udd17 extra : str inherited \ud83d\udd17 force_skip_defaults : bool inherited \ud83d\udd17 json_encoders : Dict [ str , Any ] inherited \ud83d\udd17 serialize_default_excludes : Set inherited \ud83d\udd17 serialize_skip_defaults : bool inherited \ud83d\udd17 schema_extra ( schema , model ) \ud83d\udd17 Source code in qcelemental/models/results.py def schema_extra ( schema , model ): schema [ \"$schema\" ] = qcschema_draft Methods \ud83d\udd17 compare ( self , other : Union [ ProtoModel , pydantic . main . BaseModel ], ** kwargs ) -> bool inherited \ud83d\udd17 Compares the current object to the provided object recursively. Parameters \ud83d\udd17 other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive . Returns \ud83d\udd17 bool True if the objects match. Source code in qcelemental/models/results.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs ) dict ( self , ** kwargs ) -> Dict [ str , Any ] inherited \ud83d\udd17 Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/results.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" ) json ( self , ** kwargs ) inherited \ud83d\udd17 Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/results.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs ) serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None ) -> Union [ bytes , str ] inherited \ud83d\udd17 Generates a serialized representation of the model Parameters \ud83d\udd17 encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None . Returns \ud83d\udd17 Union[bytes, str] The serialized model. Source code in qcelemental/models/results.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"AtomicInput"},{"location":"code_reference/AtomicInput/#atomicinput","text":"The MolSSI Quantum Chemistry Schema","title":"AtomicInput"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput--parameters","text":"id : str, Optional The optional ID for the computation. schema_name : ConstrainedStrValue, Default: qcschema_input The QCSchema specification this model conforms to. Explicitly fixed as qcschema_input. schema_version : int, Default: 1 The version number of schema_name to which this model conforms. molecule : :class: Molecule , Default: Ellipsis The molecule to use in the computation. driver : {energy,gradient,hessian,properties}, Default: Ellipsis Allowed computation driver values. model : :class: Model , Default: Ellipsis The computational molecular sciences model to run. keywords : Dict[str, Any], Default: {} The program-specific keywords to be used. protocols : :class: AtomicResultProtocols , Optional Protocols regarding the manipulation of computational result data. extras : Dict[str, Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. provenance : :class: Provenance , Optional Provenance information.","title":"Parameters"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput-attributes","text":"","title":"Attributes"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.driver","text":"Allowed computation driver values.","title":"driver"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.extras","text":"Additional information to bundle with the computation. Use for schema development and scratch space.","title":"extras"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.fields","text":"","title":"fields"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.id","text":"The optional ID for the computation.","title":"id"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.keywords","text":"The program-specific keywords to be used.","title":"keywords"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.model","text":"The computational molecular sciences model to run.","title":"model"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.molecule","text":"The molecule to use in the computation.","title":"molecule"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.protocols","text":"Protocols regarding the manipulation of computational result data.","title":"protocols"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.provenance","text":"Provenance information.","title":"provenance"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.schema_name","text":"The QCSchema specification this model conforms to. Explicitly fixed as qcschema_input.","title":"schema_name"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.schema_version","text":"The version number of schema_name to which this model conforms.","title":"schema_version"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.Config","text":"","title":"Config"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.Config.allow_mutation","text":"","title":"allow_mutation"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.Config.extra","text":"","title":"extra"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.Config.force_skip_defaults","text":"","title":"force_skip_defaults"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.Config.json_encoders","text":"","title":"json_encoders"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.Config.serialize_default_excludes","text":"","title":"serialize_default_excludes"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.Config.serialize_skip_defaults","text":"","title":"serialize_skip_defaults"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.Config.schema_extra","text":"Source code in qcelemental/models/results.py def schema_extra ( schema , model ): schema [ \"$schema\" ] = qcschema_draft","title":"schema_extra()"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput-methods","text":"","title":"Methods"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.compare","text":"Compares the current object to the provided object recursively.","title":"compare()"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.compare--parameters","text":"other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive .","title":"Parameters"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.compare--returns","text":"bool True if the objects match. Source code in qcelemental/models/results.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs )","title":"Returns"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.dict","text":"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/results.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" )","title":"dict()"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.json","text":"Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/results.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs )","title":"json()"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.serialize","text":"Generates a serialized representation of the model","title":"serialize()"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.serialize--parameters","text":"encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None .","title":"Parameters"},{"location":"code_reference/AtomicInput/#qcelemental.models.results.AtomicInput.serialize--returns","text":"Union[bytes, str] The serialized model. Source code in qcelemental/models/results.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Returns"},{"location":"code_reference/AtomicResult/","text":"AtomicResult \ud83d\udd17 Results from a CMS program execution. Parameters \ud83d\udd17 id : str, Optional The optional ID for the computation. schema_name : ConstrainedStrValue, Default: qcschema_output The QCSchema specification this model conforms to. Explicitly fixed as qcschema_output. schema_version : int, Default: 1 The version number of schema_name to which this model conforms. molecule : :class: Molecule , Default: Ellipsis The molecule to use in the computation. driver : {energy,gradient,hessian,properties}, Default: Ellipsis Allowed computation driver values. model : :class: Model , Default: Ellipsis The computational molecular sciences model to run. keywords : Dict[str, Any], Default: {} The program-specific keywords to be used. protocols : :class: AtomicResultProtocols , Optional Protocols regarding the manipulation of computational result data. extras : Dict[str, Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. provenance : :class: Provenance , Default: Ellipsis Provenance information. properties : :class: AtomicResultProperties , Default: Ellipsis Named properties of quantum chemistry computations following the MolSSI QCSchema. Notes ----- All arrays are stored flat but must be reshapable into the dimensions in attribute ``shape``, with abbreviations as follows: nao: number of atomic orbitals = calcinfo_nbasis nmo: number of molecular orbitals wavefunction : :class: WavefunctionProperties , Optional Wavefunction properties resulting from a computation. Matrix quantities are stored in column-major order. Presence and contents configurable by protocol. return_result : Union[float, Array, Dict[str, Any]], Default: Ellipsis The primary return specified by the driver field. Scalar if energy; array if gradient or hessian; dictionary with property keys if properties. stdout : str, Optional The primary logging output of the program, whether natively standard output or a file. Presence vs. absence (or null-ness?) configurable by protocol. stderr : str, Optional The standard error of the program execution. success : bool, Default: Ellipsis The success of program execution. If False, other fields may be blank. error : :class: ComputeError , Optional Complete description of the error from an unsuccessful program execution. Attributes \ud83d\udd17 driver : DriverEnum pydantic-field required \ud83d\udd17 Allowed computation driver values. error : ComputeError pydantic-field \ud83d\udd17 Complete description of the error from an unsuccessful program execution. extras : Dict [ str , Any ] pydantic-field \ud83d\udd17 Additional information to bundle with the computation. Use for schema development and scratch space. fields : Dict [ str , pydantic . fields . ModelField ] inherited property readonly \ud83d\udd17 id : str pydantic-field \ud83d\udd17 The optional ID for the computation. keywords : Dict [ str , Any ] pydantic-field \ud83d\udd17 The program-specific keywords to be used. model : Model pydantic-field required \ud83d\udd17 The computational molecular sciences model to run. molecule : Molecule pydantic-field required \ud83d\udd17 The molecule to use in the computation. properties : AtomicResultProperties pydantic-field required \ud83d\udd17 Named properties of quantum chemistry computations following the MolSSI QCSchema. Notes ----- All arrays are stored flat but must be reshapable into the dimensions in attribute ``shape``, with abbreviations as follows: nao: number of atomic orbitals = calcinfo_nbasis nmo: number of molecular orbitals protocols : AtomicResultProtocols pydantic-field \ud83d\udd17 Protocols regarding the manipulation of computational result data. provenance : Provenance pydantic-field required \ud83d\udd17 Provenance information. return_result : Union [ float , qcelemental . models . types . Array , Dict [ str , Any ]] pydantic-field required \ud83d\udd17 The primary return specified by the driver field. Scalar if energy; array if gradient or hessian; dictionary with property keys if properties. schema_name : ConstrainedStrValue pydantic-field \ud83d\udd17 The QCSchema specification this model conforms to. Explicitly fixed as qcschema_output. schema_version : int pydantic-field \ud83d\udd17 The version number of schema_name to which this model conforms. stderr : str pydantic-field \ud83d\udd17 The standard error of the program execution. stdout : str pydantic-field \ud83d\udd17 The primary logging output of the program, whether natively standard output or a file. Presence vs. absence (or null-ness?) configurable by protocol. success : bool pydantic-field required \ud83d\udd17 The success of program execution. If False, other fields may be blank. wavefunction : WavefunctionProperties pydantic-field \ud83d\udd17 Wavefunction properties resulting from a computation. Matrix quantities are stored in column-major order. Presence and contents configurable by protocol. Config inherited \ud83d\udd17 allow_mutation : bool inherited \ud83d\udd17 extra : str inherited \ud83d\udd17 force_skip_defaults : bool inherited \ud83d\udd17 json_encoders : Dict [ str , Any ] inherited \ud83d\udd17 serialize_default_excludes : Set inherited \ud83d\udd17 serialize_skip_defaults : bool inherited \ud83d\udd17 schema_extra ( schema , model ) \ud83d\udd17 Source code in qcelemental/models/results.py def schema_extra ( schema , model ): schema [ \"$schema\" ] = qcschema_draft Methods \ud83d\udd17 compare ( self , other : Union [ ProtoModel , pydantic . main . BaseModel ], ** kwargs ) -> bool inherited \ud83d\udd17 Compares the current object to the provided object recursively. Parameters \ud83d\udd17 other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive . Returns \ud83d\udd17 bool True if the objects match. Source code in qcelemental/models/results.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs ) dict ( self , ** kwargs ) -> Dict [ str , Any ] inherited \ud83d\udd17 Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/results.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" ) json ( self , ** kwargs ) inherited \ud83d\udd17 Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/results.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs ) serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None ) -> Union [ bytes , str ] inherited \ud83d\udd17 Generates a serialized representation of the model Parameters \ud83d\udd17 encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None . Returns \ud83d\udd17 Union[bytes, str] The serialized model. Source code in qcelemental/models/results.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"AtomicResult"},{"location":"code_reference/AtomicResult/#atomicresult","text":"Results from a CMS program execution.","title":"AtomicResult"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult--parameters","text":"id : str, Optional The optional ID for the computation. schema_name : ConstrainedStrValue, Default: qcschema_output The QCSchema specification this model conforms to. Explicitly fixed as qcschema_output. schema_version : int, Default: 1 The version number of schema_name to which this model conforms. molecule : :class: Molecule , Default: Ellipsis The molecule to use in the computation. driver : {energy,gradient,hessian,properties}, Default: Ellipsis Allowed computation driver values. model : :class: Model , Default: Ellipsis The computational molecular sciences model to run. keywords : Dict[str, Any], Default: {} The program-specific keywords to be used. protocols : :class: AtomicResultProtocols , Optional Protocols regarding the manipulation of computational result data. extras : Dict[str, Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. provenance : :class: Provenance , Default: Ellipsis Provenance information. properties : :class: AtomicResultProperties , Default: Ellipsis Named properties of quantum chemistry computations following the MolSSI QCSchema. Notes ----- All arrays are stored flat but must be reshapable into the dimensions in attribute ``shape``, with abbreviations as follows: nao: number of atomic orbitals = calcinfo_nbasis nmo: number of molecular orbitals wavefunction : :class: WavefunctionProperties , Optional Wavefunction properties resulting from a computation. Matrix quantities are stored in column-major order. Presence and contents configurable by protocol. return_result : Union[float, Array, Dict[str, Any]], Default: Ellipsis The primary return specified by the driver field. Scalar if energy; array if gradient or hessian; dictionary with property keys if properties. stdout : str, Optional The primary logging output of the program, whether natively standard output or a file. Presence vs. absence (or null-ness?) configurable by protocol. stderr : str, Optional The standard error of the program execution. success : bool, Default: Ellipsis The success of program execution. If False, other fields may be blank. error : :class: ComputeError , Optional Complete description of the error from an unsuccessful program execution.","title":"Parameters"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult-attributes","text":"","title":"Attributes"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.driver","text":"Allowed computation driver values.","title":"driver"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.error","text":"Complete description of the error from an unsuccessful program execution.","title":"error"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.extras","text":"Additional information to bundle with the computation. Use for schema development and scratch space.","title":"extras"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.fields","text":"","title":"fields"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.id","text":"The optional ID for the computation.","title":"id"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.keywords","text":"The program-specific keywords to be used.","title":"keywords"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.model","text":"The computational molecular sciences model to run.","title":"model"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.molecule","text":"The molecule to use in the computation.","title":"molecule"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.properties","text":"Named properties of quantum chemistry computations following the MolSSI QCSchema. Notes ----- All arrays are stored flat but must be reshapable into the dimensions in attribute ``shape``, with abbreviations as follows: nao: number of atomic orbitals = calcinfo_nbasis nmo: number of molecular orbitals","title":"properties"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.protocols","text":"Protocols regarding the manipulation of computational result data.","title":"protocols"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.provenance","text":"Provenance information.","title":"provenance"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.return_result","text":"The primary return specified by the driver field. Scalar if energy; array if gradient or hessian; dictionary with property keys if properties.","title":"return_result"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.schema_name","text":"The QCSchema specification this model conforms to. Explicitly fixed as qcschema_output.","title":"schema_name"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.schema_version","text":"The version number of schema_name to which this model conforms.","title":"schema_version"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.stderr","text":"The standard error of the program execution.","title":"stderr"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.stdout","text":"The primary logging output of the program, whether natively standard output or a file. Presence vs. absence (or null-ness?) configurable by protocol.","title":"stdout"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.success","text":"The success of program execution. If False, other fields may be blank.","title":"success"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.wavefunction","text":"Wavefunction properties resulting from a computation. Matrix quantities are stored in column-major order. Presence and contents configurable by protocol.","title":"wavefunction"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.Config","text":"","title":"Config"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.Config.allow_mutation","text":"","title":"allow_mutation"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.Config.extra","text":"","title":"extra"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.Config.force_skip_defaults","text":"","title":"force_skip_defaults"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.Config.json_encoders","text":"","title":"json_encoders"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.Config.serialize_default_excludes","text":"","title":"serialize_default_excludes"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.Config.serialize_skip_defaults","text":"","title":"serialize_skip_defaults"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.Config.schema_extra","text":"Source code in qcelemental/models/results.py def schema_extra ( schema , model ): schema [ \"$schema\" ] = qcschema_draft","title":"schema_extra()"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult-methods","text":"","title":"Methods"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.compare","text":"Compares the current object to the provided object recursively.","title":"compare()"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.compare--parameters","text":"other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive .","title":"Parameters"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.compare--returns","text":"bool True if the objects match. Source code in qcelemental/models/results.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs )","title":"Returns"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.dict","text":"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/results.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" )","title":"dict()"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.json","text":"Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/results.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs )","title":"json()"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.serialize","text":"Generates a serialized representation of the model","title":"serialize()"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.serialize--parameters","text":"encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None .","title":"Parameters"},{"location":"code_reference/AtomicResult/#qcelemental.models.results.AtomicResult.serialize--returns","text":"Union[bytes, str] The serialized model. Source code in qcelemental/models/results.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Returns"},{"location":"code_reference/ComputeError/","text":"ComputeError \ud83d\udd17 Complete description of the error from an unsuccessful program execution. Parameters \ud83d\udd17 error_type : str, Default: Ellipsis The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py error_message : str, Default: Ellipsis Text associated with the thrown error. This is often the backtrace, but it can contain additional information as well. extras : Dict[str, Any], Optional Additional information to bundle with the error. Attributes \ud83d\udd17 error_message : str pydantic-field required \ud83d\udd17 Text associated with the thrown error. This is often the backtrace, but it can contain additional information as well. error_type : str pydantic-field required \ud83d\udd17 The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py extras : Dict [ str , Any ] pydantic-field \ud83d\udd17 Additional information to bundle with the error. fields : Dict [ str , pydantic . fields . ModelField ] inherited property readonly \ud83d\udd17 Config \ud83d\udd17 Methods \ud83d\udd17 compare ( self , other : Union [ ProtoModel , pydantic . main . BaseModel ], ** kwargs ) -> bool inherited \ud83d\udd17 Compares the current object to the provided object recursively. Parameters \ud83d\udd17 other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive . Returns \ud83d\udd17 bool True if the objects match. Source code in qcelemental/models/common_models.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs ) dict ( self , ** kwargs ) -> Dict [ str , Any ] inherited \ud83d\udd17 Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/common_models.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" ) json ( self , ** kwargs ) inherited \ud83d\udd17 Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/common_models.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs ) serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None ) -> Union [ bytes , str ] inherited \ud83d\udd17 Generates a serialized representation of the model Parameters \ud83d\udd17 encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None . Returns \ud83d\udd17 Union[bytes, str] The serialized model. Source code in qcelemental/models/common_models.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"ComputeError"},{"location":"code_reference/ComputeError/#computeerror","text":"Complete description of the error from an unsuccessful program execution.","title":"ComputeError"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError--parameters","text":"error_type : str, Default: Ellipsis The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py error_message : str, Default: Ellipsis Text associated with the thrown error. This is often the backtrace, but it can contain additional information as well. extras : Dict[str, Any], Optional Additional information to bundle with the error.","title":"Parameters"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError-attributes","text":"","title":"Attributes"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.error_message","text":"Text associated with the thrown error. This is often the backtrace, but it can contain additional information as well.","title":"error_message"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.error_type","text":"The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py","title":"error_type"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.extras","text":"Additional information to bundle with the error.","title":"extras"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.fields","text":"","title":"fields"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.Config","text":"","title":"Config"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError-methods","text":"","title":"Methods"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.compare","text":"Compares the current object to the provided object recursively.","title":"compare()"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.compare--parameters","text":"other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive .","title":"Parameters"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.compare--returns","text":"bool True if the objects match. Source code in qcelemental/models/common_models.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs )","title":"Returns"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.dict","text":"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/common_models.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" )","title":"dict()"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.json","text":"Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/common_models.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs )","title":"json()"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.serialize","text":"Generates a serialized representation of the model","title":"serialize()"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.serialize--parameters","text":"encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None .","title":"Parameters"},{"location":"code_reference/ComputeError/#qcelemental.models.common_models.ComputeError.serialize--returns","text":"Union[bytes, str] The serialized model. Source code in qcelemental/models/common_models.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Returns"},{"location":"code_reference/FailedOperation/","text":"FailedOperation \ud83d\udd17 Record indicating that a given operation (program, procedure, etc.) has failed and containing the reason and input data which generated the failure. Parameters \ud83d\udd17 id : str, Optional A unique identifier which links this FailedOperation, often of the same Id of the operation should it have been successful. This will often be set programmatically by a database such as Fractal. input_data : Any, Optional The input data which was passed in that generated this failure. This should be the complete input which when attempted to be run, caused the operation to fail. success : bool, Default: False A boolean indicator that the operation failed consistent with the model of successful operations. Should always be False. Allows programmatic assessment of all operations regardless of if they failed or succeeded error : :class: ComputeError , Default: Ellipsis A container which has details of the error that failed this operation. See the :class: ComputeError for more details. extras : Dict[str, Any], Optional Additional information to bundle with the failed operation. Details which pertain specifically to a thrown error should be contained in the error field. See :class: ComputeError for details. Attributes \ud83d\udd17 error : ComputeError pydantic-field required \ud83d\udd17 A container which has details of the error that failed this operation. See the :class: ComputeError for more details. extras : Dict [ str , Any ] pydantic-field \ud83d\udd17 Additional information to bundle with the failed operation. Details which pertain specifically to a thrown error should be contained in the error field. See :class: ComputeError for details. fields : Dict [ str , pydantic . fields . ModelField ] inherited property readonly \ud83d\udd17 id : str pydantic-field \ud83d\udd17 A unique identifier which links this FailedOperation, often of the same Id of the operation should it have been successful. This will often be set programmatically by a database such as Fractal. input_data : Any pydantic-field \ud83d\udd17 The input data which was passed in that generated this failure. This should be the complete input which when attempted to be run, caused the operation to fail. success : bool pydantic-field \ud83d\udd17 A boolean indicator that the operation failed consistent with the model of successful operations. Should always be False. Allows programmatic assessment of all operations regardless of if they failed or succeeded Config inherited \ud83d\udd17 allow_mutation : bool \ud83d\udd17 extra : str \ud83d\udd17 force_skip_defaults : bool \ud83d\udd17 json_encoders : Dict [ str , Any ] \ud83d\udd17 serialize_default_excludes : Set \ud83d\udd17 serialize_skip_defaults : bool \ud83d\udd17 Methods \ud83d\udd17 compare ( self , other : Union [ ProtoModel , pydantic . main . BaseModel ], ** kwargs ) -> bool inherited \ud83d\udd17 Compares the current object to the provided object recursively. Parameters \ud83d\udd17 other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive . Returns \ud83d\udd17 bool True if the objects match. Source code in qcelemental/models/common_models.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs ) dict ( self , ** kwargs ) -> Dict [ str , Any ] inherited \ud83d\udd17 Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/common_models.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" ) json ( self , ** kwargs ) inherited \ud83d\udd17 Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/common_models.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs ) serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None ) -> Union [ bytes , str ] inherited \ud83d\udd17 Generates a serialized representation of the model Parameters \ud83d\udd17 encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None . Returns \ud83d\udd17 Union[bytes, str] The serialized model. Source code in qcelemental/models/common_models.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"FailedOperation"},{"location":"code_reference/FailedOperation/#failedoperation","text":"Record indicating that a given operation (program, procedure, etc.) has failed and containing the reason and input data which generated the failure.","title":"FailedOperation"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation--parameters","text":"id : str, Optional A unique identifier which links this FailedOperation, often of the same Id of the operation should it have been successful. This will often be set programmatically by a database such as Fractal. input_data : Any, Optional The input data which was passed in that generated this failure. This should be the complete input which when attempted to be run, caused the operation to fail. success : bool, Default: False A boolean indicator that the operation failed consistent with the model of successful operations. Should always be False. Allows programmatic assessment of all operations regardless of if they failed or succeeded error : :class: ComputeError , Default: Ellipsis A container which has details of the error that failed this operation. See the :class: ComputeError for more details. extras : Dict[str, Any], Optional Additional information to bundle with the failed operation. Details which pertain specifically to a thrown error should be contained in the error field. See :class: ComputeError for details.","title":"Parameters"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation-attributes","text":"","title":"Attributes"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.error","text":"A container which has details of the error that failed this operation. See the :class: ComputeError for more details.","title":"error"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.extras","text":"Additional information to bundle with the failed operation. Details which pertain specifically to a thrown error should be contained in the error field. See :class: ComputeError for details.","title":"extras"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.fields","text":"","title":"fields"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.id","text":"A unique identifier which links this FailedOperation, often of the same Id of the operation should it have been successful. This will often be set programmatically by a database such as Fractal.","title":"id"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.input_data","text":"The input data which was passed in that generated this failure. This should be the complete input which when attempted to be run, caused the operation to fail.","title":"input_data"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.success","text":"A boolean indicator that the operation failed consistent with the model of successful operations. Should always be False. Allows programmatic assessment of all operations regardless of if they failed or succeeded","title":"success"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.Config","text":"","title":"Config"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.Config.allow_mutation","text":"","title":"allow_mutation"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.Config.extra","text":"","title":"extra"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.Config.force_skip_defaults","text":"","title":"force_skip_defaults"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.Config.json_encoders","text":"","title":"json_encoders"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.Config.serialize_default_excludes","text":"","title":"serialize_default_excludes"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.Config.serialize_skip_defaults","text":"","title":"serialize_skip_defaults"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation-methods","text":"","title":"Methods"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.compare","text":"Compares the current object to the provided object recursively.","title":"compare()"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.compare--parameters","text":"other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive .","title":"Parameters"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.compare--returns","text":"bool True if the objects match. Source code in qcelemental/models/common_models.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs )","title":"Returns"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.dict","text":"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/common_models.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" )","title":"dict()"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.json","text":"Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/common_models.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs )","title":"json()"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.serialize","text":"Generates a serialized representation of the model","title":"serialize()"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.serialize--parameters","text":"encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None .","title":"Parameters"},{"location":"code_reference/FailedOperation/#qcelemental.models.common_models.FailedOperation.serialize--returns","text":"Union[bytes, str] The serialized model. Source code in qcelemental/models/common_models.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Returns"},{"location":"code_reference/FutureResult/","text":"FutureResult \ud83d\udd17 Single computation FutureResult Attributes \ud83d\udd17 client : Any pydantic-field \ud83d\udd17 compute_status : TaskStatus pydantic-field \ud83d\udd17 fields : Dict [ str , pydantic . fields . ModelField ] inherited property readonly \ud83d\udd17 result : Union [ qcelemental . models . results . AtomicResult , qcelemental . models . procedures . OptimizationResult , qcelemental . models . common_models . FailedOperation ] pydantic-field \ud83d\udd17 status : str inherited property readonly \ud83d\udd17 Check status of compute task. Returns: Type Description str Status of computation. Note Sets self.result if task is complete. NOTE: Do I want to return TaskStatus.FAILURE if FailedOperation is returned? task_id : str pydantic-field required \ud83d\udd17 Config inherited \ud83d\udd17 Methods \ud83d\udd17 from_task ( task : Dict [ str , str ], client ) -> FutureResult classmethod \ud83d\udd17 Instantiate FutureResult from TeraChem Cloud Task Source code in tccloud/models.py @classmethod def from_task ( cls , task : Dict [ str , str ], client ) -> \"FutureResult\" : \"\"\"Instantiate FutureResult from TeraChem Cloud Task\"\"\" return cls ( task_id = task [ \"task_id\" ], client = client ) get ( self , timeout : Optional [ float ] = None , interval : float = 1.0 , raise_error : bool = False ) -> Union [ qcelemental . models . results . AtomicResult , qcelemental . models . procedures . OptimizationResult , qcelemental . models . common_models . FailedOperation ] inherited \ud83d\udd17 Block and return result. Parameters: Name Type Description Default timeout Optional[float] The number of seconds to wait for a computation before raising a TimeOutError. None interval float The amount of time to wait between calls to TeraChem Cloud to check a computation's status. 1.0 raise_error bool If set to True .get() will raise a ComputeError if the computation was unsuccessful. False Returns: Type Description Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation] AtomicResult if computation succeeded or FailedOperation if computation failed. Exceptions: Type Description ComputeError Raised if raise_error=True Source code in tccloud/models.py def get ( self , timeout : Optional [ float ] = None , # in seconds interval : float = 1.0 , raise_error : bool = False , ) -> PossibleResults : \"\"\"Block and return result. Parameters: timeout: The number of seconds to wait for a computation before raising a TimeOutError. interval: The amount of time to wait between calls to TeraChem Cloud to check a computation's status. raise_error: If set to True `.get()` will raise a ComputeError if the computation was unsuccessful. Returns: `AtomicResult` if computation succeeded or `FailedOperation` if computation failed. Exceptions: ComputeError: Raised if `raise_error=True` \"\"\" if self . result : return self . result start_time = time () # Calling self.status returns status and sets self.result if task complete while self . status not in _READY_STATES : sleep ( interval ) if timeout : if ( time () - start_time ) > timeout : raise TimeoutError ( f \"Your timeout limit of { timeout } seconds was exceeded\" ) if self . status != TaskStatus . SUCCESS and raise_error is True : raise ComputeError ( f \"An error occurred in your computation. \\n \" f \"Status: { self . status } . \\n \" f \"Additional information: { self . result } \" ) return self . result to_task ( self ) -> Dict [ str , str ] \ud83d\udd17 To TeraChem Cloud task defintion Source code in tccloud/models.py def to_task ( self ) -> Dict [ str , str ]: \"\"\"To TeraChem Cloud task defintion\"\"\" return { \"task_id\" : self . task_id }","title":"FutureResult"},{"location":"code_reference/FutureResult/#futureresult","text":"Single computation FutureResult","title":"FutureResult"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult-attributes","text":"","title":"Attributes"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.client","text":"","title":"client"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.compute_status","text":"","title":"compute_status"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.fields","text":"","title":"fields"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.result","text":"","title":"result"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.status","text":"Check status of compute task. Returns: Type Description str Status of computation. Note Sets self.result if task is complete. NOTE: Do I want to return TaskStatus.FAILURE if FailedOperation is returned?","title":"status"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.task_id","text":"","title":"task_id"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.Config","text":"","title":"Config"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult-methods","text":"","title":"Methods"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.from_task","text":"Instantiate FutureResult from TeraChem Cloud Task Source code in tccloud/models.py @classmethod def from_task ( cls , task : Dict [ str , str ], client ) -> \"FutureResult\" : \"\"\"Instantiate FutureResult from TeraChem Cloud Task\"\"\" return cls ( task_id = task [ \"task_id\" ], client = client )","title":"from_task()"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.get","text":"Block and return result. Parameters: Name Type Description Default timeout Optional[float] The number of seconds to wait for a computation before raising a TimeOutError. None interval float The amount of time to wait between calls to TeraChem Cloud to check a computation's status. 1.0 raise_error bool If set to True .get() will raise a ComputeError if the computation was unsuccessful. False Returns: Type Description Union[qcelemental.models.results.AtomicResult, qcelemental.models.procedures.OptimizationResult, qcelemental.models.common_models.FailedOperation] AtomicResult if computation succeeded or FailedOperation if computation failed. Exceptions: Type Description ComputeError Raised if raise_error=True Source code in tccloud/models.py def get ( self , timeout : Optional [ float ] = None , # in seconds interval : float = 1.0 , raise_error : bool = False , ) -> PossibleResults : \"\"\"Block and return result. Parameters: timeout: The number of seconds to wait for a computation before raising a TimeOutError. interval: The amount of time to wait between calls to TeraChem Cloud to check a computation's status. raise_error: If set to True `.get()` will raise a ComputeError if the computation was unsuccessful. Returns: `AtomicResult` if computation succeeded or `FailedOperation` if computation failed. Exceptions: ComputeError: Raised if `raise_error=True` \"\"\" if self . result : return self . result start_time = time () # Calling self.status returns status and sets self.result if task complete while self . status not in _READY_STATES : sleep ( interval ) if timeout : if ( time () - start_time ) > timeout : raise TimeoutError ( f \"Your timeout limit of { timeout } seconds was exceeded\" ) if self . status != TaskStatus . SUCCESS and raise_error is True : raise ComputeError ( f \"An error occurred in your computation. \\n \" f \"Status: { self . status } . \\n \" f \"Additional information: { self . result } \" ) return self . result","title":"get()"},{"location":"code_reference/FutureResult/#tccloud.models.FutureResult.to_task","text":"To TeraChem Cloud task defintion Source code in tccloud/models.py def to_task ( self ) -> Dict [ str , str ]: \"\"\"To TeraChem Cloud task defintion\"\"\" return { \"task_id\" : self . task_id }","title":"to_task()"},{"location":"code_reference/Molecule/","text":"Molecule \ud83d\udd17 Overview \ud83d\udd17 The Molecule object is the core representation of a molecule used throughout tccloud . The molecule object is from the qcelemental.models module, but it is available in the tccloud.models module for your convenience. You can access the QCElemental documentation on the Molecule here . It is assumed that all geometries are in bohr . Import the Model object \ud83d\udd17 from tccloud.models import Molecule Create a Molecule \ud83d\udd17 Molecules can be created directly from data on pubchem , a python string, a psi4 file, an xyz file, an xyz+ file, or a json file. Pubchem: water = Molecule . from_data ( \"pubchem:water\" ) From Files: water = Molecule . from_file ( \"water.xyz\" ) water = Molecule . from_file ( \"water.psi4\" ) Save a Molecule to a file \ud83d\udd17 water = Molecule . from_data ( \"pubchem:water\" ) # JSON is the prefered format since it preserves the most information water . to_file ( \"water.json\" ) water . to_file ( \"water.xyz\" ) water . to_file ( \"water.psi4\" ) Oft-used Attributes \ud83d\udd17 water = Molecule . from_data ( \"pubchem:water\" ) water . symbols array ([ 'O' , 'H' , 'H' ], dtype = '<U1' ) water . symbols water . geometry array ([[ 0. , 0. , 0. ], [ 0.52421003 , 1.68733646 , 0.48074633 ], [ 1.14668581 , - 0.45032174 , - 1.35474466 ]]) # All Attributes attrs = [ attr for attr in dir ( water ) if not attr . startswith ( \"_\" )] print ( attrs ) Molecule Full Reference \ud83d\udd17 The physical Cartesian representation of the molecular system. A QCSchema representation of a Molecule. This model contains data for symbols, geometry, connectivity, charges, fragmentation, etc while also supporting a wide array of I/O and manipulation capabilities. Molecule objects geometry, masses, and charges are truncated to 8, 6, and 4 decimal places respectively to assist with duplicate detection. Notes \ud83d\udd17 All arrays are stored flat but must be reshapable into the dimensions in attribute shape , with abbreviations as follows: nat: number of atomic = calcinfo_natom nfr: number of fragments : irregular dimension not systematically reshapable Attributes \ud83d\udd17 atom_labels : Array property readonly \ud83d\udd17 atom_labels_ : Array pydantic-field \ud83d\udd17 Additional per-atom labels as an array of strings. Typical use is in model conversions, such as Elemental <-> Molpro and not typically something which should be user assigned. See the comments field for general human-consumable text to affix to the molecule. atomic_numbers : Array property readonly \ud83d\udd17 atomic_numbers_ : Array pydantic-field \ud83d\udd17 An optional ordered 1-D array-like object of atomic numbers of shape (nat,). Index matches the 0-indexed indices of all other per-atom settings like symbols and real . Values are inferred from the symbols list if not explicitly set. Ghostedness should be indicated through real field, not zeros here. comment : str pydantic-field \ud83d\udd17 Additional comments for this molecule. Intended for pure human/user consumption and clarity. connectivity : List [ Tuple [ int , int , float ]] property readonly \ud83d\udd17 connectivity_ : ConstrainedListValue pydantic-field \ud83d\udd17 A list of bonds within the molecule. Each entry is a tuple of (atom_index_A, atom_index_B, bond_order) where the atom_index matches the 0-indexed indices of all other per-atom settings like symbols and real . Bonds may be freely reordered and inverted. extras : Dict [ str , Any ] pydantic-field \ud83d\udd17 Additional information to bundle with the molecule. Use for schema development and scratch space. fields : Dict [ str , pydantic . fields . ModelField ] inherited property readonly \ud83d\udd17 fix_com : bool pydantic-field \ud83d\udd17 Whether translation of geometry is allowed (fix F) or disallowed (fix T).When False, QCElemental will pre-process the Molecule object to translate the center of mass to (0,0,0) in Euclidean coordinate space, resulting in a different geometry than the one provided. guidance: A consumer who translates the geometry must not reattach the input (pre-translation) molecule schema instance to any output (post-translation) origin-sensitive results (e.g., an ordinary energy when EFP present). fix_orientation : bool pydantic-field \ud83d\udd17 Whether rotation of geometry is allowed (fix F) or disallowed (fix T). When False, QCElemental will pre-process the Molecule object to orient via the intertial tensor, resulting in a different geometry than the one provided. guidance: A consumer who rotates the geometry must not reattach the input (pre-rotation) molecule schema instance to any output (post-rotation) frame-sensitive results (e.g., molecular vibrations). fix_symmetry : str pydantic-field \ud83d\udd17 Maximal point group symmetry which geometry should be treated. Lowercase. fragment_charges : List [ float ] property readonly \ud83d\udd17 fragment_charges_ : List [ float ] pydantic-field \ud83d\udd17 The total charge of each fragment in the fragments list. The index of this list matches the 0-index indices of fragments list. Will be filled in based on a set of rules if not provided (and fragments are specified). fragment_multiplicities : List [ int ] property readonly \ud83d\udd17 fragment_multiplicities_ : List [ int ] pydantic-field \ud83d\udd17 The multiplicity of each fragment in the fragments list. The index of this list matches the 0-index indices of fragments list. Will be filled in based on a set of rules if not provided (and fragments are specified). fragments : List [ qcelemental . models . types . Array ] property readonly \ud83d\udd17 fragments_ : List [ qcelemental . models . types . Array ] pydantic-field \ud83d\udd17 List of indices grouping atoms (0-indexed) into molecular fragments within the molecule. Each entry in the outer list is a new fragment; index matches the ordering in fragment_charges and fragment_multiplicities . Inner lists are 0-indexed atoms which compose the fragment; every atom must be in exactly one inner list. Noncontiguous fragments are allowed, though no QM program is known to support them. Fragment ordering is fixed; that is, a consumer who shuffles fragments must not reattach the input (pre-shuffling) molecule schema instance to any output (post-shuffling) per-fragment results (e.g., n-body energy arrays). geometry : Array pydantic-field required \ud83d\udd17 The ordered array for Cartesian XYZ atomic coordinates [a0]. Atom ordering is fixed; that is, a consumer who shuffles atoms must not reattach the input (pre-shuffling) molecule schema instance to any output (post-shuffling) per-atom results (e.g., gradient). Index of the first dimension matches the 0-indexed indices of all other per-atom settings like symbols and real . Serialized storage is always flat, (3 nat,), but QCSchema implementations will want to reshape it. QCElemental can also accept array-likes which can be mapped to (nat,3) such as a 1-D list of length 3 nat, or the serialized version of the array in (3*nat,) shape; all forms will be reshaped to (nat,3) for this attribute. hash_fields property readonly \ud83d\udd17 id : Any pydantic-field \ud83d\udd17 A unique identifier for this Molecule object. This field exists primarily for Databases (e.g. Fractal's Server) to track and lookup this specific object and should virtually never need to be manually set. identifiers : Identifiers pydantic-field \ud83d\udd17 An optional dictionary of additional identifiers by which this molecule can be referenced, such as INCHI, canonical SMILES, etc. See the :class: Identifiers model for more details. mass_numbers : Array property readonly \ud83d\udd17 mass_numbers_ : Array pydantic-field \ud83d\udd17 An optional ordered 1-D array-like object of atomic mass numbers of shape (nat). Index matches the 0-indexed indices of all other per-atom settings like symbols and real . Values are inferred from the most common isotopes of the symbols list if not explicitly set. If single isotope not (yet) known for an atom, -1 is placeholder. masses : Array property readonly \ud83d\udd17 masses_ : Array pydantic-field \ud83d\udd17 The ordered array of atomic masses. Index order matches the 0-indexed indices of all other per-atom fields like symbols and real . If this is not provided, the mass of each atom is inferred from its most common isotope. If this is provided, it must be the same length as symbols but can accept None entries for standard masses to infer from the same index in the symbols field. molecular_charge : float pydantic-field \ud83d\udd17 The net electrostatic charge of the molecule. molecular_multiplicity : int pydantic-field \ud83d\udd17 The total multiplicity of the molecule. name : str pydantic-field \ud83d\udd17 Common or human-readable name to assign to this molecule. This field can be arbitrary; see identifiers for well-defined labels. provenance : Provenance pydantic-field \ud83d\udd17 The provenance information about how this Molecule (and its attributes) were generated, provided, and manipulated. real : Array property readonly \ud83d\udd17 real_ : Array pydantic-field \ud83d\udd17 The ordered array indicating if each atom is real ( True ) or ghost/virtual ( False ). Index matches the 0-indexed indices of all other per-atom settings like symbols and the first dimension of geometry . If this is not provided, all atoms are assumed to be real ( True ).If this is provided, the reality or ghostedness of every atom must be specified. schema_name : ConstrainedStrValue pydantic-field \ud83d\udd17 The QCSchema specification to which this model conforms. Explicitly fixed as qcschema_molecule. schema_version : int pydantic-field \ud83d\udd17 The version number of schema_name to which this model conforms. symbols : Array pydantic-field required \ud83d\udd17 The ordered array of atomic elemental symbols in title case. This field's index sets atomic order for all other per-atom fields like real and the first dimension of geometry . Ghost/virtual atoms must have an entry here in symbols ; ghostedness is indicated through the real field. validated : bool pydantic-field \ud83d\udd17 A boolean indicator (for speed purposes) that the input Molecule data has been previously checked for schema (data layout and type) and physics (e.g., non-overlapping atoms, feasible multiplicity) compliance. This should be False in most cases. A True setting should only ever be set by the constructor for this class itself or other trusted sources such as a Fractal Server or previously serialized Molecules. Config \ud83d\udd17 allow_mutation : bool inherited \ud83d\udd17 extra : str inherited \ud83d\udd17 force_skip_defaults : bool inherited \ud83d\udd17 json_encoders : Dict [ str , Any ] inherited \ud83d\udd17 serialize_default_excludes : Set inherited \ud83d\udd17 serialize_skip_defaults : bool \ud83d\udd17 repr_style ( self ) \ud83d\udd17 Source code in qcelemental/models/molecule.py repr_style = lambda self : [ ( \"name\" , self . name ), ( \"formula\" , self . get_molecular_formula ()), ( \"hash\" , self . get_hash ()[: 7 ]), ] schema_extra ( schema , model ) \ud83d\udd17 Source code in qcelemental/models/molecule.py def schema_extra ( schema , model ): # below addresses the draft-04 issue until https://github.com/samuelcolvin/pydantic/issues/1478 . schema [ \"$schema\" ] = qcschema_draft Methods \ud83d\udd17 __init__ ( self , orient : bool = False , validate : Optional [ bool ] = None , ** kwargs : Any ) -> None special \ud83d\udd17 Initializes the molecule object from dictionary-like values. Parameters \ud83d\udd17 orient : bool, optional If True, orientates the Molecule to a common reference frame. validate : Optional[bool], optional If None validation is always applied unless the validated flag is set. Otherwise uses the boolean to decide to validate the Molecule or not. **kwargs : Any The values of the Molecule object attributes. Source code in qcelemental/models/molecule.py def __init__ ( self , orient : bool = False , validate : Optional [ bool ] = None , ** kwargs : Any ) -> None : \"\"\"Initializes the molecule object from dictionary-like values. Parameters ---------- orient : bool, optional If True, orientates the Molecule to a common reference frame. validate : Optional[bool], optional If ``None`` validation is always applied unless the ``validated`` flag is set. Otherwise uses the boolean to decide to validate the Molecule or not. **kwargs : Any The values of the Molecule object attributes. \"\"\" if validate is None : validate = not kwargs . get ( \"validated\" , False ) geometry_prep = kwargs . pop ( \"_geometry_prep\" , False ) if validate : kwargs [ \"schema_name\" ] = kwargs . pop ( \"schema_name\" , \"qcschema_molecule\" ) kwargs [ \"schema_version\" ] = kwargs . pop ( \"schema_version\" , 2 ) # original_keys = set(kwargs.keys()) # revive when ready to revisit sparsity nonphysical = kwargs . pop ( \"nonphysical\" , False ) schema = to_schema ( from_schema ( kwargs , nonphysical = nonphysical ), dtype = kwargs [ \"schema_version\" ], copy = False , np_out = True ) schema = _filter_defaults ( schema ) kwargs [ \"validated\" ] = True kwargs = { ** kwargs , ** schema } # Allow any extra fields validate = True super () . __init__ ( ** kwargs ) # We are pulling out the values *explicitly* so that the pydantic skip_defaults works as expected # All attributes set below are equivalent to the default set. values = self . __dict__ if validate : values [ \"symbols\" ] = np . core . defchararray . title ( self . symbols ) # Title case for consistency if orient : values [ \"geometry\" ] = float_prep ( self . _orient_molecule_internal (), GEOMETRY_NOISE ) elif validate or geometry_prep : values [ \"geometry\" ] = float_prep ( values [ \"geometry\" ], GEOMETRY_NOISE ) align ( self , ref_mol : Molecule , * , do_plot : bool = False , verbose : int = 0 , atoms_map : bool = False , run_resorting : bool = False , mols_align : Union [ bool , float ] = False , run_to_completion : bool = False , uno_cutoff : float = 0.001 , run_mirror : bool = False ) \ud83d\udd17 Finds shift, rotation, and atom reordering of concern_mol (self) that best aligns with ref_mol . Wraps func: qcel.molutil.B787 for class: qcel.models.Molecule . Employs the Kabsch, Hungarian, and Uno algorithms to exhaustively locate the best alignment for non-oriented, non-ordered structures. Parameters \ud83d\udd17 ref_mol : qcel.models.Molecule Molecule to match. atoms_map : bool, optional Whether atom1 of ref_mol corresponds to atom1 of concern_mol , etc. If true, specifying True can save much time. mols_align : bool or float, optional Whether ref_mol and concern_mol have identical geometries (barring orientation or atom mapping) and expected final RMSD = 0. If True , procedure is truncated when RMSD condition met, saving time. If float, RMSD tolerance at which search for alignment stops. If provided, the alignment routine will throw an error if it fails to align the molecule within the specified RMSD tolerance. do_plot : bool, optional Pops up a mpl plot showing before, after, and ref geometries. run_to_completion : bool, optional Run reorderings to completion (past RMSD = 0) even if unnecessary because mols_align=True . Used to test worst-case timings. run_resorting : bool, optional Run the resorting machinery even if unnecessary because atoms_map=True . uno_cutoff : float, optional TODO run_mirror : bool, optional Run alternate geometries potentially allowing best match to ref_mol from mirror image of concern_mol . Only run if system confirmed to be nonsuperimposable upon mirror reflection. verbose : int, optional Print level. Returns \ud83d\udd17 Molecule, data Molecule is internal geometry of self optimally aligned and atom-ordered to ref_mol . Presently all fragment information is discarded. data['rmsd'] is RMSD [A] between ref_mol and the optimally aligned geometry computed. data['mill'] is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from concern_mol and the optimally aligned geometry. Source code in qcelemental/models/molecule.py def align ( self , ref_mol : \"Molecule\" , * , do_plot : bool = False , verbose : int = 0 , atoms_map : bool = False , run_resorting : bool = False , mols_align : Union [ bool , float ] = False , run_to_completion : bool = False , uno_cutoff : float = 1.0e-3 , run_mirror : bool = False , ): \"\"\"Finds shift, rotation, and atom reordering of `concern_mol` (self) that best aligns with `ref_mol`. Wraps :py:func:`qcel.molutil.B787` for :py:class:`qcel.models.Molecule`. Employs the Kabsch, Hungarian, and Uno algorithms to exhaustively locate the best alignment for non-oriented, non-ordered structures. Parameters ---------- ref_mol : qcel.models.Molecule Molecule to match. atoms_map : bool, optional Whether atom1 of `ref_mol` corresponds to atom1 of `concern_mol`, etc. If true, specifying `True` can save much time. mols_align : bool or float, optional Whether ref_mol and concern_mol have identical geometries (barring orientation or atom mapping) and expected final RMSD = 0. If `True`, procedure is truncated when RMSD condition met, saving time. If float, RMSD tolerance at which search for alignment stops. If provided, the alignment routine will throw an error if it fails to align the molecule within the specified RMSD tolerance. do_plot : bool, optional Pops up a mpl plot showing before, after, and ref geometries. run_to_completion : bool, optional Run reorderings to completion (past RMSD = 0) even if unnecessary because `mols_align=True`. Used to test worst-case timings. run_resorting : bool, optional Run the resorting machinery even if unnecessary because `atoms_map=True`. uno_cutoff : float, optional TODO run_mirror : bool, optional Run alternate geometries potentially allowing best match to `ref_mol` from mirror image of `concern_mol`. Only run if system confirmed to be nonsuperimposable upon mirror reflection. verbose : int, optional Print level. Returns ------- Molecule, data Molecule is internal geometry of `self` optimally aligned and atom-ordered to `ref_mol`. Presently all fragment information is discarded. `data['rmsd']` is RMSD [A] between `ref_mol` and the optimally aligned geometry computed. `data['mill']` is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from `concern_mol` and the optimally aligned geometry. \"\"\" from ..molutil.align import B787 rgeom = np . array ( ref_mol . geometry ) runiq = np . asarray ( [ hashlib . sha1 (( sym + str ( mas )) . encode ( \"utf-8\" )) . hexdigest () for sym , mas in zip ( cast ( Iterable [ str ], ref_mol . symbols ), ref_mol . masses ) ] ) concern_mol = self cgeom = np . array ( concern_mol . geometry ) cmass = np . array ( concern_mol . masses ) celem = np . array ( concern_mol . symbols ) celez = np . array ( concern_mol . atomic_numbers ) cuniq = np . asarray ( [ hashlib . sha1 (( sym + str ( mas )) . encode ( \"utf-8\" )) . hexdigest () for sym , mas in zip ( cast ( Iterable [ str ], concern_mol . symbols ), concern_mol . masses ) ] ) rmsd , solution = B787 ( cgeom = cgeom , rgeom = rgeom , cuniq = cuniq , runiq = runiq , do_plot = do_plot , verbose = verbose , atoms_map = atoms_map , run_resorting = run_resorting , mols_align = mols_align , run_to_completion = run_to_completion , run_mirror = run_mirror , uno_cutoff = uno_cutoff , ) ageom , amass , aelem , aelez , _ = solution . align_system ( cgeom , cmass , celem , celez , cuniq , reverse = False ) adict = from_arrays ( geom = ageom , mass = amass , elem = aelem , elez = aelez , units = \"Bohr\" , molecular_charge = concern_mol . molecular_charge , molecular_multiplicity = concern_mol . molecular_multiplicity , fix_com = True , fix_orientation = True , ) amol = Molecule ( validate = False , ** to_schema ( adict , dtype = 2 )) # TODO -- can probably do more with fragments in amol now that # Mol is something with non-contig frags. frags now discarded. assert compare_values ( concern_mol . nuclear_repulsion_energy (), amol . nuclear_repulsion_energy (), \"Q: concern_mol-->returned_mol NRE uncorrupted\" , atol = 1.0e-4 , quiet = ( verbose > 1 ), ) if mols_align : assert compare_values ( ref_mol . nuclear_repulsion_energy (), amol . nuclear_repulsion_energy (), \"Q: concern_mol-->returned_mol NRE matches ref_mol\" , atol = 1.0e-4 , quiet = ( verbose > 1 ), ) assert compare ( True , np . allclose ( ref_mol . geometry , amol . geometry , atol = 4 ), \"Q: concern_mol-->returned_mol geometry matches ref_mol\" , quiet = ( verbose > 1 ), ) return amol , { \"rmsd\" : rmsd , \"mill\" : solution } compare ( self , other ) \ud83d\udd17 Compares the current object to the provided object recursively. Parameters \ud83d\udd17 other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive . Returns \ud83d\udd17 bool True if the objects match. Source code in qcelemental/models/molecule.py def compare ( self , other ): warnings . warn ( \"Molecule.compare is deprecated and will be removed in v0.13.0. Use == instead.\" , DeprecationWarning ) return self == other dict ( self , * args , ** kwargs ) \ud83d\udd17 Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/molecule.py def dict ( self , * args , ** kwargs ): kwargs [ \"by_alias\" ] = True kwargs [ \"exclude_unset\" ] = True return super () . dict ( * args , ** kwargs ) from_data ( data : Union [ str , Dict [ str , Any ], < built - in function array > , bytes ], dtype : Optional [ str ] = None , * , orient : bool = False , validate : bool = None , ** kwargs : Dict [ str , Any ]) -> Molecule classmethod \ud83d\udd17 Constructs a molecule object from a data structure. Parameters \ud83d\udd17 data : Union[str, Dict[str, Any], np.array] Data to construct Molecule from dtype : Optional[str], optional How to interpret the data, if not passed attempts to discover this based on input type. orient : bool, optional Orientates the molecule to a standard frame or not. validate : bool, optional Validates the molecule or not. **kwargs : Dict[str, Any] Additional kwargs to pass to the constructors. kwargs take precedence over data. Returns \ud83d\udd17 Molecule A constructed molecule class. Source code in qcelemental/models/molecule.py @classmethod def from_data ( cls , data : Union [ str , Dict [ str , Any ], np . array , bytes ], dtype : Optional [ str ] = None , * , orient : bool = False , validate : bool = None , ** kwargs : Dict [ str , Any ], ) -> \"Molecule\" : \"\"\" Constructs a molecule object from a data structure. Parameters ---------- data : Union[str, Dict[str, Any], np.array] Data to construct Molecule from dtype : Optional[str], optional How to interpret the data, if not passed attempts to discover this based on input type. orient : bool, optional Orientates the molecule to a standard frame or not. validate : bool, optional Validates the molecule or not. **kwargs : Dict[str, Any] Additional kwargs to pass to the constructors. kwargs take precedence over data. Returns ------- Molecule A constructed molecule class. \"\"\" if dtype is None : if isinstance ( data , str ): dtype = \"string\" elif isinstance ( data , np . ndarray ): dtype = \"numpy\" elif isinstance ( data , dict ): dtype = \"dict\" elif isinstance ( dtype , bytes ): dtype = \"msgpack\" else : raise TypeError ( \"Input type not understood, please supply the 'dtype' kwarg.\" ) if dtype in [ \"string\" , \"psi4\" , \"xyz\" , \"xyz+\" ]: mol_dict = from_string ( data , dtype if dtype != \"string\" else None ) assert isinstance ( mol_dict , dict ) input_dict = to_schema ( mol_dict [ \"qm\" ], dtype = 2 , np_out = True ) input_dict = _filter_defaults ( input_dict ) input_dict [ \"validated\" ] = True input_dict [ \"_geometry_prep\" ] = True elif dtype == \"numpy\" : data = np . asarray ( data ) data = { \"geom\" : data [:, 1 :], \"elez\" : data [:, 0 ], \"units\" : kwargs . pop ( \"units\" , \"Angstrom\" ), \"fragment_separators\" : kwargs . pop ( \"frags\" , []), } input_dict = to_schema ( from_arrays ( ** data ), dtype = 2 , np_out = True ) input_dict = _filter_defaults ( input_dict ) input_dict [ \"validated\" ] = True input_dict [ \"_geometry_prep\" ] = True elif dtype == \"msgpack\" : assert isinstance ( data , bytes ) input_dict = msgpackext_loads ( data ) elif dtype == \"json\" : assert isinstance ( data , str ) input_dict = json . loads ( data ) elif dtype == \"dict\" : assert isinstance ( data , dict ) input_dict = data else : raise KeyError ( \"Dtype not understood ' {} '.\" . format ( dtype )) input_dict . update ( kwargs ) # if charge/spin options are given, invalidate charge and spin options that are missing charge_spin_opts = { \"molecular_charge\" , \"fragment_charges\" , \"molecular_multiplicity\" , \"fragment_multiplicities\" } kwarg_keys = set ( kwargs . keys ()) if len ( charge_spin_opts & kwarg_keys ) > 0 : for key in charge_spin_opts - kwarg_keys : input_dict . pop ( key , None ) input_dict . pop ( \"validated\" , None ) return cls ( orient = orient , validate = validate , ** input_dict ) from_file ( filename : str , dtype : Optional [ str ] = None , * , orient : bool = False , ** kwargs ) classmethod \ud83d\udd17 Constructs a molecule object from a file. Parameters \ud83d\udd17 filename : str The filename to build dtype : Optional[str], optional The type of file to interpret. orient : bool, optional Orientates the molecule to a standard frame or not. **kwargs Any additional keywords to pass to the constructor Returns \ud83d\udd17 Molecule A constructed molecule class. Source code in qcelemental/models/molecule.py @classmethod def from_file ( cls , filename : str , dtype : Optional [ str ] = None , * , orient : bool = False , ** kwargs ): \"\"\" Constructs a molecule object from a file. Parameters ---------- filename : str The filename to build dtype : Optional[str], optional The type of file to interpret. orient : bool, optional Orientates the molecule to a standard frame or not. **kwargs Any additional keywords to pass to the constructor Returns ------- Molecule A constructed molecule class. \"\"\" ext = Path ( filename ) . suffix if dtype is None : if ext in _extension_map : dtype = _extension_map [ ext ] else : # Let `from_string` try to sort it dtype = \"string\" # Raw string type, read and pass through if dtype in [ \"string\" , \"xyz\" , \"xyz+\" , \"psi4\" ]: with open ( filename , \"r\" ) as infile : data = infile . read () elif dtype == \"numpy\" : data = np . load ( filename ) elif dtype == \"json\" : with open ( filename , \"r\" ) as infile : data = json . load ( infile ) dtype = \"dict\" elif dtype == \"msgpack\" : with open ( filename , \"rb\" ) as infile_bytes : data = deserialize ( infile_bytes . read (), encoding = \"msgpack-ext\" ) dtype = \"dict\" else : raise KeyError ( \"Dtype not understood ' {} '.\" . format ( dtype )) return cls . from_data ( data , dtype , orient = orient , ** kwargs ) get_fragment ( self , real : Union [ int , List ], ghost : Union [ int , List ] = None , orient : bool = False , group_fragments : bool = True ) -> Molecule \ud83d\udd17 Get new Molecule with fragments preserved, dropped, or ghosted. Parameters \ud83d\udd17 real Fragment index or list of indices (0-indexed) to be real atoms in new Molecule. ghost Fragment index or list of indices (0-indexed) to be ghost atoms (basis fns only) in new Molecule. orient Whether or not to align (inertial frame) and phase geometry upon new Molecule instantiation (according to _orient_molecule_internal)? group_fragments Whether or not to group real fragments at the start of the atom list and ghost fragments toward the back. Previous to v0.5 , this was always effectively True. True is handy for finding duplicate (atom-order-independent) molecules by hash. False preserves fragment order (though collapsing gaps for absent fragments) like Psi4's extract_subsets . False is handy for gradients where atom order of returned values matters. Returns \ud83d\udd17 mol New py::class:qcelemental.model.Molecule with self 's fragments present, ghosted, or absent. Source code in qcelemental/models/molecule.py def get_fragment ( self , real : Union [ int , List ], ghost : Optional [ Union [ int , List ]] = None , orient : bool = False , group_fragments : bool = True , ) -> \"Molecule\" : \"\"\"Get new Molecule with fragments preserved, dropped, or ghosted. Parameters ---------- real Fragment index or list of indices (0-indexed) to be real atoms in new Molecule. ghost Fragment index or list of indices (0-indexed) to be ghost atoms (basis fns only) in new Molecule. orient Whether or not to align (inertial frame) and phase geometry upon new Molecule instantiation (according to _orient_molecule_internal)? group_fragments Whether or not to group real fragments at the start of the atom list and ghost fragments toward the back. Previous to ``v0.5``, this was always effectively True. True is handy for finding duplicate (atom-order-independent) molecules by hash. False preserves fragment order (though collapsing gaps for absent fragments) like Psi4's ``extract_subsets``. False is handy for gradients where atom order of returned values matters. Returns ------- mol New ``py::class:qcelemental.model.Molecule`` with ``self``\\'s fragments present, ghosted, or absent. \"\"\" if isinstance ( real , int ): real = [ real ] if isinstance ( ghost , int ): ghost = [ ghost ] elif ghost is None : ghost = [] constructor_dict : Dict = {} ret_name = ( self . name if self . name is not None else \"\" ) + \" (\" + str ( real ) + \",\" + str ( ghost ) + \")\" constructor_dict [ \"name\" ] = ret_name # ret = Molecule(None, name=ret_name) if len ( set ( real ) & set ( ghost )): raise TypeError ( \"Molecule:get_fragment: real and ghost sets are overlapping! ( {0} , {1} ).\" . format ( str ( real ), str ( ghost )) ) geom_blocks = [] symbols = [] masses = [] real_atoms = [] fragments = [] fragment_charges = [] fragment_multiplicities = [] atom_size = 0 if group_fragments : # Loop through the real blocks frag_start = 0 for frag in real : frag_size = len ( self . fragments [ frag ]) geom_blocks . append ( self . geometry [ self . fragments [ frag ]]) for idx in self . fragments [ frag ]: symbols . append ( self . symbols [ idx ]) real_atoms . append ( True ) masses . append ( self . masses [ idx ]) fragments . append ( list ( range ( frag_start , frag_start + frag_size ))) frag_start += frag_size fragment_charges . append ( float ( self . fragment_charges [ frag ])) fragment_multiplicities . append ( self . fragment_multiplicities [ frag ]) # Set charge and multiplicity constructor_dict [ \"molecular_charge\" ] = sum ( fragment_charges ) constructor_dict [ \"molecular_multiplicity\" ] = sum ( x - 1 for x in fragment_multiplicities ) + 1 # Loop through the ghost blocks for frag in ghost : frag_size = len ( self . fragments [ frag ]) geom_blocks . append ( self . geometry [ self . fragments [ frag ]]) for idx in self . fragments [ frag ]: symbols . append ( self . symbols [ idx ]) real_atoms . append ( False ) masses . append ( self . masses [ idx ]) fragments . append ( list ( range ( frag_start , frag_start + frag_size ))) frag_start += frag_size fragment_charges . append ( 0 ) fragment_multiplicities . append ( 1 ) else : # List[Array[np.int32]] at2fr : List [ Union [ int , None ]] = [ None ] * len ( self . symbols ) for ifr , fr in enumerate ( self . fragments ): for iat in fr : at2fr [ iat ] = ifr at2at : List [ Union [ int , None ]] = [ None ] * len ( self . symbols ) for iat in range ( len ( self . symbols )): ifr = at2fr [ iat ] if ifr in real or ifr in ghost : geom_blocks . append ( self . geometry [ iat ]) symbols . append ( self . symbols [ iat ]) real_atoms . append ( ifr in real ) masses . append ( self . masses [ iat ]) at2at [ iat ] = atom_size atom_size += 1 else : at2at [ iat ] = None for ifr , fr in enumerate ( self . fragments ): if ifr in real or ifr in ghost : fragments . append ([ at2at [ iat ] for iat in fr ]) if ifr in real : fragment_charges . append ( self . fragment_charges [ ifr ]) fragment_multiplicities . append ( self . fragment_multiplicities [ ifr ]) elif ifr in ghost : fragment_charges . append ( 0 ) fragment_multiplicities . append ( 1 ) assert None not in fragments constructor_dict [ \"fragments\" ] = fragments constructor_dict [ \"fragment_charges\" ] = fragment_charges constructor_dict [ \"fragment_multiplicities\" ] = fragment_multiplicities constructor_dict [ \"symbols\" ] = symbols constructor_dict [ \"geometry\" ] = np . vstack ( geom_blocks ) constructor_dict [ \"real\" ] = real_atoms constructor_dict [ \"masses\" ] = masses return Molecule ( orient = orient , ** constructor_dict ) get_hash ( self ) \ud83d\udd17 Returns the hash of the molecule. Source code in qcelemental/models/molecule.py def get_hash ( self ): \"\"\" Returns the hash of the molecule. \"\"\" m = hashlib . sha1 () concat = \"\" np . set_printoptions ( precision = 16 ) for field in self . hash_fields : data = getattr ( self , field ) if field == \"geometry\" : data = float_prep ( data , GEOMETRY_NOISE ) elif field == \"fragment_charges\" : data = float_prep ( data , CHARGE_NOISE ) elif field == \"molecular_charge\" : data = float_prep ( data , CHARGE_NOISE ) elif field == \"masses\" : data = float_prep ( data , MASS_NOISE ) concat += json . dumps ( data , default = lambda x : x . ravel () . tolist ()) m . update ( concat . encode ( \"utf-8\" )) return m . hexdigest () get_molecular_formula ( self , order : str = 'alphabetical' ) -> str \ud83d\udd17 Returns the molecular formula for a molecule. Parameters \ud83d\udd17 str, optional Sorting order of the formula. Valid choices are \"alphabetical\" and \"hill\". Returns \ud83d\udd17 str The molecular formula. Examples \ud83d\udd17 methane = qcelemental.models.Molecule(''' ... H 0.5288 0.1610 0.9359 ... C 0.0000 0.0000 0.0000 ... H 0.2051 0.8240 -0.6786 ... H 0.3345 -0.9314 -0.4496 ... H -1.0685 -0.0537 0.1921 ... ''') methane.get_molecular_formula() CH4 hcl = qcelemental.models.Molecule(''' ... H 0.0000 0.0000 0.0000 ... Cl 0.0000 0.0000 1.2000 ... ''') hcl.get_molecular_formula() ClH Source code in qcelemental/models/molecule.py def get_molecular_formula ( self , order : str = \"alphabetical\" ) -> str : \"\"\" Returns the molecular formula for a molecule. Parameters ---------- order: str, optional Sorting order of the formula. Valid choices are \"alphabetical\" and \"hill\". Returns ------- str The molecular formula. Examples -------- >>> methane = qcelemental.models.Molecule(''' ... H 0.5288 0.1610 0.9359 ... C 0.0000 0.0000 0.0000 ... H 0.2051 0.8240 -0.6786 ... H 0.3345 -0.9314 -0.4496 ... H -1.0685 -0.0537 0.1921 ... ''') >>> methane.get_molecular_formula() CH4 >>> hcl = qcelemental.models.Molecule(''' ... H 0.0000 0.0000 0.0000 ... Cl 0.0000 0.0000 1.2000 ... ''') >>> hcl.get_molecular_formula() ClH \"\"\" from ..molutil import molecular_formula_from_symbols return molecular_formula_from_symbols ( symbols = self . symbols , order = order ) json ( self , ** kwargs ) inherited \ud83d\udd17 Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/molecule.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs ) measure ( self , measurements : Union [ List [ int ], List [ List [ int ]]], * , degrees : bool = True ) -> Union [ float , List [ float ]] \ud83d\udd17 Takes a measurement of the moleucle from the indicies provided. Parameters \ud83d\udd17 measurements : Union[List[int], List[List[int]]] Either a single list of indices or multiple. Return a distance, angle, or dihedral depending if 2, 3, or 4 indices is provided, respectively. Values are returned in Bohr (distance) or degree. degrees : bool, optional Returns degrees by default, radians otherwise. Returns \ud83d\udd17 Union[float, List[float]] Either a value or list of the measured values. Source code in qcelemental/models/molecule.py def measure ( self , measurements : Union [ List [ int ], List [ List [ int ]]], * , degrees : bool = True ) -> Union [ float , List [ float ]]: \"\"\" Takes a measurement of the moleucle from the indicies provided. Parameters ---------- measurements : Union[List[int], List[List[int]]] Either a single list of indices or multiple. Return a distance, angle, or dihedral depending if 2, 3, or 4 indices is provided, respectively. Values are returned in Bohr (distance) or degree. degrees : bool, optional Returns degrees by default, radians otherwise. Returns ------- Union[float, List[float]] Either a value or list of the measured values. \"\"\" return measure_coordinates ( self . geometry , measurements , degrees = degrees ) nelectrons ( self , ifr : int = None ) -> int \ud83d\udd17 Number of electrons. Parameters \ud83d\udd17 ifr : int, optional If not None , only compute for the ifr -th (0-indexed) fragment. Returns \ud83d\udd17 Number of electrons in entire molecule or in fragment. Source code in qcelemental/models/molecule.py def nelectrons ( self , ifr : int = None ) -> int : \"\"\"Number of electrons. Parameters ---------- ifr : int, optional If not `None`, only compute for the `ifr`-th (0-indexed) fragment. Returns ------- Number of electrons in entire molecule or in fragment. \"\"\" Zeff = [ z * int ( real ) for z , real in zip ( cast ( Iterable [ int ], self . atomic_numbers ), self . real )] if ifr is None : nel = sum ( Zeff ) - self . molecular_charge else : nel = sum ([ zf for iat , zf in enumerate ( Zeff ) if iat in self . fragments [ ifr ]]) - self . fragment_charges [ ifr ] return int ( nel ) nuclear_repulsion_energy ( self , ifr : int = None ) -> float \ud83d\udd17 Nuclear repulsion energy. Parameters \ud83d\udd17 ifr : int, optional If not None , only compute for the ifr -th (0-indexed) fragment. Returns \ud83d\udd17 Nuclear repulsion energy in entire molecule or in fragment. Source code in qcelemental/models/molecule.py def nuclear_repulsion_energy ( self , ifr : int = None ) -> float : \"\"\"Nuclear repulsion energy. Parameters ---------- ifr : int, optional If not `None`, only compute for the `ifr`-th (0-indexed) fragment. Returns ------- Nuclear repulsion energy in entire molecule or in fragment. \"\"\" Zeff = [ z * int ( real ) for z , real in zip ( cast ( Iterable [ int ], self . atomic_numbers ), self . real )] atoms = list ( range ( self . geometry . shape [ 0 ])) if ifr is not None : atoms = self . fragments [ ifr ] nre = 0.0 for iat1 , at1 in enumerate ( atoms ): for at2 in atoms [: iat1 ]: dist = np . linalg . norm ( self . geometry [ at1 ] - self . geometry [ at2 ]) nre += Zeff [ at1 ] * Zeff [ at2 ] / dist return nre orient_molecule ( self ) \ud83d\udd17 Centers the molecule and orients via inertia tensor before returning a new Molecule Source code in qcelemental/models/molecule.py def orient_molecule ( self ): \"\"\" Centers the molecule and orients via inertia tensor before returning a new Molecule \"\"\" return Molecule ( orient = True , ** self . dict ()) pretty_print ( self ) \ud83d\udd17 Print the molecule in Angstroms. Same as func: print_out only always in Angstroms. (method name in libmints is print_in_angstrom) Source code in qcelemental/models/molecule.py def pretty_print ( self ): \"\"\"Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms. (method name in libmints is print_in_angstrom) \"\"\" text = \"\" text += \"\"\" Geometry (in {0:s} ), charge = {1:.1f} , multiplicity = {2:d} : \\n\\n \"\"\" . format ( \"Angstrom\" , self . molecular_charge , self . molecular_multiplicity ) text += \"\"\" Center X Y Z \\n \"\"\" text += \"\"\" ------------ ----------------- ----------------- ----------------- \\n \"\"\" for i in range ( len ( self . geometry )): text += \"\"\" {0:8s}{1:4s} \"\"\" . format ( self . symbols [ i ], \"\" if self . real [ i ] else \"(Gh)\" ) for j in range ( 3 ): text += \"\"\" {0:17.12f} \"\"\" . format ( self . geometry [ i ][ j ] * constants . conversion_factor ( \"bohr\" , \"angstroms\" ) ) text += \" \\n \" # text += \"\\n\" return text scramble ( self , * , do_shift : bool = True , do_rotate = True , do_resort = True , deflection = 1.0 , do_mirror = False , do_plot = False , do_test = False , run_to_completion = False , run_resorting = False , verbose = 0 ) \ud83d\udd17 Generate a Molecule with random or directed translation, rotation, and atom shuffling. Optionally, check that the aligner returns the opposite transformation. Parameters \ud83d\udd17 ref_mol : qcel.models.Molecule Molecule to perturb. do_shift : bool or array-like, optional Whether to generate a random atom shift on interval [-3, 3) in each dimension ( True ) or leave at current origin. To shift by a specified vector, supply a 3-element list. do_rotate : bool or array-like, optional Whether to generate a random 3D rotation according to algorithm of Arvo. To rotate by a specified matrix, supply a 9-element list of lists. do_resort : bool or array-like, optional Whether to shuffle atoms ( True ) or leave 1st atom 1st, etc. ( False ). To specify shuffle, supply a nat-element list of indices. deflection : float, optional If do_rotate , how random a rotation: 0.0 is no change, 0.1 is small perturbation, 1.0 is completely random. do_mirror : bool, optional Whether to construct the mirror image structure by inverting y-axis. do_plot : bool, optional Pops up a mpl plot showing before, after, and ref geometries. do_test : bool, optional Additionally, run the aligner on the returned Molecule and check that opposite transformations obtained. run_to_completion : bool, optional By construction, scrambled systems are fully alignable (final RMSD=0). Even so, True turns off the mechanism to stop when RMSD reaches zero and instead proceed to worst possible time. run_resorting : bool, optional Even if atoms not shuffled, test the resorting machinery. verbose : int, optional Print level. Returns \ud83d\udd17 Molecule, data Molecule is scrambled copy of ref_mol (self). data['rmsd'] is RMSD [A] between ref_mol and the scrambled geometry. data['mill'] is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from ref_mol to the returned geometry. Raises \ud83d\udd17 AssertionError If do_test=True and aligner sanity check fails for any of the reverse transformations. Source code in qcelemental/models/molecule.py def scramble ( self , * , do_shift : bool = True , do_rotate = True , do_resort = True , deflection = 1.0 , do_mirror = False , do_plot = False , do_test = False , run_to_completion = False , run_resorting = False , verbose = 0 , ): \"\"\"Generate a Molecule with random or directed translation, rotation, and atom shuffling. Optionally, check that the aligner returns the opposite transformation. Parameters ---------- ref_mol : qcel.models.Molecule Molecule to perturb. do_shift : bool or array-like, optional Whether to generate a random atom shift on interval [-3, 3) in each dimension (`True`) or leave at current origin. To shift by a specified vector, supply a 3-element list. do_rotate : bool or array-like, optional Whether to generate a random 3D rotation according to algorithm of Arvo. To rotate by a specified matrix, supply a 9-element list of lists. do_resort : bool or array-like, optional Whether to shuffle atoms (`True`) or leave 1st atom 1st, etc. (`False`). To specify shuffle, supply a nat-element list of indices. deflection : float, optional If `do_rotate`, how random a rotation: 0.0 is no change, 0.1 is small perturbation, 1.0 is completely random. do_mirror : bool, optional Whether to construct the mirror image structure by inverting y-axis. do_plot : bool, optional Pops up a mpl plot showing before, after, and ref geometries. do_test : bool, optional Additionally, run the aligner on the returned Molecule and check that opposite transformations obtained. run_to_completion : bool, optional By construction, scrambled systems are fully alignable (final RMSD=0). Even so, `True` turns off the mechanism to stop when RMSD reaches zero and instead proceed to worst possible time. run_resorting : bool, optional Even if atoms not shuffled, test the resorting machinery. verbose : int, optional Print level. Returns ------- Molecule, data Molecule is scrambled copy of `ref_mol` (self). `data['rmsd']` is RMSD [A] between `ref_mol` and the scrambled geometry. `data['mill']` is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from `ref_mol` to the returned geometry. Raises ------ AssertionError If `do_test=True` and aligner sanity check fails for any of the reverse transformations. \"\"\" from ..molutil.align import compute_scramble ref_mol = self rgeom = np . array ( ref_mol . geometry ) rmass = np . array ( ref_mol . masses ) relem = np . array ( ref_mol . symbols ) relez = np . array ( ref_mol . atomic_numbers ) runiq = np . asarray ( [ hashlib . sha1 (( sym + str ( mas )) . encode ( \"utf-8\" )) . hexdigest () for sym , mas in zip ( cast ( Iterable [ str ], ref_mol . symbols ), ref_mol . masses ) ] ) nat = rgeom . shape [ 0 ] perturbation = compute_scramble ( rgeom . shape [ 0 ], do_shift = do_shift , do_rotate = do_rotate , deflection = deflection , do_resort = do_resort , do_mirror = do_mirror , ) cgeom , cmass , celem , celez , cuniq = perturbation . align_system ( rgeom , rmass , relem , relez , runiq , reverse = True ) cmolrec = from_arrays ( geom = cgeom , mass = cmass , elem = celem , elez = celez , units = \"Bohr\" , molecular_charge = ref_mol . molecular_charge , molecular_multiplicity = ref_mol . molecular_multiplicity , # copying fix_* vals rather than outright True. neither way great fix_com = ref_mol . fix_com , fix_orientation = ref_mol . fix_orientation , ) cmol = Molecule ( validate = False , ** to_schema ( cmolrec , dtype = 2 )) rmsd = np . linalg . norm ( cgeom - rgeom ) * constants . bohr2angstroms / np . sqrt ( nat ) if verbose >= 1 : print ( \"Start RMSD = {:8.4f} [A]\" . format ( rmsd )) if do_test : _ , data = cmol . align ( ref_mol , do_plot = do_plot , atoms_map = ( not do_resort ), run_resorting = run_resorting , mols_align = True , run_to_completion = run_to_completion , run_mirror = do_mirror , verbose = verbose , ) solution = data [ \"mill\" ] assert compare ( True , np . allclose ( solution . shift , perturbation . shift , atol = 6 ), \"shifts equiv\" , quiet = ( verbose > 1 ) ) if not do_resort : assert compare ( True , np . allclose ( solution . rotation . T , perturbation . rotation ), \"rotations transpose\" , quiet = ( verbose > 1 ), ) if solution . mirror : assert compare ( True , do_mirror , \"mirror allowed\" , quiet = ( verbose > 1 )) return cmol , { \"rmsd\" : rmsd , \"mill\" : perturbation } serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None ) -> Union [ bytes , str ] inherited \ud83d\udd17 Generates a serialized representation of the model Parameters \ud83d\udd17 encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None . Returns \ud83d\udd17 Union[bytes, str] The serialized model. Source code in qcelemental/models/molecule.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding ) show ( self , ngl_kwargs : Optional [ Dict [ str , Any ]] = None ) -> nglview . NGLWidget \ud83d\udd17 Creates a 3D representation of a moleucle that can be manipulated in Jupyter Notebooks and exported as images ( .png ). Parameters \ud83d\udd17 ngl_kwargs : Optional[Dict[str, Any]], optional Addition nglview NGLWidget kwargs Returns \ud83d\udd17 nglview.NGLWidget A nglview view of the molecule Source code in qcelemental/models/molecule.py def show ( self , ngl_kwargs : Optional [ Dict [ str , Any ]] = None ) -> \"nglview.NGLWidget\" : # type: ignore \"\"\"Creates a 3D representation of a moleucle that can be manipulated in Jupyter Notebooks and exported as images (`.png`). Parameters ---------- ngl_kwargs : Optional[Dict[str, Any]], optional Addition nglview NGLWidget kwargs Returns ------- nglview.NGLWidget A nglview view of the molecule \"\"\" if not which_import ( \"nglview\" , return_bool = True ): raise ModuleNotFoundError ( f \"Python module nglwview not found. Solve by installing it: `conda install -c conda-forge nglview`\" ) # pragma: no cover import nglview as nv # type: ignore if ngl_kwargs is None : ngl_kwargs = {} structure = nv . TextStructure ( self . to_string ( \"nglview-sdf\" ), ext = \"sdf\" ) widget = nv . NGLWidget ( structure , ** ngl_kwargs ) return widget to_file ( self , filename : str , dtype : Optional [ str ] = None ) -> None \ud83d\udd17 Writes the Molecule to a file. Parameters \ud83d\udd17 filename : str The filename to write to dtype : Optional[str], optional The type of file to write, attempts to infer dtype from the filename if not provided. Source code in qcelemental/models/molecule.py def to_file ( self , filename : str , dtype : Optional [ str ] = None ) -> None : \"\"\"Writes the Molecule to a file. Parameters ---------- filename : str The filename to write to dtype : Optional[str], optional The type of file to write, attempts to infer dtype from the filename if not provided. \"\"\" ext = Path ( filename ) . suffix if dtype is None : if ext in _extension_map : dtype = _extension_map [ ext ] else : raise KeyError ( f \"Could not infer dtype from filename: ` { filename } `\" ) flags = \"w\" if dtype in [ \"xyz\" , \"xyz+\" , \"psi4\" ]: stringified = self . to_string ( dtype ) elif dtype in [ \"json\" ]: stringified = self . serialize ( \"json\" ) elif dtype in [ \"msgpack\" , \"msgpack-ext\" ]: stringified = self . serialize ( \"msgpack-ext\" ) flags = \"wb\" elif dtype in [ \"numpy\" ]: elements = np . array ( self . atomic_numbers ) . reshape ( - 1 , 1 ) npmol = np . hstack (( elements , self . geometry * constants . conversion_factor ( \"bohr\" , \"angstroms\" ))) np . save ( filename , npmol ) return else : raise KeyError ( f \"Dtype ` { dtype } ` is not valid\" ) with open ( filename , flags ) as handle : handle . write ( stringified ) to_string ( self , dtype : str , units : str = None , * , atom_format : str = None , ghost_format : str = None , width : int = 17 , prec : int = 12 , return_data : bool = False ) \ud83d\udd17 Returns a string that can be used by a variety of programs. Unclear if this will be removed or renamed to \"to_psi4_string\" in the future Suggest psi4 --> psi4frag and psi4 route to to_string Source code in qcelemental/models/molecule.py def to_string ( # type: ignore self , dtype : str , units : str = None , * , atom_format : str = None , ghost_format : str = None , width : int = 17 , prec : int = 12 , return_data : bool = False , ): \"\"\"Returns a string that can be used by a variety of programs. Unclear if this will be removed or renamed to \"to_psi4_string\" in the future Suggest psi4 --> psi4frag and psi4 route to to_string \"\"\" molrec = from_schema ( self . dict (), nonphysical = True ) return to_string ( molrec , dtype = dtype , units = units , atom_format = atom_format , ghost_format = ghost_format , width = width , prec = prec , return_data = return_data , )","title":"Molecule"},{"location":"code_reference/Molecule/#molecule","text":"","title":"Molecule"},{"location":"code_reference/Molecule/#overview","text":"The Molecule object is the core representation of a molecule used throughout tccloud . The molecule object is from the qcelemental.models module, but it is available in the tccloud.models module for your convenience. You can access the QCElemental documentation on the Molecule here . It is assumed that all geometries are in bohr .","title":"Overview"},{"location":"code_reference/Molecule/#import-the-model-object","text":"from tccloud.models import Molecule","title":"Import the Model object"},{"location":"code_reference/Molecule/#create-a-molecule","text":"Molecules can be created directly from data on pubchem , a python string, a psi4 file, an xyz file, an xyz+ file, or a json file. Pubchem: water = Molecule . from_data ( \"pubchem:water\" ) From Files: water = Molecule . from_file ( \"water.xyz\" ) water = Molecule . from_file ( \"water.psi4\" )","title":"Create a Molecule"},{"location":"code_reference/Molecule/#save-a-molecule-to-a-file","text":"water = Molecule . from_data ( \"pubchem:water\" ) # JSON is the prefered format since it preserves the most information water . to_file ( \"water.json\" ) water . to_file ( \"water.xyz\" ) water . to_file ( \"water.psi4\" )","title":"Save a Molecule to a file"},{"location":"code_reference/Molecule/#oft-used-attributes","text":"water = Molecule . from_data ( \"pubchem:water\" ) water . symbols array ([ 'O' , 'H' , 'H' ], dtype = '<U1' ) water . symbols water . geometry array ([[ 0. , 0. , 0. ], [ 0.52421003 , 1.68733646 , 0.48074633 ], [ 1.14668581 , - 0.45032174 , - 1.35474466 ]]) # All Attributes attrs = [ attr for attr in dir ( water ) if not attr . startswith ( \"_\" )] print ( attrs )","title":"Oft-used Attributes"},{"location":"code_reference/Molecule/#molecule-full-reference","text":"The physical Cartesian representation of the molecular system. A QCSchema representation of a Molecule. This model contains data for symbols, geometry, connectivity, charges, fragmentation, etc while also supporting a wide array of I/O and manipulation capabilities. Molecule objects geometry, masses, and charges are truncated to 8, 6, and 4 decimal places respectively to assist with duplicate detection.","title":"Molecule Full Reference"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule--notes","text":"All arrays are stored flat but must be reshapable into the dimensions in attribute shape , with abbreviations as follows: nat: number of atomic = calcinfo_natom nfr: number of fragments : irregular dimension not systematically reshapable","title":"Notes"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule-attributes","text":"","title":"Attributes"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.atom_labels","text":"","title":"atom_labels"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.atom_labels_","text":"Additional per-atom labels as an array of strings. Typical use is in model conversions, such as Elemental <-> Molpro and not typically something which should be user assigned. See the comments field for general human-consumable text to affix to the molecule.","title":"atom_labels_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.atomic_numbers","text":"","title":"atomic_numbers"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.atomic_numbers_","text":"An optional ordered 1-D array-like object of atomic numbers of shape (nat,). Index matches the 0-indexed indices of all other per-atom settings like symbols and real . Values are inferred from the symbols list if not explicitly set. Ghostedness should be indicated through real field, not zeros here.","title":"atomic_numbers_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.comment","text":"Additional comments for this molecule. Intended for pure human/user consumption and clarity.","title":"comment"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.connectivity","text":"","title":"connectivity"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.connectivity_","text":"A list of bonds within the molecule. Each entry is a tuple of (atom_index_A, atom_index_B, bond_order) where the atom_index matches the 0-indexed indices of all other per-atom settings like symbols and real . Bonds may be freely reordered and inverted.","title":"connectivity_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.extras","text":"Additional information to bundle with the molecule. Use for schema development and scratch space.","title":"extras"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fields","text":"","title":"fields"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fix_com","text":"Whether translation of geometry is allowed (fix F) or disallowed (fix T).When False, QCElemental will pre-process the Molecule object to translate the center of mass to (0,0,0) in Euclidean coordinate space, resulting in a different geometry than the one provided. guidance: A consumer who translates the geometry must not reattach the input (pre-translation) molecule schema instance to any output (post-translation) origin-sensitive results (e.g., an ordinary energy when EFP present).","title":"fix_com"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fix_orientation","text":"Whether rotation of geometry is allowed (fix F) or disallowed (fix T). When False, QCElemental will pre-process the Molecule object to orient via the intertial tensor, resulting in a different geometry than the one provided. guidance: A consumer who rotates the geometry must not reattach the input (pre-rotation) molecule schema instance to any output (post-rotation) frame-sensitive results (e.g., molecular vibrations).","title":"fix_orientation"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fix_symmetry","text":"Maximal point group symmetry which geometry should be treated. Lowercase.","title":"fix_symmetry"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fragment_charges","text":"","title":"fragment_charges"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fragment_charges_","text":"The total charge of each fragment in the fragments list. The index of this list matches the 0-index indices of fragments list. Will be filled in based on a set of rules if not provided (and fragments are specified).","title":"fragment_charges_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fragment_multiplicities","text":"","title":"fragment_multiplicities"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fragment_multiplicities_","text":"The multiplicity of each fragment in the fragments list. The index of this list matches the 0-index indices of fragments list. Will be filled in based on a set of rules if not provided (and fragments are specified).","title":"fragment_multiplicities_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fragments","text":"","title":"fragments"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.fragments_","text":"List of indices grouping atoms (0-indexed) into molecular fragments within the molecule. Each entry in the outer list is a new fragment; index matches the ordering in fragment_charges and fragment_multiplicities . Inner lists are 0-indexed atoms which compose the fragment; every atom must be in exactly one inner list. Noncontiguous fragments are allowed, though no QM program is known to support them. Fragment ordering is fixed; that is, a consumer who shuffles fragments must not reattach the input (pre-shuffling) molecule schema instance to any output (post-shuffling) per-fragment results (e.g., n-body energy arrays).","title":"fragments_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.geometry","text":"The ordered array for Cartesian XYZ atomic coordinates [a0]. Atom ordering is fixed; that is, a consumer who shuffles atoms must not reattach the input (pre-shuffling) molecule schema instance to any output (post-shuffling) per-atom results (e.g., gradient). Index of the first dimension matches the 0-indexed indices of all other per-atom settings like symbols and real . Serialized storage is always flat, (3 nat,), but QCSchema implementations will want to reshape it. QCElemental can also accept array-likes which can be mapped to (nat,3) such as a 1-D list of length 3 nat, or the serialized version of the array in (3*nat,) shape; all forms will be reshaped to (nat,3) for this attribute.","title":"geometry"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.hash_fields","text":"","title":"hash_fields"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.id","text":"A unique identifier for this Molecule object. This field exists primarily for Databases (e.g. Fractal's Server) to track and lookup this specific object and should virtually never need to be manually set.","title":"id"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.identifiers","text":"An optional dictionary of additional identifiers by which this molecule can be referenced, such as INCHI, canonical SMILES, etc. See the :class: Identifiers model for more details.","title":"identifiers"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.mass_numbers","text":"","title":"mass_numbers"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.mass_numbers_","text":"An optional ordered 1-D array-like object of atomic mass numbers of shape (nat). Index matches the 0-indexed indices of all other per-atom settings like symbols and real . Values are inferred from the most common isotopes of the symbols list if not explicitly set. If single isotope not (yet) known for an atom, -1 is placeholder.","title":"mass_numbers_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.masses","text":"","title":"masses"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.masses_","text":"The ordered array of atomic masses. Index order matches the 0-indexed indices of all other per-atom fields like symbols and real . If this is not provided, the mass of each atom is inferred from its most common isotope. If this is provided, it must be the same length as symbols but can accept None entries for standard masses to infer from the same index in the symbols field.","title":"masses_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.molecular_charge","text":"The net electrostatic charge of the molecule.","title":"molecular_charge"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.molecular_multiplicity","text":"The total multiplicity of the molecule.","title":"molecular_multiplicity"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.name","text":"Common or human-readable name to assign to this molecule. This field can be arbitrary; see identifiers for well-defined labels.","title":"name"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.provenance","text":"The provenance information about how this Molecule (and its attributes) were generated, provided, and manipulated.","title":"provenance"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.real","text":"","title":"real"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.real_","text":"The ordered array indicating if each atom is real ( True ) or ghost/virtual ( False ). Index matches the 0-indexed indices of all other per-atom settings like symbols and the first dimension of geometry . If this is not provided, all atoms are assumed to be real ( True ).If this is provided, the reality or ghostedness of every atom must be specified.","title":"real_"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.schema_name","text":"The QCSchema specification to which this model conforms. Explicitly fixed as qcschema_molecule.","title":"schema_name"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.schema_version","text":"The version number of schema_name to which this model conforms.","title":"schema_version"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.symbols","text":"The ordered array of atomic elemental symbols in title case. This field's index sets atomic order for all other per-atom fields like real and the first dimension of geometry . Ghost/virtual atoms must have an entry here in symbols ; ghostedness is indicated through the real field.","title":"symbols"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.validated","text":"A boolean indicator (for speed purposes) that the input Molecule data has been previously checked for schema (data layout and type) and physics (e.g., non-overlapping atoms, feasible multiplicity) compliance. This should be False in most cases. A True setting should only ever be set by the constructor for this class itself or other trusted sources such as a Fractal Server or previously serialized Molecules.","title":"validated"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config","text":"","title":"Config"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config.allow_mutation","text":"","title":"allow_mutation"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config.extra","text":"","title":"extra"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config.force_skip_defaults","text":"","title":"force_skip_defaults"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config.json_encoders","text":"","title":"json_encoders"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config.serialize_default_excludes","text":"","title":"serialize_default_excludes"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config.serialize_skip_defaults","text":"","title":"serialize_skip_defaults"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config.repr_style","text":"Source code in qcelemental/models/molecule.py repr_style = lambda self : [ ( \"name\" , self . name ), ( \"formula\" , self . get_molecular_formula ()), ( \"hash\" , self . get_hash ()[: 7 ]), ]","title":"repr_style()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.Config.schema_extra","text":"Source code in qcelemental/models/molecule.py def schema_extra ( schema , model ): # below addresses the draft-04 issue until https://github.com/samuelcolvin/pydantic/issues/1478 . schema [ \"$schema\" ] = qcschema_draft","title":"schema_extra()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule-methods","text":"","title":"Methods"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.__init__","text":"Initializes the molecule object from dictionary-like values.","title":"__init__()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.__init__--parameters","text":"orient : bool, optional If True, orientates the Molecule to a common reference frame. validate : Optional[bool], optional If None validation is always applied unless the validated flag is set. Otherwise uses the boolean to decide to validate the Molecule or not. **kwargs : Any The values of the Molecule object attributes. Source code in qcelemental/models/molecule.py def __init__ ( self , orient : bool = False , validate : Optional [ bool ] = None , ** kwargs : Any ) -> None : \"\"\"Initializes the molecule object from dictionary-like values. Parameters ---------- orient : bool, optional If True, orientates the Molecule to a common reference frame. validate : Optional[bool], optional If ``None`` validation is always applied unless the ``validated`` flag is set. Otherwise uses the boolean to decide to validate the Molecule or not. **kwargs : Any The values of the Molecule object attributes. \"\"\" if validate is None : validate = not kwargs . get ( \"validated\" , False ) geometry_prep = kwargs . pop ( \"_geometry_prep\" , False ) if validate : kwargs [ \"schema_name\" ] = kwargs . pop ( \"schema_name\" , \"qcschema_molecule\" ) kwargs [ \"schema_version\" ] = kwargs . pop ( \"schema_version\" , 2 ) # original_keys = set(kwargs.keys()) # revive when ready to revisit sparsity nonphysical = kwargs . pop ( \"nonphysical\" , False ) schema = to_schema ( from_schema ( kwargs , nonphysical = nonphysical ), dtype = kwargs [ \"schema_version\" ], copy = False , np_out = True ) schema = _filter_defaults ( schema ) kwargs [ \"validated\" ] = True kwargs = { ** kwargs , ** schema } # Allow any extra fields validate = True super () . __init__ ( ** kwargs ) # We are pulling out the values *explicitly* so that the pydantic skip_defaults works as expected # All attributes set below are equivalent to the default set. values = self . __dict__ if validate : values [ \"symbols\" ] = np . core . defchararray . title ( self . symbols ) # Title case for consistency if orient : values [ \"geometry\" ] = float_prep ( self . _orient_molecule_internal (), GEOMETRY_NOISE ) elif validate or geometry_prep : values [ \"geometry\" ] = float_prep ( values [ \"geometry\" ], GEOMETRY_NOISE )","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.align","text":"Finds shift, rotation, and atom reordering of concern_mol (self) that best aligns with ref_mol . Wraps func: qcel.molutil.B787 for class: qcel.models.Molecule . Employs the Kabsch, Hungarian, and Uno algorithms to exhaustively locate the best alignment for non-oriented, non-ordered structures.","title":"align()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.align--parameters","text":"ref_mol : qcel.models.Molecule Molecule to match. atoms_map : bool, optional Whether atom1 of ref_mol corresponds to atom1 of concern_mol , etc. If true, specifying True can save much time. mols_align : bool or float, optional Whether ref_mol and concern_mol have identical geometries (barring orientation or atom mapping) and expected final RMSD = 0. If True , procedure is truncated when RMSD condition met, saving time. If float, RMSD tolerance at which search for alignment stops. If provided, the alignment routine will throw an error if it fails to align the molecule within the specified RMSD tolerance. do_plot : bool, optional Pops up a mpl plot showing before, after, and ref geometries. run_to_completion : bool, optional Run reorderings to completion (past RMSD = 0) even if unnecessary because mols_align=True . Used to test worst-case timings. run_resorting : bool, optional Run the resorting machinery even if unnecessary because atoms_map=True . uno_cutoff : float, optional TODO run_mirror : bool, optional Run alternate geometries potentially allowing best match to ref_mol from mirror image of concern_mol . Only run if system confirmed to be nonsuperimposable upon mirror reflection. verbose : int, optional Print level.","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.align--returns","text":"Molecule, data Molecule is internal geometry of self optimally aligned and atom-ordered to ref_mol . Presently all fragment information is discarded. data['rmsd'] is RMSD [A] between ref_mol and the optimally aligned geometry computed. data['mill'] is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from concern_mol and the optimally aligned geometry. Source code in qcelemental/models/molecule.py def align ( self , ref_mol : \"Molecule\" , * , do_plot : bool = False , verbose : int = 0 , atoms_map : bool = False , run_resorting : bool = False , mols_align : Union [ bool , float ] = False , run_to_completion : bool = False , uno_cutoff : float = 1.0e-3 , run_mirror : bool = False , ): \"\"\"Finds shift, rotation, and atom reordering of `concern_mol` (self) that best aligns with `ref_mol`. Wraps :py:func:`qcel.molutil.B787` for :py:class:`qcel.models.Molecule`. Employs the Kabsch, Hungarian, and Uno algorithms to exhaustively locate the best alignment for non-oriented, non-ordered structures. Parameters ---------- ref_mol : qcel.models.Molecule Molecule to match. atoms_map : bool, optional Whether atom1 of `ref_mol` corresponds to atom1 of `concern_mol`, etc. If true, specifying `True` can save much time. mols_align : bool or float, optional Whether ref_mol and concern_mol have identical geometries (barring orientation or atom mapping) and expected final RMSD = 0. If `True`, procedure is truncated when RMSD condition met, saving time. If float, RMSD tolerance at which search for alignment stops. If provided, the alignment routine will throw an error if it fails to align the molecule within the specified RMSD tolerance. do_plot : bool, optional Pops up a mpl plot showing before, after, and ref geometries. run_to_completion : bool, optional Run reorderings to completion (past RMSD = 0) even if unnecessary because `mols_align=True`. Used to test worst-case timings. run_resorting : bool, optional Run the resorting machinery even if unnecessary because `atoms_map=True`. uno_cutoff : float, optional TODO run_mirror : bool, optional Run alternate geometries potentially allowing best match to `ref_mol` from mirror image of `concern_mol`. Only run if system confirmed to be nonsuperimposable upon mirror reflection. verbose : int, optional Print level. Returns ------- Molecule, data Molecule is internal geometry of `self` optimally aligned and atom-ordered to `ref_mol`. Presently all fragment information is discarded. `data['rmsd']` is RMSD [A] between `ref_mol` and the optimally aligned geometry computed. `data['mill']` is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from `concern_mol` and the optimally aligned geometry. \"\"\" from ..molutil.align import B787 rgeom = np . array ( ref_mol . geometry ) runiq = np . asarray ( [ hashlib . sha1 (( sym + str ( mas )) . encode ( \"utf-8\" )) . hexdigest () for sym , mas in zip ( cast ( Iterable [ str ], ref_mol . symbols ), ref_mol . masses ) ] ) concern_mol = self cgeom = np . array ( concern_mol . geometry ) cmass = np . array ( concern_mol . masses ) celem = np . array ( concern_mol . symbols ) celez = np . array ( concern_mol . atomic_numbers ) cuniq = np . asarray ( [ hashlib . sha1 (( sym + str ( mas )) . encode ( \"utf-8\" )) . hexdigest () for sym , mas in zip ( cast ( Iterable [ str ], concern_mol . symbols ), concern_mol . masses ) ] ) rmsd , solution = B787 ( cgeom = cgeom , rgeom = rgeom , cuniq = cuniq , runiq = runiq , do_plot = do_plot , verbose = verbose , atoms_map = atoms_map , run_resorting = run_resorting , mols_align = mols_align , run_to_completion = run_to_completion , run_mirror = run_mirror , uno_cutoff = uno_cutoff , ) ageom , amass , aelem , aelez , _ = solution . align_system ( cgeom , cmass , celem , celez , cuniq , reverse = False ) adict = from_arrays ( geom = ageom , mass = amass , elem = aelem , elez = aelez , units = \"Bohr\" , molecular_charge = concern_mol . molecular_charge , molecular_multiplicity = concern_mol . molecular_multiplicity , fix_com = True , fix_orientation = True , ) amol = Molecule ( validate = False , ** to_schema ( adict , dtype = 2 )) # TODO -- can probably do more with fragments in amol now that # Mol is something with non-contig frags. frags now discarded. assert compare_values ( concern_mol . nuclear_repulsion_energy (), amol . nuclear_repulsion_energy (), \"Q: concern_mol-->returned_mol NRE uncorrupted\" , atol = 1.0e-4 , quiet = ( verbose > 1 ), ) if mols_align : assert compare_values ( ref_mol . nuclear_repulsion_energy (), amol . nuclear_repulsion_energy (), \"Q: concern_mol-->returned_mol NRE matches ref_mol\" , atol = 1.0e-4 , quiet = ( verbose > 1 ), ) assert compare ( True , np . allclose ( ref_mol . geometry , amol . geometry , atol = 4 ), \"Q: concern_mol-->returned_mol geometry matches ref_mol\" , quiet = ( verbose > 1 ), ) return amol , { \"rmsd\" : rmsd , \"mill\" : solution }","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.compare","text":"Compares the current object to the provided object recursively.","title":"compare()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.compare--parameters","text":"other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive .","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.compare--returns","text":"bool True if the objects match. Source code in qcelemental/models/molecule.py def compare ( self , other ): warnings . warn ( \"Molecule.compare is deprecated and will be removed in v0.13.0. Use == instead.\" , DeprecationWarning ) return self == other","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.dict","text":"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/molecule.py def dict ( self , * args , ** kwargs ): kwargs [ \"by_alias\" ] = True kwargs [ \"exclude_unset\" ] = True return super () . dict ( * args , ** kwargs )","title":"dict()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.from_data","text":"Constructs a molecule object from a data structure.","title":"from_data()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.from_data--parameters","text":"data : Union[str, Dict[str, Any], np.array] Data to construct Molecule from dtype : Optional[str], optional How to interpret the data, if not passed attempts to discover this based on input type. orient : bool, optional Orientates the molecule to a standard frame or not. validate : bool, optional Validates the molecule or not. **kwargs : Dict[str, Any] Additional kwargs to pass to the constructors. kwargs take precedence over data.","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.from_data--returns","text":"Molecule A constructed molecule class. Source code in qcelemental/models/molecule.py @classmethod def from_data ( cls , data : Union [ str , Dict [ str , Any ], np . array , bytes ], dtype : Optional [ str ] = None , * , orient : bool = False , validate : bool = None , ** kwargs : Dict [ str , Any ], ) -> \"Molecule\" : \"\"\" Constructs a molecule object from a data structure. Parameters ---------- data : Union[str, Dict[str, Any], np.array] Data to construct Molecule from dtype : Optional[str], optional How to interpret the data, if not passed attempts to discover this based on input type. orient : bool, optional Orientates the molecule to a standard frame or not. validate : bool, optional Validates the molecule or not. **kwargs : Dict[str, Any] Additional kwargs to pass to the constructors. kwargs take precedence over data. Returns ------- Molecule A constructed molecule class. \"\"\" if dtype is None : if isinstance ( data , str ): dtype = \"string\" elif isinstance ( data , np . ndarray ): dtype = \"numpy\" elif isinstance ( data , dict ): dtype = \"dict\" elif isinstance ( dtype , bytes ): dtype = \"msgpack\" else : raise TypeError ( \"Input type not understood, please supply the 'dtype' kwarg.\" ) if dtype in [ \"string\" , \"psi4\" , \"xyz\" , \"xyz+\" ]: mol_dict = from_string ( data , dtype if dtype != \"string\" else None ) assert isinstance ( mol_dict , dict ) input_dict = to_schema ( mol_dict [ \"qm\" ], dtype = 2 , np_out = True ) input_dict = _filter_defaults ( input_dict ) input_dict [ \"validated\" ] = True input_dict [ \"_geometry_prep\" ] = True elif dtype == \"numpy\" : data = np . asarray ( data ) data = { \"geom\" : data [:, 1 :], \"elez\" : data [:, 0 ], \"units\" : kwargs . pop ( \"units\" , \"Angstrom\" ), \"fragment_separators\" : kwargs . pop ( \"frags\" , []), } input_dict = to_schema ( from_arrays ( ** data ), dtype = 2 , np_out = True ) input_dict = _filter_defaults ( input_dict ) input_dict [ \"validated\" ] = True input_dict [ \"_geometry_prep\" ] = True elif dtype == \"msgpack\" : assert isinstance ( data , bytes ) input_dict = msgpackext_loads ( data ) elif dtype == \"json\" : assert isinstance ( data , str ) input_dict = json . loads ( data ) elif dtype == \"dict\" : assert isinstance ( data , dict ) input_dict = data else : raise KeyError ( \"Dtype not understood ' {} '.\" . format ( dtype )) input_dict . update ( kwargs ) # if charge/spin options are given, invalidate charge and spin options that are missing charge_spin_opts = { \"molecular_charge\" , \"fragment_charges\" , \"molecular_multiplicity\" , \"fragment_multiplicities\" } kwarg_keys = set ( kwargs . keys ()) if len ( charge_spin_opts & kwarg_keys ) > 0 : for key in charge_spin_opts - kwarg_keys : input_dict . pop ( key , None ) input_dict . pop ( \"validated\" , None ) return cls ( orient = orient , validate = validate , ** input_dict )","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.from_file","text":"Constructs a molecule object from a file.","title":"from_file()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.from_file--parameters","text":"filename : str The filename to build dtype : Optional[str], optional The type of file to interpret. orient : bool, optional Orientates the molecule to a standard frame or not. **kwargs Any additional keywords to pass to the constructor","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.from_file--returns","text":"Molecule A constructed molecule class. Source code in qcelemental/models/molecule.py @classmethod def from_file ( cls , filename : str , dtype : Optional [ str ] = None , * , orient : bool = False , ** kwargs ): \"\"\" Constructs a molecule object from a file. Parameters ---------- filename : str The filename to build dtype : Optional[str], optional The type of file to interpret. orient : bool, optional Orientates the molecule to a standard frame or not. **kwargs Any additional keywords to pass to the constructor Returns ------- Molecule A constructed molecule class. \"\"\" ext = Path ( filename ) . suffix if dtype is None : if ext in _extension_map : dtype = _extension_map [ ext ] else : # Let `from_string` try to sort it dtype = \"string\" # Raw string type, read and pass through if dtype in [ \"string\" , \"xyz\" , \"xyz+\" , \"psi4\" ]: with open ( filename , \"r\" ) as infile : data = infile . read () elif dtype == \"numpy\" : data = np . load ( filename ) elif dtype == \"json\" : with open ( filename , \"r\" ) as infile : data = json . load ( infile ) dtype = \"dict\" elif dtype == \"msgpack\" : with open ( filename , \"rb\" ) as infile_bytes : data = deserialize ( infile_bytes . read (), encoding = \"msgpack-ext\" ) dtype = \"dict\" else : raise KeyError ( \"Dtype not understood ' {} '.\" . format ( dtype )) return cls . from_data ( data , dtype , orient = orient , ** kwargs )","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.get_fragment","text":"Get new Molecule with fragments preserved, dropped, or ghosted.","title":"get_fragment()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.get_fragment--parameters","text":"real Fragment index or list of indices (0-indexed) to be real atoms in new Molecule. ghost Fragment index or list of indices (0-indexed) to be ghost atoms (basis fns only) in new Molecule. orient Whether or not to align (inertial frame) and phase geometry upon new Molecule instantiation (according to _orient_molecule_internal)? group_fragments Whether or not to group real fragments at the start of the atom list and ghost fragments toward the back. Previous to v0.5 , this was always effectively True. True is handy for finding duplicate (atom-order-independent) molecules by hash. False preserves fragment order (though collapsing gaps for absent fragments) like Psi4's extract_subsets . False is handy for gradients where atom order of returned values matters.","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.get_fragment--returns","text":"mol New py::class:qcelemental.model.Molecule with self 's fragments present, ghosted, or absent. Source code in qcelemental/models/molecule.py def get_fragment ( self , real : Union [ int , List ], ghost : Optional [ Union [ int , List ]] = None , orient : bool = False , group_fragments : bool = True , ) -> \"Molecule\" : \"\"\"Get new Molecule with fragments preserved, dropped, or ghosted. Parameters ---------- real Fragment index or list of indices (0-indexed) to be real atoms in new Molecule. ghost Fragment index or list of indices (0-indexed) to be ghost atoms (basis fns only) in new Molecule. orient Whether or not to align (inertial frame) and phase geometry upon new Molecule instantiation (according to _orient_molecule_internal)? group_fragments Whether or not to group real fragments at the start of the atom list and ghost fragments toward the back. Previous to ``v0.5``, this was always effectively True. True is handy for finding duplicate (atom-order-independent) molecules by hash. False preserves fragment order (though collapsing gaps for absent fragments) like Psi4's ``extract_subsets``. False is handy for gradients where atom order of returned values matters. Returns ------- mol New ``py::class:qcelemental.model.Molecule`` with ``self``\\'s fragments present, ghosted, or absent. \"\"\" if isinstance ( real , int ): real = [ real ] if isinstance ( ghost , int ): ghost = [ ghost ] elif ghost is None : ghost = [] constructor_dict : Dict = {} ret_name = ( self . name if self . name is not None else \"\" ) + \" (\" + str ( real ) + \",\" + str ( ghost ) + \")\" constructor_dict [ \"name\" ] = ret_name # ret = Molecule(None, name=ret_name) if len ( set ( real ) & set ( ghost )): raise TypeError ( \"Molecule:get_fragment: real and ghost sets are overlapping! ( {0} , {1} ).\" . format ( str ( real ), str ( ghost )) ) geom_blocks = [] symbols = [] masses = [] real_atoms = [] fragments = [] fragment_charges = [] fragment_multiplicities = [] atom_size = 0 if group_fragments : # Loop through the real blocks frag_start = 0 for frag in real : frag_size = len ( self . fragments [ frag ]) geom_blocks . append ( self . geometry [ self . fragments [ frag ]]) for idx in self . fragments [ frag ]: symbols . append ( self . symbols [ idx ]) real_atoms . append ( True ) masses . append ( self . masses [ idx ]) fragments . append ( list ( range ( frag_start , frag_start + frag_size ))) frag_start += frag_size fragment_charges . append ( float ( self . fragment_charges [ frag ])) fragment_multiplicities . append ( self . fragment_multiplicities [ frag ]) # Set charge and multiplicity constructor_dict [ \"molecular_charge\" ] = sum ( fragment_charges ) constructor_dict [ \"molecular_multiplicity\" ] = sum ( x - 1 for x in fragment_multiplicities ) + 1 # Loop through the ghost blocks for frag in ghost : frag_size = len ( self . fragments [ frag ]) geom_blocks . append ( self . geometry [ self . fragments [ frag ]]) for idx in self . fragments [ frag ]: symbols . append ( self . symbols [ idx ]) real_atoms . append ( False ) masses . append ( self . masses [ idx ]) fragments . append ( list ( range ( frag_start , frag_start + frag_size ))) frag_start += frag_size fragment_charges . append ( 0 ) fragment_multiplicities . append ( 1 ) else : # List[Array[np.int32]] at2fr : List [ Union [ int , None ]] = [ None ] * len ( self . symbols ) for ifr , fr in enumerate ( self . fragments ): for iat in fr : at2fr [ iat ] = ifr at2at : List [ Union [ int , None ]] = [ None ] * len ( self . symbols ) for iat in range ( len ( self . symbols )): ifr = at2fr [ iat ] if ifr in real or ifr in ghost : geom_blocks . append ( self . geometry [ iat ]) symbols . append ( self . symbols [ iat ]) real_atoms . append ( ifr in real ) masses . append ( self . masses [ iat ]) at2at [ iat ] = atom_size atom_size += 1 else : at2at [ iat ] = None for ifr , fr in enumerate ( self . fragments ): if ifr in real or ifr in ghost : fragments . append ([ at2at [ iat ] for iat in fr ]) if ifr in real : fragment_charges . append ( self . fragment_charges [ ifr ]) fragment_multiplicities . append ( self . fragment_multiplicities [ ifr ]) elif ifr in ghost : fragment_charges . append ( 0 ) fragment_multiplicities . append ( 1 ) assert None not in fragments constructor_dict [ \"fragments\" ] = fragments constructor_dict [ \"fragment_charges\" ] = fragment_charges constructor_dict [ \"fragment_multiplicities\" ] = fragment_multiplicities constructor_dict [ \"symbols\" ] = symbols constructor_dict [ \"geometry\" ] = np . vstack ( geom_blocks ) constructor_dict [ \"real\" ] = real_atoms constructor_dict [ \"masses\" ] = masses return Molecule ( orient = orient , ** constructor_dict )","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.get_hash","text":"Returns the hash of the molecule. Source code in qcelemental/models/molecule.py def get_hash ( self ): \"\"\" Returns the hash of the molecule. \"\"\" m = hashlib . sha1 () concat = \"\" np . set_printoptions ( precision = 16 ) for field in self . hash_fields : data = getattr ( self , field ) if field == \"geometry\" : data = float_prep ( data , GEOMETRY_NOISE ) elif field == \"fragment_charges\" : data = float_prep ( data , CHARGE_NOISE ) elif field == \"molecular_charge\" : data = float_prep ( data , CHARGE_NOISE ) elif field == \"masses\" : data = float_prep ( data , MASS_NOISE ) concat += json . dumps ( data , default = lambda x : x . ravel () . tolist ()) m . update ( concat . encode ( \"utf-8\" )) return m . hexdigest ()","title":"get_hash()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.get_molecular_formula","text":"Returns the molecular formula for a molecule.","title":"get_molecular_formula()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.get_molecular_formula--parameters","text":"str, optional Sorting order of the formula. Valid choices are \"alphabetical\" and \"hill\".","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.get_molecular_formula--returns","text":"str The molecular formula.","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.get_molecular_formula--examples","text":"methane = qcelemental.models.Molecule(''' ... H 0.5288 0.1610 0.9359 ... C 0.0000 0.0000 0.0000 ... H 0.2051 0.8240 -0.6786 ... H 0.3345 -0.9314 -0.4496 ... H -1.0685 -0.0537 0.1921 ... ''') methane.get_molecular_formula() CH4 hcl = qcelemental.models.Molecule(''' ... H 0.0000 0.0000 0.0000 ... Cl 0.0000 0.0000 1.2000 ... ''') hcl.get_molecular_formula() ClH Source code in qcelemental/models/molecule.py def get_molecular_formula ( self , order : str = \"alphabetical\" ) -> str : \"\"\" Returns the molecular formula for a molecule. Parameters ---------- order: str, optional Sorting order of the formula. Valid choices are \"alphabetical\" and \"hill\". Returns ------- str The molecular formula. Examples -------- >>> methane = qcelemental.models.Molecule(''' ... H 0.5288 0.1610 0.9359 ... C 0.0000 0.0000 0.0000 ... H 0.2051 0.8240 -0.6786 ... H 0.3345 -0.9314 -0.4496 ... H -1.0685 -0.0537 0.1921 ... ''') >>> methane.get_molecular_formula() CH4 >>> hcl = qcelemental.models.Molecule(''' ... H 0.0000 0.0000 0.0000 ... Cl 0.0000 0.0000 1.2000 ... ''') >>> hcl.get_molecular_formula() ClH \"\"\" from ..molutil import molecular_formula_from_symbols return molecular_formula_from_symbols ( symbols = self . symbols , order = order )","title":"Examples"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.json","text":"Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/molecule.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs )","title":"json()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.measure","text":"Takes a measurement of the moleucle from the indicies provided.","title":"measure()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.measure--parameters","text":"measurements : Union[List[int], List[List[int]]] Either a single list of indices or multiple. Return a distance, angle, or dihedral depending if 2, 3, or 4 indices is provided, respectively. Values are returned in Bohr (distance) or degree. degrees : bool, optional Returns degrees by default, radians otherwise.","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.measure--returns","text":"Union[float, List[float]] Either a value or list of the measured values. Source code in qcelemental/models/molecule.py def measure ( self , measurements : Union [ List [ int ], List [ List [ int ]]], * , degrees : bool = True ) -> Union [ float , List [ float ]]: \"\"\" Takes a measurement of the moleucle from the indicies provided. Parameters ---------- measurements : Union[List[int], List[List[int]]] Either a single list of indices or multiple. Return a distance, angle, or dihedral depending if 2, 3, or 4 indices is provided, respectively. Values are returned in Bohr (distance) or degree. degrees : bool, optional Returns degrees by default, radians otherwise. Returns ------- Union[float, List[float]] Either a value or list of the measured values. \"\"\" return measure_coordinates ( self . geometry , measurements , degrees = degrees )","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.nelectrons","text":"Number of electrons.","title":"nelectrons()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.nelectrons--parameters","text":"ifr : int, optional If not None , only compute for the ifr -th (0-indexed) fragment.","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.nelectrons--returns","text":"Number of electrons in entire molecule or in fragment. Source code in qcelemental/models/molecule.py def nelectrons ( self , ifr : int = None ) -> int : \"\"\"Number of electrons. Parameters ---------- ifr : int, optional If not `None`, only compute for the `ifr`-th (0-indexed) fragment. Returns ------- Number of electrons in entire molecule or in fragment. \"\"\" Zeff = [ z * int ( real ) for z , real in zip ( cast ( Iterable [ int ], self . atomic_numbers ), self . real )] if ifr is None : nel = sum ( Zeff ) - self . molecular_charge else : nel = sum ([ zf for iat , zf in enumerate ( Zeff ) if iat in self . fragments [ ifr ]]) - self . fragment_charges [ ifr ] return int ( nel )","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.nuclear_repulsion_energy","text":"Nuclear repulsion energy.","title":"nuclear_repulsion_energy()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.nuclear_repulsion_energy--parameters","text":"ifr : int, optional If not None , only compute for the ifr -th (0-indexed) fragment.","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.nuclear_repulsion_energy--returns","text":"Nuclear repulsion energy in entire molecule or in fragment. Source code in qcelemental/models/molecule.py def nuclear_repulsion_energy ( self , ifr : int = None ) -> float : \"\"\"Nuclear repulsion energy. Parameters ---------- ifr : int, optional If not `None`, only compute for the `ifr`-th (0-indexed) fragment. Returns ------- Nuclear repulsion energy in entire molecule or in fragment. \"\"\" Zeff = [ z * int ( real ) for z , real in zip ( cast ( Iterable [ int ], self . atomic_numbers ), self . real )] atoms = list ( range ( self . geometry . shape [ 0 ])) if ifr is not None : atoms = self . fragments [ ifr ] nre = 0.0 for iat1 , at1 in enumerate ( atoms ): for at2 in atoms [: iat1 ]: dist = np . linalg . norm ( self . geometry [ at1 ] - self . geometry [ at2 ]) nre += Zeff [ at1 ] * Zeff [ at2 ] / dist return nre","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.orient_molecule","text":"Centers the molecule and orients via inertia tensor before returning a new Molecule Source code in qcelemental/models/molecule.py def orient_molecule ( self ): \"\"\" Centers the molecule and orients via inertia tensor before returning a new Molecule \"\"\" return Molecule ( orient = True , ** self . dict ())","title":"orient_molecule()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.pretty_print","text":"Print the molecule in Angstroms. Same as func: print_out only always in Angstroms. (method name in libmints is print_in_angstrom) Source code in qcelemental/models/molecule.py def pretty_print ( self ): \"\"\"Print the molecule in Angstroms. Same as :py:func:`print_out` only always in Angstroms. (method name in libmints is print_in_angstrom) \"\"\" text = \"\" text += \"\"\" Geometry (in {0:s} ), charge = {1:.1f} , multiplicity = {2:d} : \\n\\n \"\"\" . format ( \"Angstrom\" , self . molecular_charge , self . molecular_multiplicity ) text += \"\"\" Center X Y Z \\n \"\"\" text += \"\"\" ------------ ----------------- ----------------- ----------------- \\n \"\"\" for i in range ( len ( self . geometry )): text += \"\"\" {0:8s}{1:4s} \"\"\" . format ( self . symbols [ i ], \"\" if self . real [ i ] else \"(Gh)\" ) for j in range ( 3 ): text += \"\"\" {0:17.12f} \"\"\" . format ( self . geometry [ i ][ j ] * constants . conversion_factor ( \"bohr\" , \"angstroms\" ) ) text += \" \\n \" # text += \"\\n\" return text","title":"pretty_print()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.scramble","text":"Generate a Molecule with random or directed translation, rotation, and atom shuffling. Optionally, check that the aligner returns the opposite transformation.","title":"scramble()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.scramble--parameters","text":"ref_mol : qcel.models.Molecule Molecule to perturb. do_shift : bool or array-like, optional Whether to generate a random atom shift on interval [-3, 3) in each dimension ( True ) or leave at current origin. To shift by a specified vector, supply a 3-element list. do_rotate : bool or array-like, optional Whether to generate a random 3D rotation according to algorithm of Arvo. To rotate by a specified matrix, supply a 9-element list of lists. do_resort : bool or array-like, optional Whether to shuffle atoms ( True ) or leave 1st atom 1st, etc. ( False ). To specify shuffle, supply a nat-element list of indices. deflection : float, optional If do_rotate , how random a rotation: 0.0 is no change, 0.1 is small perturbation, 1.0 is completely random. do_mirror : bool, optional Whether to construct the mirror image structure by inverting y-axis. do_plot : bool, optional Pops up a mpl plot showing before, after, and ref geometries. do_test : bool, optional Additionally, run the aligner on the returned Molecule and check that opposite transformations obtained. run_to_completion : bool, optional By construction, scrambled systems are fully alignable (final RMSD=0). Even so, True turns off the mechanism to stop when RMSD reaches zero and instead proceed to worst possible time. run_resorting : bool, optional Even if atoms not shuffled, test the resorting machinery. verbose : int, optional Print level.","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.scramble--returns","text":"Molecule, data Molecule is scrambled copy of ref_mol (self). data['rmsd'] is RMSD [A] between ref_mol and the scrambled geometry. data['mill'] is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from ref_mol to the returned geometry.","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.scramble--raises","text":"AssertionError If do_test=True and aligner sanity check fails for any of the reverse transformations. Source code in qcelemental/models/molecule.py def scramble ( self , * , do_shift : bool = True , do_rotate = True , do_resort = True , deflection = 1.0 , do_mirror = False , do_plot = False , do_test = False , run_to_completion = False , run_resorting = False , verbose = 0 , ): \"\"\"Generate a Molecule with random or directed translation, rotation, and atom shuffling. Optionally, check that the aligner returns the opposite transformation. Parameters ---------- ref_mol : qcel.models.Molecule Molecule to perturb. do_shift : bool or array-like, optional Whether to generate a random atom shift on interval [-3, 3) in each dimension (`True`) or leave at current origin. To shift by a specified vector, supply a 3-element list. do_rotate : bool or array-like, optional Whether to generate a random 3D rotation according to algorithm of Arvo. To rotate by a specified matrix, supply a 9-element list of lists. do_resort : bool or array-like, optional Whether to shuffle atoms (`True`) or leave 1st atom 1st, etc. (`False`). To specify shuffle, supply a nat-element list of indices. deflection : float, optional If `do_rotate`, how random a rotation: 0.0 is no change, 0.1 is small perturbation, 1.0 is completely random. do_mirror : bool, optional Whether to construct the mirror image structure by inverting y-axis. do_plot : bool, optional Pops up a mpl plot showing before, after, and ref geometries. do_test : bool, optional Additionally, run the aligner on the returned Molecule and check that opposite transformations obtained. run_to_completion : bool, optional By construction, scrambled systems are fully alignable (final RMSD=0). Even so, `True` turns off the mechanism to stop when RMSD reaches zero and instead proceed to worst possible time. run_resorting : bool, optional Even if atoms not shuffled, test the resorting machinery. verbose : int, optional Print level. Returns ------- Molecule, data Molecule is scrambled copy of `ref_mol` (self). `data['rmsd']` is RMSD [A] between `ref_mol` and the scrambled geometry. `data['mill']` is a AlignmentMill with fields (shift, rotation, atommap, mirror) that prescribe the transformation from `ref_mol` to the returned geometry. Raises ------ AssertionError If `do_test=True` and aligner sanity check fails for any of the reverse transformations. \"\"\" from ..molutil.align import compute_scramble ref_mol = self rgeom = np . array ( ref_mol . geometry ) rmass = np . array ( ref_mol . masses ) relem = np . array ( ref_mol . symbols ) relez = np . array ( ref_mol . atomic_numbers ) runiq = np . asarray ( [ hashlib . sha1 (( sym + str ( mas )) . encode ( \"utf-8\" )) . hexdigest () for sym , mas in zip ( cast ( Iterable [ str ], ref_mol . symbols ), ref_mol . masses ) ] ) nat = rgeom . shape [ 0 ] perturbation = compute_scramble ( rgeom . shape [ 0 ], do_shift = do_shift , do_rotate = do_rotate , deflection = deflection , do_resort = do_resort , do_mirror = do_mirror , ) cgeom , cmass , celem , celez , cuniq = perturbation . align_system ( rgeom , rmass , relem , relez , runiq , reverse = True ) cmolrec = from_arrays ( geom = cgeom , mass = cmass , elem = celem , elez = celez , units = \"Bohr\" , molecular_charge = ref_mol . molecular_charge , molecular_multiplicity = ref_mol . molecular_multiplicity , # copying fix_* vals rather than outright True. neither way great fix_com = ref_mol . fix_com , fix_orientation = ref_mol . fix_orientation , ) cmol = Molecule ( validate = False , ** to_schema ( cmolrec , dtype = 2 )) rmsd = np . linalg . norm ( cgeom - rgeom ) * constants . bohr2angstroms / np . sqrt ( nat ) if verbose >= 1 : print ( \"Start RMSD = {:8.4f} [A]\" . format ( rmsd )) if do_test : _ , data = cmol . align ( ref_mol , do_plot = do_plot , atoms_map = ( not do_resort ), run_resorting = run_resorting , mols_align = True , run_to_completion = run_to_completion , run_mirror = do_mirror , verbose = verbose , ) solution = data [ \"mill\" ] assert compare ( True , np . allclose ( solution . shift , perturbation . shift , atol = 6 ), \"shifts equiv\" , quiet = ( verbose > 1 ) ) if not do_resort : assert compare ( True , np . allclose ( solution . rotation . T , perturbation . rotation ), \"rotations transpose\" , quiet = ( verbose > 1 ), ) if solution . mirror : assert compare ( True , do_mirror , \"mirror allowed\" , quiet = ( verbose > 1 )) return cmol , { \"rmsd\" : rmsd , \"mill\" : perturbation }","title":"Raises"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.serialize","text":"Generates a serialized representation of the model","title":"serialize()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.serialize--parameters","text":"encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None .","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.serialize--returns","text":"Union[bytes, str] The serialized model. Source code in qcelemental/models/molecule.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.show","text":"Creates a 3D representation of a moleucle that can be manipulated in Jupyter Notebooks and exported as images ( .png ).","title":"show()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.show--parameters","text":"ngl_kwargs : Optional[Dict[str, Any]], optional Addition nglview NGLWidget kwargs","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.show--returns","text":"nglview.NGLWidget A nglview view of the molecule Source code in qcelemental/models/molecule.py def show ( self , ngl_kwargs : Optional [ Dict [ str , Any ]] = None ) -> \"nglview.NGLWidget\" : # type: ignore \"\"\"Creates a 3D representation of a moleucle that can be manipulated in Jupyter Notebooks and exported as images (`.png`). Parameters ---------- ngl_kwargs : Optional[Dict[str, Any]], optional Addition nglview NGLWidget kwargs Returns ------- nglview.NGLWidget A nglview view of the molecule \"\"\" if not which_import ( \"nglview\" , return_bool = True ): raise ModuleNotFoundError ( f \"Python module nglwview not found. Solve by installing it: `conda install -c conda-forge nglview`\" ) # pragma: no cover import nglview as nv # type: ignore if ngl_kwargs is None : ngl_kwargs = {} structure = nv . TextStructure ( self . to_string ( \"nglview-sdf\" ), ext = \"sdf\" ) widget = nv . NGLWidget ( structure , ** ngl_kwargs ) return widget","title":"Returns"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.to_file","text":"Writes the Molecule to a file.","title":"to_file()"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.to_file--parameters","text":"filename : str The filename to write to dtype : Optional[str], optional The type of file to write, attempts to infer dtype from the filename if not provided. Source code in qcelemental/models/molecule.py def to_file ( self , filename : str , dtype : Optional [ str ] = None ) -> None : \"\"\"Writes the Molecule to a file. Parameters ---------- filename : str The filename to write to dtype : Optional[str], optional The type of file to write, attempts to infer dtype from the filename if not provided. \"\"\" ext = Path ( filename ) . suffix if dtype is None : if ext in _extension_map : dtype = _extension_map [ ext ] else : raise KeyError ( f \"Could not infer dtype from filename: ` { filename } `\" ) flags = \"w\" if dtype in [ \"xyz\" , \"xyz+\" , \"psi4\" ]: stringified = self . to_string ( dtype ) elif dtype in [ \"json\" ]: stringified = self . serialize ( \"json\" ) elif dtype in [ \"msgpack\" , \"msgpack-ext\" ]: stringified = self . serialize ( \"msgpack-ext\" ) flags = \"wb\" elif dtype in [ \"numpy\" ]: elements = np . array ( self . atomic_numbers ) . reshape ( - 1 , 1 ) npmol = np . hstack (( elements , self . geometry * constants . conversion_factor ( \"bohr\" , \"angstroms\" ))) np . save ( filename , npmol ) return else : raise KeyError ( f \"Dtype ` { dtype } ` is not valid\" ) with open ( filename , flags ) as handle : handle . write ( stringified )","title":"Parameters"},{"location":"code_reference/Molecule/#qcelemental.models.molecule.Molecule.to_string","text":"Returns a string that can be used by a variety of programs. Unclear if this will be removed or renamed to \"to_psi4_string\" in the future Suggest psi4 --> psi4frag and psi4 route to to_string Source code in qcelemental/models/molecule.py def to_string ( # type: ignore self , dtype : str , units : str = None , * , atom_format : str = None , ghost_format : str = None , width : int = 17 , prec : int = 12 , return_data : bool = False , ): \"\"\"Returns a string that can be used by a variety of programs. Unclear if this will be removed or renamed to \"to_psi4_string\" in the future Suggest psi4 --> psi4frag and psi4 route to to_string \"\"\" molrec = from_schema ( self . dict (), nonphysical = True ) return to_string ( molrec , dtype = dtype , units = units , atom_format = atom_format , ghost_format = ghost_format , width = width , prec = prec , return_data = return_data , )","title":"to_string()"},{"location":"code_reference/OptimizationInput/","text":"Optimization Input \ud83d\udd17 Parameters \ud83d\udd17 id : str, Optional hash_index : str, Optional schema_name : ConstrainedStrValue, Default: qcschema_optimization_input schema_version : int, Default: 1 keywords : Dict[str, Any], Default: {} The optimization specific keywords to be used. extras : Dict[str, Any], Default: {} Extra fields that are not part of the schema. protocols : :class: OptimizationProtocols , Optional Protocols regarding the manipulation of a Optimization output data. Parameters ---------- trajectory : {all,initial_and_final,final,none}, Default: all Which gradient evaluations to keep in an optimization trajectory. input_specification : :class: QCInputSpecification , Default: Ellipsis A compute description for energy, gradient, and Hessian computations used in a geometry optimization. Parameters ---------- schema_name : ConstrainedStrValue, Default: qcschema_input schema_version : int, Default: 1 driver : {energy,gradient,hessian,properties}, Default: gradient Allowed computation driver values. model : :class:`Model`, Default: Ellipsis The computational molecular sciences model to run. Parameters ---------- method : str, Default: Ellipsis The quantum chemistry method to evaluate (e.g., B3LYP, PBE, ...). For MM, name of the force field. basis : Union[str, :class:`BasisSet`], Optional The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...). Can be ``None`` for methods without basis sets. For molecular mechanics, name of the atom-typer. keywords : Dict[str, Any], Default: {} The program specific keywords to be used. extras : Dict[str, Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. initial_molecule : :class: Molecule , Default: Ellipsis The starting molecule for the geometry optimization. provenance : :class: Provenance , Optional Provenance information. Parameters ---------- creator : str, Default: Ellipsis The name of the program, library, or person who created the object. version : str, Default: The version of the creator, blank otherwise. This should be sortable by the very broad [PEP 440](https://www.python.org/dev/peps/pep-0440/). routine : str, Default: The name of the routine or function within the creator, blank otherwise. Attributes \ud83d\udd17 extras : Dict [ str , Any ] pydantic-field \ud83d\udd17 Extra fields that are not part of the schema. fields : Dict [ str , pydantic . fields . ModelField ] inherited property readonly \ud83d\udd17 hash_index : str pydantic-field \ud83d\udd17 id : str pydantic-field \ud83d\udd17 initial_molecule : Molecule pydantic-field required \ud83d\udd17 The starting molecule for the geometry optimization. input_specification : QCInputSpecification pydantic-field required \ud83d\udd17 A compute description for energy, gradient, and Hessian computations used in a geometry optimization. Parameters \ud83d\udd17 schema_name : ConstrainedStrValue, Default: qcschema_input schema_version : int, Default: 1 driver : {energy,gradient,hessian,properties}, Default: gradient Allowed computation driver values. model : :class: Model , Default: Ellipsis The computational molecular sciences model to run. Parameters ---------- method : str, Default: Ellipsis The quantum chemistry method to evaluate (e.g., B3LYP, PBE, ...). For MM, name of the force field. basis : Union[str, :class:`BasisSet`], Optional The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...). Can be ``None`` for methods without basis sets. For molecular mechanics, name of the atom-typer. keywords : Dict[str, Any], Default: {} The program specific keywords to be used. extras : Dict[str, Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. keywords : Dict [ str , Any ] pydantic-field \ud83d\udd17 The optimization specific keywords to be used. protocols : OptimizationProtocols pydantic-field \ud83d\udd17 Protocols regarding the manipulation of a Optimization output data. Parameters \ud83d\udd17 trajectory : {all,initial_and_final,final,none}, Default: all Which gradient evaluations to keep in an optimization trajectory. provenance : Provenance pydantic-field \ud83d\udd17 Provenance information. Parameters \ud83d\udd17 creator : str, Default: Ellipsis The name of the program, library, or person who created the object. version : str, Default: The version of the creator, blank otherwise. This should be sortable by the very broad PEP 440 . routine : str, Default: The name of the routine or function within the creator, blank otherwise. schema_name : ConstrainedStrValue pydantic-field \ud83d\udd17 schema_version : int pydantic-field \ud83d\udd17 Config inherited \ud83d\udd17 allow_mutation : bool \ud83d\udd17 extra : str \ud83d\udd17 force_skip_defaults : bool \ud83d\udd17 json_encoders : Dict [ str , Any ] \ud83d\udd17 serialize_default_excludes : Set \ud83d\udd17 serialize_skip_defaults : bool \ud83d\udd17 Methods \ud83d\udd17 compare ( self , other : Union [ ProtoModel , pydantic . main . BaseModel ], ** kwargs ) -> bool inherited \ud83d\udd17 Compares the current object to the provided object recursively. Parameters \ud83d\udd17 other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive . Returns \ud83d\udd17 bool True if the objects match. Source code in qcelemental/models/procedures.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs ) dict ( self , ** kwargs ) -> Dict [ str , Any ] inherited \ud83d\udd17 Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/procedures.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" ) json ( self , ** kwargs ) inherited \ud83d\udd17 Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/procedures.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs ) serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None ) -> Union [ bytes , str ] inherited \ud83d\udd17 Generates a serialized representation of the model Parameters \ud83d\udd17 encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None . Returns \ud83d\udd17 Union[bytes, str] The serialized model. Source code in qcelemental/models/procedures.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Optimization Input"},{"location":"code_reference/OptimizationInput/#optimization-input","text":"","title":"Optimization Input"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput--parameters","text":"id : str, Optional hash_index : str, Optional schema_name : ConstrainedStrValue, Default: qcschema_optimization_input schema_version : int, Default: 1 keywords : Dict[str, Any], Default: {} The optimization specific keywords to be used. extras : Dict[str, Any], Default: {} Extra fields that are not part of the schema. protocols : :class: OptimizationProtocols , Optional Protocols regarding the manipulation of a Optimization output data. Parameters ---------- trajectory : {all,initial_and_final,final,none}, Default: all Which gradient evaluations to keep in an optimization trajectory. input_specification : :class: QCInputSpecification , Default: Ellipsis A compute description for energy, gradient, and Hessian computations used in a geometry optimization. Parameters ---------- schema_name : ConstrainedStrValue, Default: qcschema_input schema_version : int, Default: 1 driver : {energy,gradient,hessian,properties}, Default: gradient Allowed computation driver values. model : :class:`Model`, Default: Ellipsis The computational molecular sciences model to run. Parameters ---------- method : str, Default: Ellipsis The quantum chemistry method to evaluate (e.g., B3LYP, PBE, ...). For MM, name of the force field. basis : Union[str, :class:`BasisSet`], Optional The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...). Can be ``None`` for methods without basis sets. For molecular mechanics, name of the atom-typer. keywords : Dict[str, Any], Default: {} The program specific keywords to be used. extras : Dict[str, Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. initial_molecule : :class: Molecule , Default: Ellipsis The starting molecule for the geometry optimization. provenance : :class: Provenance , Optional Provenance information. Parameters ---------- creator : str, Default: Ellipsis The name of the program, library, or person who created the object. version : str, Default: The version of the creator, blank otherwise. This should be sortable by the very broad [PEP 440](https://www.python.org/dev/peps/pep-0440/). routine : str, Default: The name of the routine or function within the creator, blank otherwise.","title":"Parameters"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput-attributes","text":"","title":"Attributes"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.extras","text":"Extra fields that are not part of the schema.","title":"extras"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.fields","text":"","title":"fields"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.hash_index","text":"","title":"hash_index"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.id","text":"","title":"id"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.initial_molecule","text":"The starting molecule for the geometry optimization.","title":"initial_molecule"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.input_specification","text":"A compute description for energy, gradient, and Hessian computations used in a geometry optimization.","title":"input_specification"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.input_specification--parameters","text":"schema_name : ConstrainedStrValue, Default: qcschema_input schema_version : int, Default: 1 driver : {energy,gradient,hessian,properties}, Default: gradient Allowed computation driver values. model : :class: Model , Default: Ellipsis The computational molecular sciences model to run. Parameters ---------- method : str, Default: Ellipsis The quantum chemistry method to evaluate (e.g., B3LYP, PBE, ...). For MM, name of the force field. basis : Union[str, :class:`BasisSet`], Optional The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...). Can be ``None`` for methods without basis sets. For molecular mechanics, name of the atom-typer. keywords : Dict[str, Any], Default: {} The program specific keywords to be used. extras : Dict[str, Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space.","title":"Parameters"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.keywords","text":"The optimization specific keywords to be used.","title":"keywords"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.protocols","text":"Protocols regarding the manipulation of a Optimization output data.","title":"protocols"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.protocols--parameters","text":"trajectory : {all,initial_and_final,final,none}, Default: all Which gradient evaluations to keep in an optimization trajectory.","title":"Parameters"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.provenance","text":"Provenance information.","title":"provenance"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.provenance--parameters","text":"creator : str, Default: Ellipsis The name of the program, library, or person who created the object. version : str, Default: The version of the creator, blank otherwise. This should be sortable by the very broad PEP 440 . routine : str, Default: The name of the routine or function within the creator, blank otherwise.","title":"Parameters"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.schema_name","text":"","title":"schema_name"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.schema_version","text":"","title":"schema_version"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.Config","text":"","title":"Config"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.Config.allow_mutation","text":"","title":"allow_mutation"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.Config.extra","text":"","title":"extra"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.Config.force_skip_defaults","text":"","title":"force_skip_defaults"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.Config.json_encoders","text":"","title":"json_encoders"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.Config.serialize_default_excludes","text":"","title":"serialize_default_excludes"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.Config.serialize_skip_defaults","text":"","title":"serialize_skip_defaults"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput-methods","text":"","title":"Methods"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.compare","text":"Compares the current object to the provided object recursively.","title":"compare()"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.compare--parameters","text":"other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive .","title":"Parameters"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.compare--returns","text":"bool True if the objects match. Source code in qcelemental/models/procedures.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs )","title":"Returns"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.dict","text":"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/procedures.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" )","title":"dict()"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.json","text":"Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/procedures.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs )","title":"json()"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.serialize","text":"Generates a serialized representation of the model","title":"serialize()"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.serialize--parameters","text":"encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None .","title":"Parameters"},{"location":"code_reference/OptimizationInput/#qcelemental.models.procedures.OptimizationInput.serialize--returns","text":"Union[bytes, str] The serialized model. Source code in qcelemental/models/procedures.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Returns"},{"location":"code_reference/OptimizationResult/","text":"Optimization Result \ud83d\udd17 Parameters \ud83d\udd17 id : str, Optional hash_index : str, Optional schema_name : ConstrainedStrValue, Default: qcschema_optimization_output schema_version : int, Default: 1 keywords : Dict[str, Any], Default: {} The optimization specific keywords to be used. extras : Dict[str, Any], Default: {} Extra fields that are not part of the schema. protocols : :class: OptimizationProtocols , Optional Protocols regarding the manipulation of a Optimization output data. Parameters ---------- trajectory : {all,initial_and_final,final,none}, Default: all Which gradient evaluations to keep in an optimization trajectory. input_specification : :class: QCInputSpecification , Default: Ellipsis A compute description for energy, gradient, and Hessian computations used in a geometry optimization. Parameters ---------- schema_name : ConstrainedStrValue, Default: qcschema_input schema_version : int, Default: 1 driver : {energy,gradient,hessian,properties}, Default: gradient Allowed computation driver values. model : :class:`Model`, Default: Ellipsis The computational molecular sciences model to run. Parameters ---------- method : str, Default: Ellipsis The quantum chemistry method to evaluate (e.g., B3LYP, PBE, ...). For MM, name of the force field. basis : Union[str, :class:`BasisSet`], Optional The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...). Can be ``None`` for methods without basis sets. For molecular mechanics, name of the atom-typer. keywords : Dict[str, Any], Default: {} The program specific keywords to be used. extras : Dict[str, Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. initial_molecule : :class: Molecule , Default: Ellipsis The starting molecule for the geometry optimization. provenance : :class: Provenance , Default: Ellipsis Provenance information. Parameters ---------- creator : str, Default: Ellipsis The name of the program, library, or person who created the object. version : str, Default: The version of the creator, blank otherwise. This should be sortable by the very broad [PEP 440](https://www.python.org/dev/peps/pep-0440/). routine : str, Default: The name of the routine or function within the creator, blank otherwise. final_molecule : :class: Molecule , Default: Ellipsis The final molecule of the geometry optimization. trajectory : :class: AtomicResult , Default: Ellipsis A list of ordered Result objects for each step in the optimization. energies : List[float], Default: Ellipsis A list of ordered energies for each step in the optimization. stdout : str, Optional The standard output of the program. stderr : str, Optional The standard error of the program. success : bool, Default: Ellipsis The success of a given programs execution. If False, other fields may be blank. error : :class: ComputeError , Optional Complete description of the error from an unsuccessful program execution. Parameters ---------- error_type : str, Default: Ellipsis The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py error_message : str, Default: Ellipsis Text associated with the thrown error. This is often the backtrace, but it can contain additional information as well. extras : Dict[str, Any], Optional Additional information to bundle with the error. Attributes \ud83d\udd17 energies : List [ float ] pydantic-field required \ud83d\udd17 A list of ordered energies for each step in the optimization. error : ComputeError pydantic-field \ud83d\udd17 Complete description of the error from an unsuccessful program execution. Parameters \ud83d\udd17 error_type : str, Default: Ellipsis The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py error_message : str, Default: Ellipsis Text associated with the thrown error. This is often the backtrace, but it can contain additional information as well. extras : Dict[str, Any], Optional Additional information to bundle with the error. extras : Dict [ str , Any ] pydantic-field \ud83d\udd17 Extra fields that are not part of the schema. fields : Dict [ str , pydantic . fields . ModelField ] inherited property readonly \ud83d\udd17 final_molecule : Molecule pydantic-field required \ud83d\udd17 The final molecule of the geometry optimization. hash_index : str pydantic-field \ud83d\udd17 id : str pydantic-field \ud83d\udd17 initial_molecule : Molecule pydantic-field required \ud83d\udd17 The starting molecule for the geometry optimization. input_specification : QCInputSpecification pydantic-field required \ud83d\udd17 A compute description for energy, gradient, and Hessian computations used in a geometry optimization. Parameters \ud83d\udd17 schema_name : ConstrainedStrValue, Default: qcschema_input schema_version : int, Default: 1 driver : {energy,gradient,hessian,properties}, Default: gradient Allowed computation driver values. model : :class: Model , Default: Ellipsis The computational molecular sciences model to run. Parameters ---------- method : str, Default: Ellipsis The quantum chemistry method to evaluate (e.g., B3LYP, PBE, ...). For MM, name of the force field. basis : Union[str, :class:`BasisSet`], Optional The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...). Can be ``None`` for methods without basis sets. For molecular mechanics, name of the atom-typer. keywords : Dict[str, Any], Default: {} The program specific keywords to be used. extras : Dict[str, Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. keywords : Dict [ str , Any ] pydantic-field \ud83d\udd17 The optimization specific keywords to be used. protocols : OptimizationProtocols pydantic-field \ud83d\udd17 Protocols regarding the manipulation of a Optimization output data. Parameters \ud83d\udd17 trajectory : {all,initial_and_final,final,none}, Default: all Which gradient evaluations to keep in an optimization trajectory. provenance : Provenance pydantic-field required \ud83d\udd17 Provenance information. Parameters \ud83d\udd17 creator : str, Default: Ellipsis The name of the program, library, or person who created the object. version : str, Default: The version of the creator, blank otherwise. This should be sortable by the very broad PEP 440 . routine : str, Default: The name of the routine or function within the creator, blank otherwise. schema_name : ConstrainedStrValue pydantic-field \ud83d\udd17 schema_version : int pydantic-field \ud83d\udd17 stderr : str pydantic-field \ud83d\udd17 The standard error of the program. stdout : str pydantic-field \ud83d\udd17 The standard output of the program. success : bool pydantic-field required \ud83d\udd17 The success of a given programs execution. If False, other fields may be blank. trajectory : List [ qcelemental . models . results . AtomicResult ] pydantic-field required \ud83d\udd17 A list of ordered Result objects for each step in the optimization. Config inherited \ud83d\udd17 allow_mutation : bool \ud83d\udd17 extra : str \ud83d\udd17 force_skip_defaults : bool \ud83d\udd17 json_encoders : Dict [ str , Any ] \ud83d\udd17 serialize_default_excludes : Set \ud83d\udd17 serialize_skip_defaults : bool \ud83d\udd17 Methods \ud83d\udd17 compare ( self , other : Union [ ProtoModel , pydantic . main . BaseModel ], ** kwargs ) -> bool inherited \ud83d\udd17 Compares the current object to the provided object recursively. Parameters \ud83d\udd17 other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive . Returns \ud83d\udd17 bool True if the objects match. Source code in qcelemental/models/procedures.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs ) dict ( self , ** kwargs ) -> Dict [ str , Any ] inherited \ud83d\udd17 Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/procedures.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" ) json ( self , ** kwargs ) inherited \ud83d\udd17 Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/procedures.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs ) serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None ) -> Union [ bytes , str ] inherited \ud83d\udd17 Generates a serialized representation of the model Parameters \ud83d\udd17 encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None . Returns \ud83d\udd17 Union[bytes, str] The serialized model. Source code in qcelemental/models/procedures.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Optimization Result"},{"location":"code_reference/OptimizationResult/#optimization-result","text":"","title":"Optimization Result"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult--parameters","text":"id : str, Optional hash_index : str, Optional schema_name : ConstrainedStrValue, Default: qcschema_optimization_output schema_version : int, Default: 1 keywords : Dict[str, Any], Default: {} The optimization specific keywords to be used. extras : Dict[str, Any], Default: {} Extra fields that are not part of the schema. protocols : :class: OptimizationProtocols , Optional Protocols regarding the manipulation of a Optimization output data. Parameters ---------- trajectory : {all,initial_and_final,final,none}, Default: all Which gradient evaluations to keep in an optimization trajectory. input_specification : :class: QCInputSpecification , Default: Ellipsis A compute description for energy, gradient, and Hessian computations used in a geometry optimization. Parameters ---------- schema_name : ConstrainedStrValue, Default: qcschema_input schema_version : int, Default: 1 driver : {energy,gradient,hessian,properties}, Default: gradient Allowed computation driver values. model : :class:`Model`, Default: Ellipsis The computational molecular sciences model to run. Parameters ---------- method : str, Default: Ellipsis The quantum chemistry method to evaluate (e.g., B3LYP, PBE, ...). For MM, name of the force field. basis : Union[str, :class:`BasisSet`], Optional The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...). Can be ``None`` for methods without basis sets. For molecular mechanics, name of the atom-typer. keywords : Dict[str, Any], Default: {} The program specific keywords to be used. extras : Dict[str, Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space. initial_molecule : :class: Molecule , Default: Ellipsis The starting molecule for the geometry optimization. provenance : :class: Provenance , Default: Ellipsis Provenance information. Parameters ---------- creator : str, Default: Ellipsis The name of the program, library, or person who created the object. version : str, Default: The version of the creator, blank otherwise. This should be sortable by the very broad [PEP 440](https://www.python.org/dev/peps/pep-0440/). routine : str, Default: The name of the routine or function within the creator, blank otherwise. final_molecule : :class: Molecule , Default: Ellipsis The final molecule of the geometry optimization. trajectory : :class: AtomicResult , Default: Ellipsis A list of ordered Result objects for each step in the optimization. energies : List[float], Default: Ellipsis A list of ordered energies for each step in the optimization. stdout : str, Optional The standard output of the program. stderr : str, Optional The standard error of the program. success : bool, Default: Ellipsis The success of a given programs execution. If False, other fields may be blank. error : :class: ComputeError , Optional Complete description of the error from an unsuccessful program execution. Parameters ---------- error_type : str, Default: Ellipsis The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py error_message : str, Default: Ellipsis Text associated with the thrown error. This is often the backtrace, but it can contain additional information as well. extras : Dict[str, Any], Optional Additional information to bundle with the error.","title":"Parameters"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult-attributes","text":"","title":"Attributes"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.energies","text":"A list of ordered energies for each step in the optimization.","title":"energies"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.error","text":"Complete description of the error from an unsuccessful program execution.","title":"error"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.error--parameters","text":"error_type : str, Default: Ellipsis The type of error which was thrown. Restrict this field to short classifiers e.g. 'input_error'. Suggested classifiers: https://github.com/MolSSI/QCEngine/blob/master/qcengine/exceptions.py error_message : str, Default: Ellipsis Text associated with the thrown error. This is often the backtrace, but it can contain additional information as well. extras : Dict[str, Any], Optional Additional information to bundle with the error.","title":"Parameters"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.extras","text":"Extra fields that are not part of the schema.","title":"extras"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.fields","text":"","title":"fields"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.final_molecule","text":"The final molecule of the geometry optimization.","title":"final_molecule"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.hash_index","text":"","title":"hash_index"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.id","text":"","title":"id"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.initial_molecule","text":"The starting molecule for the geometry optimization.","title":"initial_molecule"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.input_specification","text":"A compute description for energy, gradient, and Hessian computations used in a geometry optimization.","title":"input_specification"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.input_specification--parameters","text":"schema_name : ConstrainedStrValue, Default: qcschema_input schema_version : int, Default: 1 driver : {energy,gradient,hessian,properties}, Default: gradient Allowed computation driver values. model : :class: Model , Default: Ellipsis The computational molecular sciences model to run. Parameters ---------- method : str, Default: Ellipsis The quantum chemistry method to evaluate (e.g., B3LYP, PBE, ...). For MM, name of the force field. basis : Union[str, :class:`BasisSet`], Optional The quantum chemistry basis set to evaluate (e.g., 6-31g, cc-pVDZ, ...). Can be ``None`` for methods without basis sets. For molecular mechanics, name of the atom-typer. keywords : Dict[str, Any], Default: {} The program specific keywords to be used. extras : Dict[str, Any], Default: {} Additional information to bundle with the computation. Use for schema development and scratch space.","title":"Parameters"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.keywords","text":"The optimization specific keywords to be used.","title":"keywords"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.protocols","text":"Protocols regarding the manipulation of a Optimization output data.","title":"protocols"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.protocols--parameters","text":"trajectory : {all,initial_and_final,final,none}, Default: all Which gradient evaluations to keep in an optimization trajectory.","title":"Parameters"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.provenance","text":"Provenance information.","title":"provenance"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.provenance--parameters","text":"creator : str, Default: Ellipsis The name of the program, library, or person who created the object. version : str, Default: The version of the creator, blank otherwise. This should be sortable by the very broad PEP 440 . routine : str, Default: The name of the routine or function within the creator, blank otherwise.","title":"Parameters"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.schema_name","text":"","title":"schema_name"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.schema_version","text":"","title":"schema_version"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.stderr","text":"The standard error of the program.","title":"stderr"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.stdout","text":"The standard output of the program.","title":"stdout"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.success","text":"The success of a given programs execution. If False, other fields may be blank.","title":"success"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.trajectory","text":"A list of ordered Result objects for each step in the optimization.","title":"trajectory"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.Config","text":"","title":"Config"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.Config.allow_mutation","text":"","title":"allow_mutation"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.Config.extra","text":"","title":"extra"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.Config.force_skip_defaults","text":"","title":"force_skip_defaults"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.Config.json_encoders","text":"","title":"json_encoders"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.Config.serialize_default_excludes","text":"","title":"serialize_default_excludes"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.Config.serialize_skip_defaults","text":"","title":"serialize_skip_defaults"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult-methods","text":"","title":"Methods"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.compare","text":"Compares the current object to the provided object recursively.","title":"compare()"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.compare--parameters","text":"other : Model The model to compare to. **kwargs Additional kwargs to pass to qcelemental.compare_recursive .","title":"Parameters"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.compare--returns","text":"bool True if the objects match. Source code in qcelemental/models/procedures.py def compare ( self , other : Union [ \"ProtoModel\" , BaseModel ], ** kwargs ) -> bool : \"\"\"Compares the current object to the provided object recursively. Parameters ---------- other : Model The model to compare to. **kwargs Additional kwargs to pass to ``qcelemental.compare_recursive``. Returns ------- bool True if the objects match. \"\"\" return compare_recursive ( self , other , ** kwargs )","title":"Returns"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.dict","text":"Generate a dictionary representation of the model, optionally specifying which fields to include or exclude. Source code in qcelemental/models/procedures.py def dict ( self , ** kwargs ) -> Dict [ str , Any ]: encoding = kwargs . pop ( \"encoding\" , None ) kwargs [ \"exclude\" ] = ( kwargs . get ( \"exclude\" , None ) or set () ) | self . __config__ . serialize_default_excludes # type: ignore kwargs . setdefault ( \"exclude_unset\" , self . __config__ . serialize_skip_defaults ) # type: ignore if self . __config__ . force_skip_defaults : # type: ignore kwargs [ \"exclude_unset\" ] = True data = super () . dict ( ** kwargs ) if encoding is None : return data elif encoding == \"json\" : return json . loads ( serialize ( data , encoding = \"json\" )) else : raise KeyError ( f \"Unknown encoding type ' { encoding } ', valid encoding types: 'json'.\" )","title":"dict()"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.json","text":"Generate a JSON representation of the model, include and exclude arguments as per dict() . encoder is an optional function to supply as default to json.dumps(), other arguments as per json.dumps() . Source code in qcelemental/models/procedures.py def json ( self , ** kwargs ): # Alias JSON here from BaseModel to reflect dict changes return self . serialize ( \"json\" , ** kwargs )","title":"json()"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.serialize","text":"Generates a serialized representation of the model","title":"serialize()"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.serialize--parameters","text":"encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. Optional[bool], optional If True, skips fields that have value None .","title":"Parameters"},{"location":"code_reference/OptimizationResult/#qcelemental.models.procedures.OptimizationResult.serialize--returns","text":"Union[bytes, str] The serialized model. Source code in qcelemental/models/procedures.py def serialize ( self , encoding : str , * , include : Optional [ Set [ str ]] = None , exclude : Optional [ Set [ str ]] = None , exclude_unset : Optional [ bool ] = None , exclude_defaults : Optional [ bool ] = None , exclude_none : Optional [ bool ] = None , ) -> Union [ bytes , str ]: \"\"\"Generates a serialized representation of the model Parameters ---------- encoding : str The serialization type, available types are: {'json', 'json-ext', 'msgpack-ext'} include : Optional[Set[str]], optional Fields to be included in the serialization. exclude : Optional[Set[str]], optional Fields to be excluded in the serialization. exclude_unset : Optional[bool], optional If True, skips fields that have default values provided. exclude_defaults: Optional[bool], optional If True, skips fields that have set or defaulted values equal to the default. exclude_none: Optional[bool], optional If True, skips fields that have value ``None``. Returns ------- Union[bytes, str] The serialized model. \"\"\" kwargs = {} if include : kwargs [ \"include\" ] = include if exclude : kwargs [ \"exclude\" ] = exclude if exclude_unset : kwargs [ \"exclude_unset\" ] = exclude_unset if exclude_defaults : kwargs [ \"exclude_defaults\" ] = exclude_defaults if exclude_none : kwargs [ \"exclude_none\" ] = exclude_none data = self . dict ( ** kwargs ) return serialize ( data , encoding = encoding )","title":"Returns"},{"location":"code_reference/TCClient/","text":"TCClient \ud83d\udd17 Main client object to perform computations using TeraChem Cloud. Attributes \ud83d\udd17 profile : str property readonly \ud83d\udd17 Profile being used for authentication with TeraChem Cloud. Returns: Type Description str The name of the name of the credentials profile being used with the current client. NOTE: This is a note! supported_engines : List [ str ] property readonly \ud83d\udd17 Compute engines currently supported by TeraChem Cloud. Returns: Type Description List[str] List of engines currently supported by TeraChem Cloud. supported_procedures : List [ str ] property readonly \ud83d\udd17 Compute procedures currently supported by TeraChem Cloud. Returns: Type Description List[str] List of procedures currently supported by TeraChem Cloud. version : str property readonly \ud83d\udd17 Return tccloud version Methods \ud83d\udd17 __init__ ( self , * , tccloud_username : Optional [ str ] = None , tccloud_password : Optional [ str ] = None , profile : Optional [ str ] = None , tccloud_domain : Optional [ str ] = None ) special \ud83d\udd17 Initialize a TCClient object. Parameters: Name Type Description Default tccloud_username Optional[str] TeraChem Cloud username None tccloud_password Optional[str] TeraChem Cloud password None profile Optional[str] Authentication profile name None tccloud_domain Optional[str] Domain of TeraChem Cloud instance to connect to None Danger It is not recommended to pass your TeraChem Cloud username and password directly to a TCClient . Instead instantiate a client with no credentials client = TCClient() and then run client.configure() to securely set up your authentication credentials for TeraChem Cloud. Source code in tccloud/client.py def __init__ ( self , * , tccloud_username : Optional [ str ] = None , tccloud_password : Optional [ str ] = None , profile : Optional [ str ] = None , tccloud_domain : Optional [ str ] = None , ): \"\"\" Initialize a TCClient object. Parameters: tccloud_username: TeraChem Cloud username tccloud_password: TeraChem Cloud password profile: Authentication profile name tccloud_domain: Domain of TeraChem Cloud instance to connect to !!! Danger It is not recommended to pass your TeraChem Cloud username and password directly to a `TCClient`. Instead instantiate a client with no credentials `client = TCClient()` and then run `client.configure()` to securely set up your authentication credentials for TeraChem Cloud. \"\"\" self . _client = _RequestsClient ( tccloud_username = tccloud_username , tccloud_password = tccloud_password , profile = profile , tccloud_domain = tccloud_domain , ) self . _openapi_spec : Optional [ Dict ] = None compute ( self , input_data : Union [ qcelemental . models . results . AtomicInput , List [ qcelemental . models . results . AtomicInput ]], engine : str ) -> Union [ tccloud . models . FutureResult , tccloud . models . FutureResultGroup ] \ud83d\udd17 Submit a computation to TeraChem Cloud. Parameters: Name Type Description Default input_data Union[qcelemental.models.results.AtomicInput, List[qcelemental.models.results.AtomicInput]] Defines the structure of the desired computation. required engine str A string matching one of the self.supported_engines required Returns: Type Description Union[tccloud.models.FutureResult, tccloud.models.FutureResultGroup] Object providing access to a computation's eventual result. You can check a computation's status by runing .status on the FutureResult object or .get() to block and retrieve the computation's final result. Source code in tccloud/client.py def compute ( self , input_data : AtomicInputOrList , engine : str ) -> Union [ FutureResult , FutureResultGroup ]: \"\"\"Submit a computation to TeraChem Cloud. Parameters: input_data: Defines the structure of the desired computation. engine: A string matching one of the `self.supported_engines` Returns: Object providing access to a computation's eventual result. You can check a computation's status by runing `.status` on the `FutureResult` object or `.get()` to block and retrieve the computation's final result. \"\"\" if self . supported_engines is not None : assert ( engine in self . supported_engines ), f \"Please use one of the following engines: { self . supported_engines } \" return self . _client . compute ( input_data , engine ) compute_procedure ( self , input_data : Union [ qcelemental . models . procedures . OptimizationInput , List [ qcelemental . models . procedures . OptimizationInput ]], procedure : str ) -> Union [ tccloud . models . FutureResult , tccloud . models . FutureResultGroup ] \ud83d\udd17 Submit a procedure computation to TeraChem Cloud Parameters: Name Type Description Default input Defines the inputs for an optimization computation required procedure str The name of the procedure, e.g., 'berny' required Returns: Type Description Union[tccloud.models.FutureResult, tccloud.models.FutureResultGroup] Object providing access to a computation's eventual result. You can check a computation's status by runing .status on the FutureResult object or .get() to block and retrieve the computation's final result. Source code in tccloud/client.py def compute_procedure ( self , input_data : OptimizationInputOrList , procedure : str ) -> Union [ FutureResult , FutureResultGroup ]: \"\"\"Submit a procedure computation to TeraChem Cloud Parameters: input: Defines the inputs for an optimization computation procedure: The name of the procedure, e.g., 'berny' Returns: Object providing access to a computation's eventual result. You can check a computation's status by runing `.status` on the `FutureResult` object or `.get()` to block and retrieve the computation's final result. \"\"\" if self . supported_procedures is not None : assert ( procedure in self . supported_procedures ), f \"Please use one of the following procedures: { self . supported_procedures } \" return self . _client . compute_procedure ( input_data , procedure ) configure ( self , profile : str = 'default' ) -> None \ud83d\udd17 Configure profiles for authentication with TeraChem Cloud. Parameters: Name Type Description Default profile str Optional value to create a named profile for use with TeraChem Cloud. No value needs to be passed and most users will only have one login with TeraChem Cloud. TCClient will access the profile by default without a specific name being passed. Pass a value if you have multiple logins to TeraChem Cloud. 'default' Note Configures tccloud to use the passed credentials automatically in the future. You will not need to run .configure() the next time you use the tccloud . Source code in tccloud/client.py def configure ( self , profile : str = settings . tccloud_default_credentials_profile ) -> None : \"\"\"Configure profiles for authentication with TeraChem Cloud. Parameters: profile: Optional value to create a named profile for use with TeraChem Cloud. No value needs to be passed and most users will only have one login with TeraChem Cloud. TCClient will access the profile by default without a specific name being passed. Pass a value if you have multiple logins to TeraChem Cloud. Note: Configures `tccloud` to use the passed credentials automatically in the future. You will not need to run `.configure()` the next time you use the `tccloud`. \"\"\" print ( f \"\u2705 If you don't get have an account please signup at: { settings . tccloud_domain } /signup\" ) access_token , refresh_token = self . _client . _set_tokens_from_user_input () self . _client . write_tokens_to_credentials_file ( access_token , refresh_token , profile = profile ) print ( f \"' { profile } ' profile configured! Username/password not required for future use of TCClient\" ) hello_world ( self , name : Optional [ str ] = None ) -> str \ud83d\udd17 A simple endpoint to check connectivity to TeraChem Cloud. Parameters: Name Type Description Default name Optional[str] Your name None Returns: Type Description str A message from TeraChem Cloud if the client was able to successfully connect. Source code in tccloud/client.py def hello_world ( self , name : Optional [ str ] = None ) -> str : \"\"\"A simple endpoint to check connectivity to TeraChem Cloud. Parameters: name: Your name Returns: A message from TeraChem Cloud if the client was able to successfully connect. \"\"\" return self . _client . hello_world ( name )","title":"TCClient"},{"location":"code_reference/TCClient/#tcclient","text":"Main client object to perform computations using TeraChem Cloud.","title":"TCClient"},{"location":"code_reference/TCClient/#tccloud.client.TCClient-attributes","text":"","title":"Attributes"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.profile","text":"Profile being used for authentication with TeraChem Cloud. Returns: Type Description str The name of the name of the credentials profile being used with the current client. NOTE: This is a note!","title":"profile"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.supported_engines","text":"Compute engines currently supported by TeraChem Cloud. Returns: Type Description List[str] List of engines currently supported by TeraChem Cloud.","title":"supported_engines"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.supported_procedures","text":"Compute procedures currently supported by TeraChem Cloud. Returns: Type Description List[str] List of procedures currently supported by TeraChem Cloud.","title":"supported_procedures"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.version","text":"Return tccloud version","title":"version"},{"location":"code_reference/TCClient/#tccloud.client.TCClient-methods","text":"","title":"Methods"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.__init__","text":"Initialize a TCClient object. Parameters: Name Type Description Default tccloud_username Optional[str] TeraChem Cloud username None tccloud_password Optional[str] TeraChem Cloud password None profile Optional[str] Authentication profile name None tccloud_domain Optional[str] Domain of TeraChem Cloud instance to connect to None Danger It is not recommended to pass your TeraChem Cloud username and password directly to a TCClient . Instead instantiate a client with no credentials client = TCClient() and then run client.configure() to securely set up your authentication credentials for TeraChem Cloud. Source code in tccloud/client.py def __init__ ( self , * , tccloud_username : Optional [ str ] = None , tccloud_password : Optional [ str ] = None , profile : Optional [ str ] = None , tccloud_domain : Optional [ str ] = None , ): \"\"\" Initialize a TCClient object. Parameters: tccloud_username: TeraChem Cloud username tccloud_password: TeraChem Cloud password profile: Authentication profile name tccloud_domain: Domain of TeraChem Cloud instance to connect to !!! Danger It is not recommended to pass your TeraChem Cloud username and password directly to a `TCClient`. Instead instantiate a client with no credentials `client = TCClient()` and then run `client.configure()` to securely set up your authentication credentials for TeraChem Cloud. \"\"\" self . _client = _RequestsClient ( tccloud_username = tccloud_username , tccloud_password = tccloud_password , profile = profile , tccloud_domain = tccloud_domain , ) self . _openapi_spec : Optional [ Dict ] = None","title":"__init__()"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.compute","text":"Submit a computation to TeraChem Cloud. Parameters: Name Type Description Default input_data Union[qcelemental.models.results.AtomicInput, List[qcelemental.models.results.AtomicInput]] Defines the structure of the desired computation. required engine str A string matching one of the self.supported_engines required Returns: Type Description Union[tccloud.models.FutureResult, tccloud.models.FutureResultGroup] Object providing access to a computation's eventual result. You can check a computation's status by runing .status on the FutureResult object or .get() to block and retrieve the computation's final result. Source code in tccloud/client.py def compute ( self , input_data : AtomicInputOrList , engine : str ) -> Union [ FutureResult , FutureResultGroup ]: \"\"\"Submit a computation to TeraChem Cloud. Parameters: input_data: Defines the structure of the desired computation. engine: A string matching one of the `self.supported_engines` Returns: Object providing access to a computation's eventual result. You can check a computation's status by runing `.status` on the `FutureResult` object or `.get()` to block and retrieve the computation's final result. \"\"\" if self . supported_engines is not None : assert ( engine in self . supported_engines ), f \"Please use one of the following engines: { self . supported_engines } \" return self . _client . compute ( input_data , engine )","title":"compute()"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.compute_procedure","text":"Submit a procedure computation to TeraChem Cloud Parameters: Name Type Description Default input Defines the inputs for an optimization computation required procedure str The name of the procedure, e.g., 'berny' required Returns: Type Description Union[tccloud.models.FutureResult, tccloud.models.FutureResultGroup] Object providing access to a computation's eventual result. You can check a computation's status by runing .status on the FutureResult object or .get() to block and retrieve the computation's final result. Source code in tccloud/client.py def compute_procedure ( self , input_data : OptimizationInputOrList , procedure : str ) -> Union [ FutureResult , FutureResultGroup ]: \"\"\"Submit a procedure computation to TeraChem Cloud Parameters: input: Defines the inputs for an optimization computation procedure: The name of the procedure, e.g., 'berny' Returns: Object providing access to a computation's eventual result. You can check a computation's status by runing `.status` on the `FutureResult` object or `.get()` to block and retrieve the computation's final result. \"\"\" if self . supported_procedures is not None : assert ( procedure in self . supported_procedures ), f \"Please use one of the following procedures: { self . supported_procedures } \" return self . _client . compute_procedure ( input_data , procedure )","title":"compute_procedure()"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.configure","text":"Configure profiles for authentication with TeraChem Cloud. Parameters: Name Type Description Default profile str Optional value to create a named profile for use with TeraChem Cloud. No value needs to be passed and most users will only have one login with TeraChem Cloud. TCClient will access the profile by default without a specific name being passed. Pass a value if you have multiple logins to TeraChem Cloud. 'default' Note Configures tccloud to use the passed credentials automatically in the future. You will not need to run .configure() the next time you use the tccloud . Source code in tccloud/client.py def configure ( self , profile : str = settings . tccloud_default_credentials_profile ) -> None : \"\"\"Configure profiles for authentication with TeraChem Cloud. Parameters: profile: Optional value to create a named profile for use with TeraChem Cloud. No value needs to be passed and most users will only have one login with TeraChem Cloud. TCClient will access the profile by default without a specific name being passed. Pass a value if you have multiple logins to TeraChem Cloud. Note: Configures `tccloud` to use the passed credentials automatically in the future. You will not need to run `.configure()` the next time you use the `tccloud`. \"\"\" print ( f \"\u2705 If you don't get have an account please signup at: { settings . tccloud_domain } /signup\" ) access_token , refresh_token = self . _client . _set_tokens_from_user_input () self . _client . write_tokens_to_credentials_file ( access_token , refresh_token , profile = profile ) print ( f \"' { profile } ' profile configured! Username/password not required for future use of TCClient\" )","title":"configure()"},{"location":"code_reference/TCClient/#tccloud.client.TCClient.hello_world","text":"A simple endpoint to check connectivity to TeraChem Cloud. Parameters: Name Type Description Default name Optional[str] Your name None Returns: Type Description str A message from TeraChem Cloud if the client was able to successfully connect. Source code in tccloud/client.py def hello_world ( self , name : Optional [ str ] = None ) -> str : \"\"\"A simple endpoint to check connectivity to TeraChem Cloud. Parameters: name: Your name Returns: A message from TeraChem Cloud if the client was able to successfully connect. \"\"\" return self . _client . hello_world ( name )","title":"hello_world()"},{"location":"code_reference/exceptions/","text":"Exceptions \ud83d\udd17 Classes \ud83d\udd17 BaseError \ud83d\udd17 Exception Base for client. ComputeError \ud83d\udd17 Some exception was raised with a computation TimeoutError \ud83d\udd17 A timeout parameter was exceeded","title":"Exceptions"},{"location":"code_reference/exceptions/#exceptions","text":"","title":"Exceptions"},{"location":"code_reference/exceptions/#tccloud.exceptions-classes","text":"","title":"Classes"},{"location":"code_reference/exceptions/#tccloud.exceptions.BaseError","text":"Exception Base for client.","title":"BaseError"},{"location":"code_reference/exceptions/#tccloud.exceptions.ComputeError","text":"Some exception was raised with a computation","title":"ComputeError"},{"location":"code_reference/exceptions/#tccloud.exceptions.TimeoutError","text":"A timeout parameter was exceeded","title":"TimeoutError"},{"location":"development/core_decisions/","text":"Core Development Decisions \ud83d\udd17 _RequestsClient Class \ud83d\udd17 _RequestsClient public http methods (like compute() and result() should always return Python objects. This gives a layer of abstraction between callers who want to think in terms of Python data objects and the _RequestsClient which thinks in terms of http requests and json data structures. I'm starting to have second thoughts about this ^^ decision. It feels like the _RequestsClient is starting to take on too much responsibility. It accepts python data types as parameters, and returns python data types as it if were an end-user class. It isn't. It's meant to be a utility class used by end-user objects such as TCClient and FutureResult objects. I think it should return data more directly from the TeraChem Cloud API and let the other classes handle this data. This becomes more apparent as I add pydantic to my data models and realize I'd rather have them pass rawer data types to the _RequestsClient and then handle the results of an API call inside their own class. Maybe the compute() and compute_procedure() methods on the _RequestsClient should go away and these should live exclusively on the TCClient object which then utilizes request and authenticated_request to access TeraChem Cloud. FutureResult Class \ud83d\udd17 .get() will return either an AtomicResult or a FailedOperation object. From the users perspective they essentially get back a generic \"Result\" object (which will be either an AtomicResult or FailedOperation ) and can check for its status (once complete) by checking result.status . While this separates the user a bit from the \"status\" field returned by the API, I think this is the easiest user interface, i.e., they get back a result from a future_result and can check its status very simply without having to think separately about status fields and results fields They can still access the API returned status field at future_result.status if needed. E.g.,: result = future_result . get () result . success False # If FailedOperation returned result . success True # If AtomicResult returned","title":"Core Development Decisions"},{"location":"development/core_decisions/#core-development-decisions","text":"","title":"Core Development Decisions"},{"location":"development/core_decisions/#_requestsclient-class","text":"_RequestsClient public http methods (like compute() and result() should always return Python objects. This gives a layer of abstraction between callers who want to think in terms of Python data objects and the _RequestsClient which thinks in terms of http requests and json data structures. I'm starting to have second thoughts about this ^^ decision. It feels like the _RequestsClient is starting to take on too much responsibility. It accepts python data types as parameters, and returns python data types as it if were an end-user class. It isn't. It's meant to be a utility class used by end-user objects such as TCClient and FutureResult objects. I think it should return data more directly from the TeraChem Cloud API and let the other classes handle this data. This becomes more apparent as I add pydantic to my data models and realize I'd rather have them pass rawer data types to the _RequestsClient and then handle the results of an API call inside their own class. Maybe the compute() and compute_procedure() methods on the _RequestsClient should go away and these should live exclusively on the TCClient object which then utilizes request and authenticated_request to access TeraChem Cloud.","title":"_RequestsClient Class"},{"location":"development/core_decisions/#futureresult-class","text":".get() will return either an AtomicResult or a FailedOperation object. From the users perspective they essentially get back a generic \"Result\" object (which will be either an AtomicResult or FailedOperation ) and can check for its status (once complete) by checking result.status . While this separates the user a bit from the \"status\" field returned by the API, I think this is the easiest user interface, i.e., they get back a result from a future_result and can check its status very simply without having to think separately about status fields and results fields They can still access the API returned status field at future_result.status if needed. E.g.,: result = future_result . get () result . success False # If FailedOperation returned result . success True # If AtomicResult returned","title":"FutureResult Class"},{"location":"tutorial/authentication/","text":"Authentication \ud83d\udd17 Authentication is the process of supplying your credentials (usually a username and password) to tccloud so that you can perform computation. tccloud provides a few easy ways for you to authenticate. If you do not have a TeraChem Cloud account you can get one for free here: https://tccloud.mtzlab.com/signup Username and Password \ud83d\udd17 client.configure() (recommended for most cases) \ud83d\udd17 >>> from tccloud import TCClient >>> client = TCClient () >>> client . configure () \u2705 If you dont get have an account please signup at : https : // tccloud . mtzlab . com / signup Please enter your TeraChem Cloud username : your_username @email . com Please enter your TeraChem Cloud password : Authenticating ... 'default' profile configured ! Username / password not required for future use of TCClient Performing this action will configure your local client by writing authentication tokens to ~/.tccloud/credentials . You will not need to execute configure() ever again. Under the hood TCClient will access your tokens, refresh them when necessary, and keep you logged in to TeraChem Cloud. Note that this will write a file to your home directory with sensitive access tokens, so if you are on a shared computer or using a device where you would not want to write this information to disk do not use this option. If you would like to write the credentials file to a different directory than ~/.tccloud , set the TCCLOUD_BASE_DIRECTORY environment variable to the path of interest. You can configure multiple profiles in case you have multiple logins to TeraChem cloud by passing a profile name to configure() : >>> client . configure ( 'mtz_lab' ) \u2705 If you dont get have an account please signup at : https : // tccloud . mtzlab . com / signup Please enter your TeraChem Cloud username : your_username @email . om Please enter your TeraChem Cloud password : Authenticating ... 'mtz_lab' profile configured ! Username / password not required for future use of TCClient To use one of these profiles pass the profile option to your client instance. The \"default\" profile is used when no profile name is passed: >>> from tccloud import TCClient # Use default profile >>> client = TCClient () # Use named profile >>> client = TCClient ( profile = \"mtz_lab\" ) Environment Variables \ud83d\udd17 You can set your TeraChem username and password in your environment and the client will find them automatically. Set TCCLOUD_USERNAME and TCCLOUD_PASSWORD . When you create a client it will find these values and maintain all access tokens in memory only. Pass Username/Password when prompted after requesting a compute job \ud83d\udd17 If you have not run client.configure() or set environment variables you will be requested for your username and password when you submit a computation to TeraChem Cloud using client.compute(...) . The client will use your username and password to get access tokens and will maintain access tokens for you in memory only. Your login session will be valid for the duration of your python session. Pass Username/Password to Client (not recommended) \ud83d\udd17 You can directly pass a username and password to the client object. This is not recommended as it opens up the possibility of your credentials accidentally being committed to your code repo. However, it can be used in rare circumstances when necessary. >>> from tccloud import TCClient >>> client = TCClient ( tccloud_username = \"your_username@email.com\" , tccloud_password = \"super_secret_password\" )","title":"Authentication"},{"location":"tutorial/authentication/#authentication","text":"Authentication is the process of supplying your credentials (usually a username and password) to tccloud so that you can perform computation. tccloud provides a few easy ways for you to authenticate. If you do not have a TeraChem Cloud account you can get one for free here: https://tccloud.mtzlab.com/signup","title":"Authentication"},{"location":"tutorial/authentication/#username-and-password","text":"","title":"Username and Password"},{"location":"tutorial/authentication/#clientconfigure-recommended-for-most-cases","text":">>> from tccloud import TCClient >>> client = TCClient () >>> client . configure () \u2705 If you dont get have an account please signup at : https : // tccloud . mtzlab . com / signup Please enter your TeraChem Cloud username : your_username @email . com Please enter your TeraChem Cloud password : Authenticating ... 'default' profile configured ! Username / password not required for future use of TCClient Performing this action will configure your local client by writing authentication tokens to ~/.tccloud/credentials . You will not need to execute configure() ever again. Under the hood TCClient will access your tokens, refresh them when necessary, and keep you logged in to TeraChem Cloud. Note that this will write a file to your home directory with sensitive access tokens, so if you are on a shared computer or using a device where you would not want to write this information to disk do not use this option. If you would like to write the credentials file to a different directory than ~/.tccloud , set the TCCLOUD_BASE_DIRECTORY environment variable to the path of interest. You can configure multiple profiles in case you have multiple logins to TeraChem cloud by passing a profile name to configure() : >>> client . configure ( 'mtz_lab' ) \u2705 If you dont get have an account please signup at : https : // tccloud . mtzlab . com / signup Please enter your TeraChem Cloud username : your_username @email . om Please enter your TeraChem Cloud password : Authenticating ... 'mtz_lab' profile configured ! Username / password not required for future use of TCClient To use one of these profiles pass the profile option to your client instance. The \"default\" profile is used when no profile name is passed: >>> from tccloud import TCClient # Use default profile >>> client = TCClient () # Use named profile >>> client = TCClient ( profile = \"mtz_lab\" )","title":"client.configure() (recommended for most cases)"},{"location":"tutorial/authentication/#environment-variables","text":"You can set your TeraChem username and password in your environment and the client will find them automatically. Set TCCLOUD_USERNAME and TCCLOUD_PASSWORD . When you create a client it will find these values and maintain all access tokens in memory only.","title":"Environment Variables"},{"location":"tutorial/authentication/#pass-usernamepassword-when-prompted-after-requesting-a-compute-job","text":"If you have not run client.configure() or set environment variables you will be requested for your username and password when you submit a computation to TeraChem Cloud using client.compute(...) . The client will use your username and password to get access tokens and will maintain access tokens for you in memory only. Your login session will be valid for the duration of your python session.","title":"Pass Username/Password when prompted after requesting a compute job"},{"location":"tutorial/authentication/#pass-usernamepassword-to-client-not-recommended","text":"You can directly pass a username and password to the client object. This is not recommended as it opens up the possibility of your credentials accidentally being committed to your code repo. However, it can be used in rare circumstances when necessary. >>> from tccloud import TCClient >>> client = TCClient ( tccloud_username = \"your_username@email.com\" , tccloud_password = \"super_secret_password\" )","title":"Pass Username/Password to Client (not recommended)"},{"location":"tutorial/batch_computations/","text":"Batch Computations \ud83d\udd17 Both single point and geometry optimizations can be performed in bulk by submitting up to 100 computations simultaneously. Simply submit an array of AtomicInputs or OptimizationInput objects as input data. from tccloud import TCClient from tccloud.models import AtomicInput , Molecule client = TCClient () water = Molecule . from_data ( \"pubchem:water\" ) atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"energy\" , keywords = { \"closed\" : True , \"restricted\" : True , }, ) future_result = client . compute ([ atomic_input ] * 2 , engine = \"terachem_pbs\" ) result = future_result . get () # Array of AtomicResult objects print ( result )","title":"Batch Computations"},{"location":"tutorial/batch_computations/#batch-computations","text":"Both single point and geometry optimizations can be performed in bulk by submitting up to 100 computations simultaneously. Simply submit an array of AtomicInputs or OptimizationInput objects as input data. from tccloud import TCClient from tccloud.models import AtomicInput , Molecule client = TCClient () water = Molecule . from_data ( \"pubchem:water\" ) atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"energy\" , keywords = { \"closed\" : True , \"restricted\" : True , }, ) future_result = client . compute ([ atomic_input ] * 2 , engine = \"terachem_pbs\" ) result = future_result . get () # Array of AtomicResult objects print ( result )","title":"Batch Computations"},{"location":"tutorial/compute/","text":"Compute \ud83d\udd17 Overview \ud83d\udd17 Computations are physically executed on TeraChem Cloud . The tccloud python client submits jobs to and retrieves work from TeraChem Cloud. Computations are submitted using the TCClient object. Computations require an AtomicInput object and the specification of a compute engine. from tccloud import TCClient from tccloud.models import AtomicInput , Molecule client = TCClient () water = Molecule . from_data ( \"pubchem:water\" ) atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"energy\" , keywords = { \"closed\" : True , \"restricted\" : True , }, ) future_result = client . compute ( atomic_input , engine = \"terachem_pbs\" ) result = future_result . get () # AtomicResult object containing all returned data print ( result ) # The energy value requested print ( result . return_result )","title":"Compute"},{"location":"tutorial/compute/#compute","text":"","title":"Compute"},{"location":"tutorial/compute/#overview","text":"Computations are physically executed on TeraChem Cloud . The tccloud python client submits jobs to and retrieves work from TeraChem Cloud. Computations are submitted using the TCClient object. Computations require an AtomicInput object and the specification of a compute engine. from tccloud import TCClient from tccloud.models import AtomicInput , Molecule client = TCClient () water = Molecule . from_data ( \"pubchem:water\" ) atomic_input = AtomicInput ( molecule = water , model = { \"method\" : \"B3LYP\" , \"basis\" : \"6-31g\" }, driver = \"energy\" , keywords = { \"closed\" : True , \"restricted\" : True , }, ) future_result = client . compute ( atomic_input , engine = \"terachem_pbs\" ) result = future_result . get () # AtomicResult object containing all returned data print ( result ) # The energy value requested print ( result . return_result )","title":"Overview"},{"location":"tutorial/compute_engines/","text":"Compute Engines \ud83d\udd17 Supported compute engines in tccloud can be checked as follows: from tccloud import TCClient client = TCClient () client . supported_engines [ \"psi4\" , \"terachem_pbs\" , \"rdkit\" , ... ] Keywords \ud83d\udd17 Keywords specific to a quantum chemistry engine can be added to an AtomicInput as follows: ai = AtomicInput ( ... , keywords = { \"molden\" : True , \"restricted\" : True , ... } ) TeraChem \ud83d\udd17 Relevant keywords \ud83d\udd17 Keyword Type Description Default Value molden bool If True with mo_ouput=True the result.extras[\"molden\"] field will contain a string of the molden file False mo_output bool Request atomic orbital and molecular orbital information. Needs to be set to True to generate data required for molden file False convthre float Convergence threshold for SCF calculations 3.0e-5 precision str Can be single , double , mixed or other values Unknown dftgrid int Speeds up a computation somehow. 0 makes things quicker Unknown restricted bool Restricted computation True closed bool Closed shell True Psi4 \ud83d\udd17 rdkit \ud83d\udd17 xtb \ud83d\udd17 xtb specific documentation on how to run calculations using the QCSchema specification used TeraChem Cloud can be found here and here .","title":"Compute Engines"},{"location":"tutorial/compute_engines/#compute-engines","text":"Supported compute engines in tccloud can be checked as follows: from tccloud import TCClient client = TCClient () client . supported_engines [ \"psi4\" , \"terachem_pbs\" , \"rdkit\" , ... ]","title":"Compute Engines"},{"location":"tutorial/compute_engines/#keywords","text":"Keywords specific to a quantum chemistry engine can be added to an AtomicInput as follows: ai = AtomicInput ( ... , keywords = { \"molden\" : True , \"restricted\" : True , ... } )","title":"Keywords"},{"location":"tutorial/compute_engines/#terachem","text":"","title":"TeraChem"},{"location":"tutorial/compute_engines/#relevant-keywords","text":"Keyword Type Description Default Value molden bool If True with mo_ouput=True the result.extras[\"molden\"] field will contain a string of the molden file False mo_output bool Request atomic orbital and molecular orbital information. Needs to be set to True to generate data required for molden file False convthre float Convergence threshold for SCF calculations 3.0e-5 precision str Can be single , double , mixed or other values Unknown dftgrid int Speeds up a computation somehow. 0 makes things quicker Unknown restricted bool Restricted computation True closed bool Closed shell True","title":"Relevant keywords"},{"location":"tutorial/compute_engines/#psi4","text":"","title":"Psi4"},{"location":"tutorial/compute_engines/#rdkit","text":"","title":"rdkit"},{"location":"tutorial/compute_engines/#xtb","text":"xtb specific documentation on how to run calculations using the QCSchema specification used TeraChem Cloud can be found here and here .","title":"xtb"},{"location":"tutorial/geometry_optimization/","text":"Geometry Optimization \ud83d\udd17 Basic Working Example \ud83d\udd17 Create a Molecule Define parameters for the compute engine Define the optimization parameters for the optimizer and specify the compute engine Specify the optimizer to run from pprint import pprint from tccloud import TCClient from tccloud.models import Molecule , OptimizationInput , QCInputSpecification client = TCClient () water = Molecule . from_data ( \"pubchem:water\" ) input_spec = QCInputSpecification ( model = { \"method\" : \"b3lyp\" , \"basis\" : \"6-31g\" }, # Keywords for the compute engine (e.g., psi4, terachem_pbs) keywords = {}, ) opt_input = OptimizationInput ( initial_molecule = water , input_specification = input_spec , # Trajectory molecules to include in result, may be one of: # 'all' or 'initial_and_final' or 'final' or 'none' protocols = { \"trajectory\" : \"all\" }, # Must define compute engine \"program\": \"engine_name\" # Define keywords for optimizer (pyberny or geomeTRIC) keywords = { \"program\" : \"terachem_pbs\" , \"maxsteps\" : 3 }, ) # Optimizer can be \"berny\" or \"geometric\" future_result = client . compute_procedure ( opt_input , \"berny\" ) result = future_result . get () if result . success : print ( \"Optimization succeeded!\" ) # Will be OptimizationResult object print ( result ) # The final molecule of the geometry optimization print ( result . final_molecule ) # Initial molecule print ( result . initial_molecule ) # A list of ordered AtomicResult objects for each step in the optimization print ( result . trajectory ) # A list of ordered energies for each step in the optimization print ( result . energies ) else : print ( \"Optimization failed!\" ) # Will be FailedOperation object print ( result ) # Error information print ( result . error ) # Detailed error message pprint ( result . error . error_message ) Using Force Fields \ud83d\udd17 rdkit can be specified as a compute backend to perform optimizations using force field methods instead of quantum chemistry backends. To use rdkit force field methods simply modify the model specification and program specification as shown below. Also note that rdkit requires the molecular connectivity to be defined. # Hack to quickly drop in water's connectivity water = Molecule . from_data ( \"pubchem:water\" ) water = Molecule ( ** { ** water . dict (), \"connectivity\" : [( 0 , 1 , 1.0 ), ( 0 , 2 , 1.0 )]}) input_spec = QCInputSpecification ( ... model = { \"method\" : \"UFF\" } # or any other force field ) opt_input = OptimizationInput ( ... keywords = { \"program\" : \"rdkit\" }, ) future_result = client . compute_procedure ( opt_input , \"geometric\" ) Berny Specifics \ud83d\udd17 The berny procedure uses the pyberny package to perform a geometry optimization. berny specific keywords are subject to change as the berny package evolves, but for simplicity a short list is included here with default values noted: Keyword Description Default Value maxsteps Maximum number of steps in the optimization 100 gradientmax Convergence criteria (AU) 0.45e-3 gradientrms Convergence criteria (AU) 0.15e-3 stepmax Step in internal coordinates, assuming radian units for angles (AU) 1.8e-3 steprms Step in internal coordinates, assuming radian units for angles (AU) 0.45e-3 trust Initial trust radius in AU. It is the maximum RMS of the quadratic step 0.3 dihedral Form dihedral angles True superweakdih Form dihedral angles containing two or more noncovalent bonds False geomeTRIC Specifics \ud83d\udd17 The geometric procedure uses the geomeTRIC package to perform a geometry optimization. geomeTRIC specific keywords are subject to change as the geomeTRIC package evolves. Since geomeTRIC has considerably more keywords, here's the source code that defines varous parameters for an optimization. Keywords noted below can be included in the OptimizationInput keywords dictionary. If these options are overwhelming, keep in mind you can run both the berny and geometric optimizers without any keywords and the optimizers will use sensible defaults. class OptParams ( object ): \"\"\" Container for optimization parameters. The parameters used to be contained in the command-line \"args\", but this was dropped in order to call Optimize() from another script. \"\"\" def __init__ ( self , ** kwargs ): # Whether we are optimizing for a transition state. This changes a number of default parameters. self . transition = kwargs . get ( 'transition' , False ) # CI optimizations sometimes require tiny steps self . meci = kwargs . get ( 'meci' , False ) # Handle convergence criteria; this edits the kwargs self . convergence_criteria ( ** kwargs ) # Threshold (in a.u. / rad) for activating alternative algorithm that enforces precise constraint satisfaction self . enforce = kwargs . get ( 'enforce' , 0.0 ) # Small eigenvalue threshold self . epsilon = kwargs . get ( 'epsilon' , 1e-5 ) # Interval for checking the coordinate system for changes self . check = kwargs . get ( 'check' , 0 ) # More verbose printout self . verbose = kwargs . get ( 'verbose' , False ) # Starting value of the trust radius # Because TS optimization is experimental, use conservative trust radii self . trust = kwargs . get ( 'trust' , 0.01 if self . transition else 0.1 ) # Maximum value of trust radius self . tmax = kwargs . get ( 'tmax' , 0.03 if self . transition else 0.3 ) # Minimum value of the trust radius self . tmin = kwargs . get ( 'tmin' , 0.0 if ( self . transition or self . meci ) else min ( 1.2e-3 , self . Convergence_drms )) # Minimum size of a step that can be rejected self . thre_rj = kwargs . get ( 'thre_rj' , 1e-4 if ( self . transition or self . meci ) else 1e-2 ) # Sanity checks on trust radius if self . tmax < self . tmin : raise ParamError ( \"Max trust radius must be larger than min\" ) # The trust radius should not be outside (tmin, tmax) self . trust = min ( self . tmax , self . trust ) self . trust = max ( self . tmin , self . trust ) # Maximum number of optimization cycles self . maxiter = kwargs . get ( 'maxiter' , 300 ) # Use updated constraint algorithm implemented 2019-03-20 self . conmethod = kwargs . get ( 'conmethod' , 0 ) # Write Hessian matrix at optimized structure to text file self . write_cart_hess = kwargs . get ( 'write_cart_hess' , None ) # Output .xyz file name may be set separately in # run_optimizer() prior to calling Optimize(). self . xyzout = kwargs . get ( 'xyzout' , None ) # Name of the qdata.txt file to be written. # The CLI is designed so the user passes true/false instead of the file name. self . qdata = 'qdata.txt' if kwargs . get ( 'qdata' , False ) else None # Whether to calculate or read a Hessian matrix. self . hessian = kwargs . get ( 'hessian' , None ) if self . hessian is None : # Default is to calculate Hessian in the first step if searching for a transition state. # Otherwise the default is to never calculate the Hessian. if self . transition : self . hessian = 'first' else : self . hessian = 'never' if self . hessian . startswith ( 'file:' ): if os . path . exists ( self . hessian [ 5 :]): # If a path is provided for reading a Hessian file, read it now. self . hess_data = np . loadtxt ( self . hessian [ 5 :]) else : raise IOError ( \"No Hessian data file found at %s \" % self . hessian ) elif self . hessian . lower () in [ 'never' , 'first' , 'each' , 'stop' , 'last' , 'first+last' ]: self . hessian = self . hessian . lower () else : raise RuntimeError ( \"Hessian command line argument can only be never, first, last, first+last, each, stop, or file:<path>\" ) # Perform a frequency analysis whenever a cartesian Hessian is computed self . frequency = kwargs . get ( 'frequency' , None ) if self . frequency is None : self . frequency = True # Temperature and pressure for harmonic free energy self . temperature , self . pressure = kwargs . get ( 'thermo' , [ 300.0 , 1.0 ]) # Number of desired samples from Wigner distribution self . wigner = kwargs . get ( 'wigner' , 0 ) if self . wigner and not self . frequency : raise ParamError ( 'Wigner sampling requires frequency analysis' ) # Reset Hessian to guess whenever eigenvalues drop below epsilon self . reset = kwargs . get ( 'reset' , None ) if self . reset is None : self . reset = not ( self . transition or self . meci or self . hessian == 'each' ) And convergence criteria: def convergence_criteria ( self , ** kwargs ): criteria = kwargs . get ( 'converge' , []) if len ( criteria ) % 2 != 0 : raise RuntimeError ( 'Please pass an even number of options to --converge' ) for i in range ( int ( len ( criteria ) / 2 )): key = 'convergence_' + criteria [ 2 * i ] . lower () try : val = float ( criteria [ 2 * i + 1 ]) logger . info ( 'Using convergence criteria: %s %.2e \\n ' % ( key , val )) except ValueError : # This must be a set val = str ( criteria [ 2 * i + 1 ]) logger . info ( 'Using convergence criteria set: %s %s \\n ' % ( key , val )) kwargs [ key ] = val # convergence dictionary to store criteria stored in order of energy, grms, gmax, drms, dmax # 'GAU' contains the default convergence criteria that are used when nothing is passed. convergence_sets = { 'GAU' : [ 1e-6 , 3e-4 , 4.5e-4 , 1.2e-3 , 1.8e-3 ], 'NWCHEM_LOOSE' : [ 1e-6 , 3e-3 , 4.5e-3 , 3.6e-3 , 5.4e-3 ], 'GAU_LOOSE' : [ 1e-6 , 1.7e-3 , 2.5e-3 , 6.7e-3 , 1e-2 ], 'TURBOMOLE' : [ 1e-6 , 5e-4 , 1e-3 , 5.0e-4 , 1e-3 ], 'INTERFRAG_TIGHT' : [ 1e-6 , 1e-5 , 1.5e-5 , 4.0e-4 , 6.0e-4 ], 'GAU_TIGHT' : [ 1e-6 , 1e-5 , 1.5e-5 , 4e-5 , 6e-5 ], 'GAU_VERYTIGHT' : [ 1e-6 , 1e-6 , 2e-6 , 4e-6 , 6e-6 ]} # Q-Chem style convergence criteria (i.e. gradient and either energy or displacement) self . qccnv = kwargs . get ( 'qccnv' , False ) # Molpro style convergence criteria (i.e. gradient and either energy or displacement, with different defaults) self . molcnv = kwargs . get ( 'molcnv' , False ) # Check if there is a convergence set passed else use the default set_name = kwargs . get ( 'convergence_set' , 'GAU' ) . upper () # If we have extra keywords apply them here else use the set # Convergence criteria in a.u. and Angstrom self . Convergence_energy = kwargs . get ( 'convergence_energy' , convergence_sets [ set_name ][ 0 ]) self . Convergence_grms = kwargs . get ( 'convergence_grms' , convergence_sets [ set_name ][ 1 ]) self . Convergence_gmax = kwargs . get ( 'convergence_gmax' , convergence_sets [ set_name ][ 2 ]) self . Convergence_drms = kwargs . get ( 'convergence_drms' , convergence_sets [ set_name ][ 3 ]) self . Convergence_dmax = kwargs . get ( 'convergence_dmax' , convergence_sets [ set_name ][ 4 ]) # Convergence criteria that are only used if molconv is set to True self . Convergence_molpro_gmax = kwargs . get ( 'convergence_molpro_gmax' , 3e-4 ) self . Convergence_molpro_dmax = kwargs . get ( 'convergence_molpro_dmax' , 1.2e-3 )","title":"Geometry Optimization"},{"location":"tutorial/geometry_optimization/#geometry-optimization","text":"","title":"Geometry Optimization"},{"location":"tutorial/geometry_optimization/#basic-working-example","text":"Create a Molecule Define parameters for the compute engine Define the optimization parameters for the optimizer and specify the compute engine Specify the optimizer to run from pprint import pprint from tccloud import TCClient from tccloud.models import Molecule , OptimizationInput , QCInputSpecification client = TCClient () water = Molecule . from_data ( \"pubchem:water\" ) input_spec = QCInputSpecification ( model = { \"method\" : \"b3lyp\" , \"basis\" : \"6-31g\" }, # Keywords for the compute engine (e.g., psi4, terachem_pbs) keywords = {}, ) opt_input = OptimizationInput ( initial_molecule = water , input_specification = input_spec , # Trajectory molecules to include in result, may be one of: # 'all' or 'initial_and_final' or 'final' or 'none' protocols = { \"trajectory\" : \"all\" }, # Must define compute engine \"program\": \"engine_name\" # Define keywords for optimizer (pyberny or geomeTRIC) keywords = { \"program\" : \"terachem_pbs\" , \"maxsteps\" : 3 }, ) # Optimizer can be \"berny\" or \"geometric\" future_result = client . compute_procedure ( opt_input , \"berny\" ) result = future_result . get () if result . success : print ( \"Optimization succeeded!\" ) # Will be OptimizationResult object print ( result ) # The final molecule of the geometry optimization print ( result . final_molecule ) # Initial molecule print ( result . initial_molecule ) # A list of ordered AtomicResult objects for each step in the optimization print ( result . trajectory ) # A list of ordered energies for each step in the optimization print ( result . energies ) else : print ( \"Optimization failed!\" ) # Will be FailedOperation object print ( result ) # Error information print ( result . error ) # Detailed error message pprint ( result . error . error_message )","title":"Basic Working Example"},{"location":"tutorial/geometry_optimization/#using-force-fields","text":"rdkit can be specified as a compute backend to perform optimizations using force field methods instead of quantum chemistry backends. To use rdkit force field methods simply modify the model specification and program specification as shown below. Also note that rdkit requires the molecular connectivity to be defined. # Hack to quickly drop in water's connectivity water = Molecule . from_data ( \"pubchem:water\" ) water = Molecule ( ** { ** water . dict (), \"connectivity\" : [( 0 , 1 , 1.0 ), ( 0 , 2 , 1.0 )]}) input_spec = QCInputSpecification ( ... model = { \"method\" : \"UFF\" } # or any other force field ) opt_input = OptimizationInput ( ... keywords = { \"program\" : \"rdkit\" }, ) future_result = client . compute_procedure ( opt_input , \"geometric\" )","title":"Using Force Fields"},{"location":"tutorial/geometry_optimization/#berny-specifics","text":"The berny procedure uses the pyberny package to perform a geometry optimization. berny specific keywords are subject to change as the berny package evolves, but for simplicity a short list is included here with default values noted: Keyword Description Default Value maxsteps Maximum number of steps in the optimization 100 gradientmax Convergence criteria (AU) 0.45e-3 gradientrms Convergence criteria (AU) 0.15e-3 stepmax Step in internal coordinates, assuming radian units for angles (AU) 1.8e-3 steprms Step in internal coordinates, assuming radian units for angles (AU) 0.45e-3 trust Initial trust radius in AU. It is the maximum RMS of the quadratic step 0.3 dihedral Form dihedral angles True superweakdih Form dihedral angles containing two or more noncovalent bonds False","title":"Berny Specifics"},{"location":"tutorial/geometry_optimization/#geometric-specifics","text":"The geometric procedure uses the geomeTRIC package to perform a geometry optimization. geomeTRIC specific keywords are subject to change as the geomeTRIC package evolves. Since geomeTRIC has considerably more keywords, here's the source code that defines varous parameters for an optimization. Keywords noted below can be included in the OptimizationInput keywords dictionary. If these options are overwhelming, keep in mind you can run both the berny and geometric optimizers without any keywords and the optimizers will use sensible defaults. class OptParams ( object ): \"\"\" Container for optimization parameters. The parameters used to be contained in the command-line \"args\", but this was dropped in order to call Optimize() from another script. \"\"\" def __init__ ( self , ** kwargs ): # Whether we are optimizing for a transition state. This changes a number of default parameters. self . transition = kwargs . get ( 'transition' , False ) # CI optimizations sometimes require tiny steps self . meci = kwargs . get ( 'meci' , False ) # Handle convergence criteria; this edits the kwargs self . convergence_criteria ( ** kwargs ) # Threshold (in a.u. / rad) for activating alternative algorithm that enforces precise constraint satisfaction self . enforce = kwargs . get ( 'enforce' , 0.0 ) # Small eigenvalue threshold self . epsilon = kwargs . get ( 'epsilon' , 1e-5 ) # Interval for checking the coordinate system for changes self . check = kwargs . get ( 'check' , 0 ) # More verbose printout self . verbose = kwargs . get ( 'verbose' , False ) # Starting value of the trust radius # Because TS optimization is experimental, use conservative trust radii self . trust = kwargs . get ( 'trust' , 0.01 if self . transition else 0.1 ) # Maximum value of trust radius self . tmax = kwargs . get ( 'tmax' , 0.03 if self . transition else 0.3 ) # Minimum value of the trust radius self . tmin = kwargs . get ( 'tmin' , 0.0 if ( self . transition or self . meci ) else min ( 1.2e-3 , self . Convergence_drms )) # Minimum size of a step that can be rejected self . thre_rj = kwargs . get ( 'thre_rj' , 1e-4 if ( self . transition or self . meci ) else 1e-2 ) # Sanity checks on trust radius if self . tmax < self . tmin : raise ParamError ( \"Max trust radius must be larger than min\" ) # The trust radius should not be outside (tmin, tmax) self . trust = min ( self . tmax , self . trust ) self . trust = max ( self . tmin , self . trust ) # Maximum number of optimization cycles self . maxiter = kwargs . get ( 'maxiter' , 300 ) # Use updated constraint algorithm implemented 2019-03-20 self . conmethod = kwargs . get ( 'conmethod' , 0 ) # Write Hessian matrix at optimized structure to text file self . write_cart_hess = kwargs . get ( 'write_cart_hess' , None ) # Output .xyz file name may be set separately in # run_optimizer() prior to calling Optimize(). self . xyzout = kwargs . get ( 'xyzout' , None ) # Name of the qdata.txt file to be written. # The CLI is designed so the user passes true/false instead of the file name. self . qdata = 'qdata.txt' if kwargs . get ( 'qdata' , False ) else None # Whether to calculate or read a Hessian matrix. self . hessian = kwargs . get ( 'hessian' , None ) if self . hessian is None : # Default is to calculate Hessian in the first step if searching for a transition state. # Otherwise the default is to never calculate the Hessian. if self . transition : self . hessian = 'first' else : self . hessian = 'never' if self . hessian . startswith ( 'file:' ): if os . path . exists ( self . hessian [ 5 :]): # If a path is provided for reading a Hessian file, read it now. self . hess_data = np . loadtxt ( self . hessian [ 5 :]) else : raise IOError ( \"No Hessian data file found at %s \" % self . hessian ) elif self . hessian . lower () in [ 'never' , 'first' , 'each' , 'stop' , 'last' , 'first+last' ]: self . hessian = self . hessian . lower () else : raise RuntimeError ( \"Hessian command line argument can only be never, first, last, first+last, each, stop, or file:<path>\" ) # Perform a frequency analysis whenever a cartesian Hessian is computed self . frequency = kwargs . get ( 'frequency' , None ) if self . frequency is None : self . frequency = True # Temperature and pressure for harmonic free energy self . temperature , self . pressure = kwargs . get ( 'thermo' , [ 300.0 , 1.0 ]) # Number of desired samples from Wigner distribution self . wigner = kwargs . get ( 'wigner' , 0 ) if self . wigner and not self . frequency : raise ParamError ( 'Wigner sampling requires frequency analysis' ) # Reset Hessian to guess whenever eigenvalues drop below epsilon self . reset = kwargs . get ( 'reset' , None ) if self . reset is None : self . reset = not ( self . transition or self . meci or self . hessian == 'each' ) And convergence criteria: def convergence_criteria ( self , ** kwargs ): criteria = kwargs . get ( 'converge' , []) if len ( criteria ) % 2 != 0 : raise RuntimeError ( 'Please pass an even number of options to --converge' ) for i in range ( int ( len ( criteria ) / 2 )): key = 'convergence_' + criteria [ 2 * i ] . lower () try : val = float ( criteria [ 2 * i + 1 ]) logger . info ( 'Using convergence criteria: %s %.2e \\n ' % ( key , val )) except ValueError : # This must be a set val = str ( criteria [ 2 * i + 1 ]) logger . info ( 'Using convergence criteria set: %s %s \\n ' % ( key , val )) kwargs [ key ] = val # convergence dictionary to store criteria stored in order of energy, grms, gmax, drms, dmax # 'GAU' contains the default convergence criteria that are used when nothing is passed. convergence_sets = { 'GAU' : [ 1e-6 , 3e-4 , 4.5e-4 , 1.2e-3 , 1.8e-3 ], 'NWCHEM_LOOSE' : [ 1e-6 , 3e-3 , 4.5e-3 , 3.6e-3 , 5.4e-3 ], 'GAU_LOOSE' : [ 1e-6 , 1.7e-3 , 2.5e-3 , 6.7e-3 , 1e-2 ], 'TURBOMOLE' : [ 1e-6 , 5e-4 , 1e-3 , 5.0e-4 , 1e-3 ], 'INTERFRAG_TIGHT' : [ 1e-6 , 1e-5 , 1.5e-5 , 4.0e-4 , 6.0e-4 ], 'GAU_TIGHT' : [ 1e-6 , 1e-5 , 1.5e-5 , 4e-5 , 6e-5 ], 'GAU_VERYTIGHT' : [ 1e-6 , 1e-6 , 2e-6 , 4e-6 , 6e-6 ]} # Q-Chem style convergence criteria (i.e. gradient and either energy or displacement) self . qccnv = kwargs . get ( 'qccnv' , False ) # Molpro style convergence criteria (i.e. gradient and either energy or displacement, with different defaults) self . molcnv = kwargs . get ( 'molcnv' , False ) # Check if there is a convergence set passed else use the default set_name = kwargs . get ( 'convergence_set' , 'GAU' ) . upper () # If we have extra keywords apply them here else use the set # Convergence criteria in a.u. and Angstrom self . Convergence_energy = kwargs . get ( 'convergence_energy' , convergence_sets [ set_name ][ 0 ]) self . Convergence_grms = kwargs . get ( 'convergence_grms' , convergence_sets [ set_name ][ 1 ]) self . Convergence_gmax = kwargs . get ( 'convergence_gmax' , convergence_sets [ set_name ][ 2 ]) self . Convergence_drms = kwargs . get ( 'convergence_drms' , convergence_sets [ set_name ][ 3 ]) self . Convergence_dmax = kwargs . get ( 'convergence_dmax' , convergence_sets [ set_name ][ 4 ]) # Convergence criteria that are only used if molconv is set to True self . Convergence_molpro_gmax = kwargs . get ( 'convergence_molpro_gmax' , 3e-4 ) self . Convergence_molpro_dmax = kwargs . get ( 'convergence_molpro_dmax' , 1.2e-3 )","title":"geomeTRIC Specifics"}]}