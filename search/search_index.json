{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tccloud A Python Client for TeraChem Cloud. tccloud is a python client that makes performing quantum chemistry calculations easy, fast, and fun. All input and output data structures are based on the QCSchema specification designed by The Molecular Sciences Software Institute . The client provides a simple, yet powerful interface to perform quantum chemistry calculation using nothing but modern python and an internet connection. Compute is generously provided free of charge by the TeraChem Cloud project. Requirements Python 3.6+ tccloud stands on the shoulders of giants. It internally depends upon QCElemental , httpx , and toml . The AtomicInput , Molecule , Model , and AtomicResult models used throughout the package come directly from QCElemental . They are included in tccloud.models for your convenience. Installation pip install tccloud Example The Absolute Minimum Create a TeraChem Cloud account at https://tccloud.mtzlab.com/signup. Instantiate a client Configure client (only required the very first time you use TCClient ) >>> from tccloud import TCClient >>> client = TCClient() >>> client.configure() # See supported compute engines >>> client.supported_engines ['psi4', 'terachem_pbs', ...] # Test connection to TeraChem Cloud >>> client.hello_world(\"Colton\") 'Welcome to TeraChem Cloud, Colton' Create a Molecule More details about the Molecule object can be found here and here . Molecules can be created from pubchem , local files, or using pure python. >>> from tccloud.models import Molecule >>> water = Molecule.from_data(\"pubchem:water\") Specify your compute job using an AtomicInput object More details about the AtomicInput object can be found here . >>> from tccloud.models import AtomicInput >>> atomic_input = AtomicInput(molecule=water, model={\"method\": \"B3LYP\", \"basis\": \"6-31g\"}, driver=\"energy\") Submit a computation, specify a target quantum chemistry engine, and get back an AtomicResult >>> future_result = client.compute(atomic_input, engine=\"terachem_pbs\") >>> future_result.status 'STARTED' # Get result >>> result = future_result.get() # Successful computation >>> result.success True >>> result AtomicResult(driver='energy', model={'method': 'B3LYP', 'basis': '6-31g'}, molecule_hash='b6ec4fa') >>> result.return_result -76.38545794119997 # Failed computation >>> result.success False # View result >>> result FailedOperation(error=ComputeError(error_type='input_error', error_message='QCEngine Input Error: Traceback (most recent call last):...')) >>> from pprint import pprint >>> pprint(result.error.error_message) Putting it all together >>> from tccloud import TCClient >>> from tccloud.models import AtomicInput, Molecule >>> client = TCClient() >>> client.configure() # only run the very first time you use TCClient >>> water = Molecule.from_data(\"pubchem:water\") >>> atomic_input = AtomicInput(molecule=water, model={\"method\": \"B3LYP\", \"basis\": \"6-31g\"}, driver=\"energy\") >>> future_result = client.compute(atomic_input, engine=\"terachem_pbs\") >>> result = future_result.get() >>> result AtomicResult(driver='energy', model={'method': 'B3LYP', 'basis': '6-31g'}, molecule_hash='b6ec4fa') >>> result.return_result -76.38545794119997 Licence This project is licensed under the terms of the MIT license.","title":"tccloud"},{"location":"#tccloud","text":"A Python Client for TeraChem Cloud. tccloud is a python client that makes performing quantum chemistry calculations easy, fast, and fun. All input and output data structures are based on the QCSchema specification designed by The Molecular Sciences Software Institute . The client provides a simple, yet powerful interface to perform quantum chemistry calculation using nothing but modern python and an internet connection. Compute is generously provided free of charge by the TeraChem Cloud project.","title":"tccloud"},{"location":"#requirements","text":"Python 3.6+ tccloud stands on the shoulders of giants. It internally depends upon QCElemental , httpx , and toml . The AtomicInput , Molecule , Model , and AtomicResult models used throughout the package come directly from QCElemental . They are included in tccloud.models for your convenience.","title":"Requirements"},{"location":"#installation","text":"pip install tccloud","title":"Installation"},{"location":"#example","text":"","title":"Example"},{"location":"#the-absolute-minimum","text":"Create a TeraChem Cloud account at https://tccloud.mtzlab.com/signup. Instantiate a client Configure client (only required the very first time you use TCClient ) >>> from tccloud import TCClient >>> client = TCClient() >>> client.configure() # See supported compute engines >>> client.supported_engines ['psi4', 'terachem_pbs', ...] # Test connection to TeraChem Cloud >>> client.hello_world(\"Colton\") 'Welcome to TeraChem Cloud, Colton' Create a Molecule More details about the Molecule object can be found here and here . Molecules can be created from pubchem , local files, or using pure python. >>> from tccloud.models import Molecule >>> water = Molecule.from_data(\"pubchem:water\") Specify your compute job using an AtomicInput object More details about the AtomicInput object can be found here . >>> from tccloud.models import AtomicInput >>> atomic_input = AtomicInput(molecule=water, model={\"method\": \"B3LYP\", \"basis\": \"6-31g\"}, driver=\"energy\") Submit a computation, specify a target quantum chemistry engine, and get back an AtomicResult >>> future_result = client.compute(atomic_input, engine=\"terachem_pbs\") >>> future_result.status 'STARTED' # Get result >>> result = future_result.get() # Successful computation >>> result.success True >>> result AtomicResult(driver='energy', model={'method': 'B3LYP', 'basis': '6-31g'}, molecule_hash='b6ec4fa') >>> result.return_result -76.38545794119997 # Failed computation >>> result.success False # View result >>> result FailedOperation(error=ComputeError(error_type='input_error', error_message='QCEngine Input Error: Traceback (most recent call last):...')) >>> from pprint import pprint >>> pprint(result.error.error_message) Putting it all together >>> from tccloud import TCClient >>> from tccloud.models import AtomicInput, Molecule >>> client = TCClient() >>> client.configure() # only run the very first time you use TCClient >>> water = Molecule.from_data(\"pubchem:water\") >>> atomic_input = AtomicInput(molecule=water, model={\"method\": \"B3LYP\", \"basis\": \"6-31g\"}, driver=\"energy\") >>> future_result = client.compute(atomic_input, engine=\"terachem_pbs\") >>> result = future_result.get() >>> result AtomicResult(driver='energy', model={'method': 'B3LYP', 'basis': '6-31g'}, molecule_hash='b6ec4fa') >>> result.return_result -76.38545794119997","title":"The Absolute Minimum"},{"location":"#licence","text":"This project is licensed under the terms of the MIT license.","title":"Licence"},{"location":"about/","text":"About The about page, yo!","title":"About"},{"location":"about/#about","text":"The about page, yo!","title":"About"},{"location":"development/core_decisions/","text":"Core Development Decisions _RequestsClient Class _RequestsClient public http methods (like compute() and result() should always return Python objects. This gives a layer of abstraction between callers who want to think in terms of Python data objects and the _RequestsClient which thinks in terms of http requests and json data structures. FutureResult Class .get() will return either an AtomicResult or a FailedOperation object. From the users perspective they essentially get back a generic \"Result\" object (which will be either an AtomicResult or FailedOperation ) and can check for its status (once complete) by checking result.status . While this separates the user a bit from the \"status\" field returned by the API, I think this is the easiest user interface, i.e., they get back a result from a future_result and can check its status very simply without having to think separately about status fields and results fields They can still access the API returned status field at future_result.status if needed. E.g.,: result = future_result.get() result.success False # If FailedOperation returned result.success True # If AtomicResult returned","title":"Core Development Decisions"},{"location":"development/core_decisions/#core-development-decisions","text":"","title":"Core Development Decisions"},{"location":"development/core_decisions/#_requestsclient-class","text":"_RequestsClient public http methods (like compute() and result() should always return Python objects. This gives a layer of abstraction between callers who want to think in terms of Python data objects and the _RequestsClient which thinks in terms of http requests and json data structures.","title":"_RequestsClient Class"},{"location":"development/core_decisions/#futureresult-class","text":".get() will return either an AtomicResult or a FailedOperation object. From the users perspective they essentially get back a generic \"Result\" object (which will be either an AtomicResult or FailedOperation ) and can check for its status (once complete) by checking result.status . While this separates the user a bit from the \"status\" field returned by the API, I think this is the easiest user interface, i.e., they get back a result from a future_result and can check its status very simply without having to think separately about status fields and results fields They can still access the API returned status field at future_result.status if needed. E.g.,: result = future_result.get() result.success False # If FailedOperation returned result.success True # If AtomicResult returned","title":"FutureResult Class"},{"location":"usage/TCClient/","text":"TCClient The TCClient is the main way you will interact with TeraChem Cloud to make compute requests.","title":"TCClient"},{"location":"usage/TCClient/#tcclient","text":"The TCClient is the main way you will interact with TeraChem Cloud to make compute requests.","title":"TCClient"},{"location":"usage/authentication/","text":"Authentication Authentication is the process of supplying your credentials (usually a username and password) to tccloud so that you can perform computation. tccloud provides a few easy ways for you to authenticate.","title":"Authentication"},{"location":"usage/authentication/#authentication","text":"Authentication is the process of supplying your credentials (usually a username and password) to tccloud so that you can perform computation. tccloud provides a few easy ways for you to authenticate.","title":"Authentication"}]}